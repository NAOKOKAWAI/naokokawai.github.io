{"meta":{"title":"谢朴欢","subtitle":null,"description":"个人技术博客","author":"谢朴欢","url":"https://xiepuhuan.github.io"},"pages":[{"title":"categories","date":"2018-11-16T10:31:06.997Z","updated":"2018-11-16T10:31:06.953Z","comments":true,"path":"categories/index.html","permalink":"https://xiepuhuan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"高拓展性的Java多线程爬虫框架reptile(个人开源项目)","slug":"高拓展性的Java多线程爬虫框架reptile","date":"2019-05-20T10:59:53.000Z","updated":"2019-05-20T10:59:53.000Z","comments":true,"path":"2019/05/20/高拓展性的Java多线程爬虫框架reptile/","link":"","permalink":"https://xiepuhuan.github.io/2019/05/20/高拓展性的Java多线程爬虫框架reptile/","excerpt":"","text":"简介 项目地址: https://github.com/xiepuhuan/reptileReptile是一个具有高拓展性的可支持单机与集群部署Java多线程爬虫框架，该框架可简化爬虫的开发流程。该框架各个组件高内聚松耦合的特性让用户可以对不同组件进行定制来满足不同的需求。 架构 Reptile.png Reptile作为爬虫主体可在主线程运行也可以异步运行，爬虫主要有四个核心组件： Scheduler执行请求调度，可以往其添加新的爬取请求，并支持去重处理 Downloader执行请求下载与解析响应 ResponseHandler由使用者提供实现来对响应处理，形成Result结果与新的爬取请求Request Consumer来对处理的结果Result进行消费，例如持久化存储，用户可自定义其具体实现 四个组件之间的关系如架构图所示，它们之间的互相调用形成一个完整的工作流并在Workflow线程中运行，Reptile爬虫会根据配置的线程数量通过线程池创建指定数量的工作流线程并发执行工作流任务。 特性 模块化设计，具有高度拓展性 支持单机多线程部署 支持简单集群部署 配置简单清晰 单机部署时，请求爬取完毕并且无其他线程产生新请求时会自动停止并清除理资源 整合Jsoup，支持HTML页面解析 请求调度器支持URL或请求的去重处理，提供布隆过滤器与集合去重实现，默认使用布隆过滤器，可在配置类进行指定 支持设置UserAgent池与Proxy池，并且可设置请求对UserAgent与Proxy的选择策略，如随机或循环顺序选择 快速开始使用Maven clone项目并构建发布到本地仓库 123git clone git@github.com:xiepuhuan/reptile.gitcd reptilemvn -Dmaven.test.skip=true 在项目中使用Maven引入对应的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.xiepuhuan&lt;/groupId&gt; &lt;artifactId&gt;reptile&lt;/artifactId&gt; &lt;version&gt;0.2&lt;/version&gt;&lt;/dependency&gt; 使用方式 实现ResponseHandler接口，重写isSupport与handle方法。 isSupport方法根据request和response参数判断是否需要处理该响应，是则返回true，否则返回false。 handle方法处理该响应，并将处理结果存储到result，如果从响应中有提取到要爬取的新请求则将其作为返回值返回。 如果没有找到支持处理该响应的处理器则响应会被忽略。 实现Consumer接口，重写consume方法，执行对数据的消费，可在该方法中对响应处理结果进行持久化等操作，目前提供了ConsoleConsumer与JsonFileConsumer等实现，默认使用ConsoleConsumer。 示例单机部署123456789101112131415161718192021222324252627282930313233343536373839404142public class ZhihuPageHandler implements ResponseHandler &#123; private static final String[] URLS = new String[] &#123; \"https://www.zhihu.com/api/v4/search_v3?t=general&amp;q=java\" &#125;; @Override public List&lt;Request&gt; handle(Response response, Result result) &#123; Content content = response.getContent(); JSONObject jsonObject = JSON.parseObject(content.getContent(), JSONObject.class); result.setResults(jsonObject.getInnerMap()); JSONObject paging = jsonObject.getJSONObject(\"paging\"); if (!paging.getBoolean(\"is_end\")) &#123; List&lt;Request&gt; requests = new ArrayList&lt;&gt;(); requests.add(new Request(paging.getString(\"next\"))); return requests; &#125; return null; &#125; @Override public boolean isSupport(Request request, Response response) &#123; return true; &#125; public static void main(String[] args) throws IOException, InterruptedException &#123; // 构建Reptile爬虫配置类， ReptileConfig config = ReptileConfig.Builder.cutom() .setThreadCount(8) .appendResponseHandlers(new ZhihuPageHandler()) .setDeploymentMode(DeploymentModeEnum.SINGLE) .setConsumer(new ConsoleConsumer()) .build(); // 构建Reptile爬虫对象并添加初始爬取URL Reptile reptile = Reptile.create(config).addUrls(URLS); // 启动爬虫 reptile.start(); &#125;&#125; 分布式部署分布式部署时，创建配置类时需要通过setDeploymentMode方法指定部署模式为DeploymentModeEnum.Distributed，并且需要通过setScheduler方法设置一个Redis队列调度器，可以使用RedisFIFOQueueScheduler作为实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ZhihuPageHandler implements ResponseHandler &#123; private static final String[] URLS = new String[] &#123; \"https://www.zhihu.com/api/v4/search_v3?t=general&amp;q=java\" &#125;; @Override public List&lt;Request&gt; handle(Response response, Result result) &#123; Content content = response.getContent(); JSONObject jsonObject = JSON.parseObject(content.getContent(), JSONObject.class); result.setResults(jsonObject.getInnerMap()); JSONObject paging = jsonObject.getJSONObject(\"paging\"); if (!paging.getBoolean(\"is_end\")) &#123; List&lt;Request&gt; requests = new ArrayList&lt;&gt;(); requests.add(new Request(paging.getString(\"next\"))); return requests; &#125; return null; &#125; @Override public boolean isSupport(Request request, Response response) &#123; return true; &#125; public static void main(String[] args) throws IOException, InterruptedException &#123; // 构建Reptile爬虫配置类， ReptileConfig config = ReptileConfig.Builder.cutom() .setThreadCount(8) .appendResponseHandlers(new ZhihuPageHandler()) .setDeploymentMode(DeploymentModeEnum.Distributed) .setScheduler(new RedisFIFOQueueScheduler()) .setConsumer(new ConsoleConsumer()) .build(); // 构建Reptile爬虫对象并添加爬去的URL Reptile reptile = Reptile.create(config).addUrls(URLS); // 启动爬虫 reptile.start(); &#125;&#125;","categories":[{"name":"项目","slug":"项目","permalink":"https://xiepuhuan.github.io/categories/项目/"}],"tags":[]},{"title":"Redis底层数据结构实现","slug":"Redis底层数据结构实现","date":"2018-11-15T12:39:13.000Z","updated":"2018-11-15T12:39:13.000Z","comments":true,"path":"2018/11/15/Redis底层数据结构实现/","link":"","permalink":"https://xiepuhuan.github.io/2018/11/15/Redis底层数据结构实现/","excerpt":"","text":"1. 简介Redis是一个基于内存的非关系型的键值对数据库，因它基于内存的特性所以它的速度比传统的关系型数据库快，除此之外它还具有许多特性： 支持事务 支持AOF和RDB持久化 支持多种数据数据结构 流水线、发布\\订阅功能 主从复制 内存回收 本文讲的是Redis丰富的数据结构的实现原理 实现五种基本类型Redis是一个键值对数据库，而键都是字符串（Redis内部实现的简单动态字符串）类型，值有5种基本类型，分别是： STRING（字符串） LIST（列表） SET（集合） ZSET（有序集合） HASH（哈希） 不同类型的不同实现 类型 编码 STRING（字符串） INT（整型） STRING（字符串） EMBSTR（简单动态字符串） STRING（字符串） RAW（简单动态字符串） LIST（列表） QUICKLIST（快表） LIST（列表） LINKEDLIST（快表） SET（集合） INTSET（整数集合） SET（集合） HT（哈希表） ZSET（有序集合） ZIPLIST（压缩列表） ZSET（有序集合） SKIPLIST（跳表） HASH（哈希） ZIPLIST（压缩列表） HASH（哈希） HT（哈希表） redisObject在Redis中，这5种基本类型的对象都是封装在robj这个结构体中，源码如下： 12345678910111213141516171819202122232425262728293031323334typedef struct redisObject &#123; // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 对象最后一次被访问的时间 unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */ // 引用计数，用于内存回收与对象共享 int refcount; // 指向实际值的指针 void *ptr;&#125; robj;// 通过调用createObject方法可以创建其对象robj *createObject(int type, void *ptr) &#123; robj *o = zmalloc(sizeof(*o)); o-&gt;type = type; o-&gt;encoding = OBJ_ENCODING_RAW; o-&gt;ptr = ptr; o-&gt;refcount = 1; /* Set the LRU to the current lruclock (minutes resolution), or * alternatively the LFU counter. */ if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123; o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;8) | LFU_INIT_VAL; &#125; else &#123; o-&gt;lru = LRU_CLOCK(); &#125; return o;&#125; 下面解释下各个属性： type该属性表示对象的类型，占4个bit，源码如下： 12345#define REDIS_STRING 0#define REDIS_LIST 1#define REDIS_SET 2#define REDIS_ZSET 3#define REDIS_HASH 4 在Redis中通过使用TYPE命令可以获得其类型 127.0.0.1:6379&gt; TYPE key string encoding该属性表示该类型的对象具体的实现，这样做的目的是为了使在不同场景下灵活使用不同的数据结构 123456789#define REDIS_ENCODING_RAW 0 /* Raw representation */#define REDIS_ENCODING_INT 1 /* Encoded as integer */#define REDIS_ENCODING_HT 2 /* Encoded as hash table */#define REDIS_ENCODING_ZIPMAP 3 /* Encoded as zipmap */#define REDIS_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */#define REDIS_ENCODING_ZIPLIST 5 /* Encoded as ziplist */#define REDIS_ENCODING_INTSET 6 /* Encoded as intset */#define REDIS_ENCODING_SKIPLIST 7 /* Encoded as skiplist */#define REDIS_ENCODING_EMBSTR 8 /* Embedded sds string encoding */ 在Redis中通过使用OBJECT ENCODING命令可以获得其编码 127.0.0.1:6379&gt; OBJECT ENCODING key “embstr” lru该属性记录该对象最近一次被访问的时间，如果服务器打开了maxmemory选项，并且服务器用于内存回收的算法为volatile-lru或allkeys-lru，当占用内存超过maxmemory设置的上限时，最早被访问的会先被释放。 在Redis中通过使用OBJECT IDLETIME命令可以获得其lru时间 127.0.0.1:6379&gt; OBJECT IDLETIME key (integer) 10155 refcount该属性有两个作用： 用于引用计数实现内存回收，该属性值表示对象被多少个程序引用，当对象被创建时，该属性值为1，当该值为0时对象占用的内存会被回收。 用于对象共享，比如Redis在初始化服务器时就会创建0到9999的字符串对象用于对象共享，每当使用set命令创建一个新字符串对象，如果要创建的字符串已经存在则将指向值的指针指向该字符串对象，并将该对象的refcount加1。 127.0.0.1:6379&gt; OBJECT REFCOUNT key (integer) 2 REDIS_STRING（字符串）Redis的字符串一共有三种实现方式，分别适用于不同场景，其中有一种实现是简单动态字符串，简称SDS，下面的结构体sdshdr就表示一个SDS，它具有以下几个优点： 常数时间获取字符串长度 自动扩容 预分配空间以减少内存重新分配次数 二进制安全 重用部分C语言函数库 12345678910struct sdshdr &#123; // buf 中已占用空间的长度 int len; // buf 中剩余可用空间的长度 int free; // 数据空间 char buf[];&#125;; INT当字符串保存的是一个可以用long类型来表示的整数时，那么robj对象里的属性ptr的类型void *就会被替换为long，而encoding的值会设置为int表示该字符串的实现方式是整型。 127.0.0.1:6379&gt; SET key 88 OK 127.0.0.1:6379&gt; OBJECT ENCODING key “int” EMBSTR在目前最新版本中，当字符串保存的是一个小于等于44个字节的字符串时，那么robj对象里的属性ptr就会指向一个SDS对象，而encoding的值会设置为embstr表示该字符串的实现方式是SDS（简单动态字符串）。embstr是一种用来保存短字符串的编码方式，embstr编码通过调用一次内存分配函数来创建一块连续的内存空间，即redisObject对象和它的ptr指针指向的SDS对象是连续的。不过embstr编码的字符串对象是只读性的，一旦对其指向APPEND命令追加字符串会导致其变为raw编码实现。 embstr编码创建的内存块结构 127.0.0.1:6379&gt; SET key value OK 127.0.0.1:6379&gt; OBJECT ENCODING key “embstr” RAW在目前最新版本中，当字符串对象保存的是一个超过44个字节的字符串时，那么robj对象里的属性ptr就会指向一个SDS对象，而encoding的值会设置为raw表示该字符串的实现方式是SDS（简单动态字符串）。raw编码的字符串对象是可读可写的，对其指向APPEND命令追加字符串会不会导致其实现改变，如果追加的字符串的长度超过其free属性值，会在追加前重新进行内存空间分配。 127.0.0.1:6379&gt; SET key value OK 127.0.0.1:6379&gt; OBJECT ENCODING key “raw”","categories":[{"name":"Redis","slug":"Redis","permalink":"https://xiepuhuan.github.io/categories/Redis/"}],"tags":[]},{"title":"ThreadPoolExecutor源码解析","slug":"ThreadPoolExecutor源码解析","date":"2018-05-03T08:35:02.000Z","updated":"2018-05-03T08:35:02.000Z","comments":true,"path":"2018/05/03/ThreadPoolExecutor源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/05/03/ThreadPoolExecutor源码解析/","excerpt":"","text":"1. 简介在引入线程池之前，我们先来了解几个事情： 线程的创建和销毁是有代价的，如线程创建需要时间和相关计算资源。如果在Web服务器上为每个来到的请求都创建一个线程，而大多数请求都是轻量级的处理过程。那么创建线程的代价与请求处理的代价相比就非常大了，导致影响整体性能。 当线程数量达到能让CPU忙绿起来的时候，此时再创建线程，线程也基本处于闲置状态，这时候多出来的线程除了占用内存外，还可能因为与其他线程争用CPU资源导致出现其他性能开销. 在可创建线程的数量上存在一个限制，如果超过这个限制，可能会抛出OutOfMemoryError异常。 这时候如果能出现一个东西能够对线程的生命周期进行管理，对现有的线程重复利用，并且能够以一种简单的方式将任务的提交与执行相解耦。没错，这就是线程池(Thread Pool)，在要了解Java中的线程池，首先必须了解ThreadPoolExecutor这个类。 2. ThreadPoolExecutor详解类继承图 ThreadPoolExecutor类继承 构造函数12345678910111213141516171819202122232425262728293031323334353637//线程池配置信息，volatile修饰保证变量在多线程下的可见性private volatile int corePoolSize;private volatile int maximumPoolSize;private volatile long keepAliveTime;private final BlockingQueue&lt;Runnable&gt; workQueue;private volatile ThreadFactory threadFactory;private volatile RejectedExecutionHandler handler;private static final RejectedExecutionHandler defaultHandler = new AbortPolicy();private static final RuntimePermission shutdownPerm = new RuntimePermission(\"modifyThread\");public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; 从上面的JDK中ThreadPoolExecutor类的构造函数源码看出该构造函数一共有7个参数，下面介绍七个参数的含义： 参数 含义 corePoolSize 基本大小，即线程池中的核心线程数 maximumPoolSize 最大大小，即线程池中允许的最大线程数 keepAliveTime 存活时间，当线程的没执行任务时，空闲的时间超过了这个时间就会被标记为可回收，直到线程池的大小超过基本大小，被标记的线程就会被终止 unit keepAliveTime的单位，有DAYS、HOURS、MINUTES、SECONDS、MILLISECONDS、MICROSECONDS、NANOSECONDS7个单位可选 workQueue 工作队列，一个用来保存等待被执行的任务的阻塞队列 threadFactory 线程工厂。线程池在创建线程时通过调用线程工厂的Thread newThread(Runnable r)来创建线程 handler 饱和策略。当阻塞队列已满、线程池当前的线程数已达到最大值且没有线程处于空闲状态时，此时对于提交过来的任务将执行饱和策略。（如果某个任务提交到一个已关闭的Executor时，也会执行饱和策略） ThreadPoolExecutor类中有四个重载的构造函数，每个构造函数都必须指定上表中的前5个参数，最后两个参数可以随意指定，不指定的话构造函数会使用默认的线程工厂和饱和策略： 线程工厂(ThreadFactory)线程池创建线程都是通过的ThreadFactory的Thread newThread(Runnable r)方法来创建的。下面是Executors类里的默认线程工厂方法的源码。 1234567891011121314151617181920212223242526static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 从上面可以看出默认线程工厂创建出的是一个非守护、优先级为Thread.NORM_PRIORITY 的线程。如果想要自己定制线程工厂满足需求，只需实现ThreadFactory接口的Thread newThread(Runnable r)方法。 饱和策略(RejectedExecutionHandler)JDK中的ThreadPoolExecutor类提供了4种不同的RejectedExecutionHandler实现： AbortPolicy默认的饱和策略，该策略抛出未检查（运行时异常）的RejectedExecutionException。 DiscardPolicy 不执行任何操作，直接抛弃任务 CallerRunsPolicy 在调用者线程中执行该任务 DiscardOldestPolicy 丢弃阻塞队列中的第一个任务， 然后重新将该任务交给线程池执行 同样的，可以通过实现RejectedExecutionHandler接口自定义饱和策略。 线程池状态和线程数量1234567891011121314151617181920212223242526272829303132333435363738394041424344//代表线程池当前状态和线程数量的原子变量private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3; //COUNT_BITS为29private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; //CAPACITY为能表示的最大线程数。//线程池状态private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;//对线程池状态和线程数量进行打包和拆包的函数：private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;//判断线程池状态的三个函数private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s;&#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s;&#125;private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125;//线程数量增1，成功返回true，失败返回falseprivate boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1); &#125;//线程数量减1，成功返回true，失败返回falseprivate boolean compareAndDecrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect - 1);&#125;//线程数量减1，失败则重试直到成功private void decrementWorkerCount() &#123; do &#123;&#125; while (! compareAndDecrementWorkerCount(ctl.get()));&#125; AtomicInteger类型的变量ctl用高3位来表示当前线程池状态，低29位来表示当前的线程数。 Java线程池有5种不同的状态，分别为运行(RUNNING)、关闭(SHUTDOWN)、停止(STOP)、整理(TIDYING)、结束(TERMINATED)。在ThreadPoolExecutor里由5个整型常量表示，每个整型常量的都由高3位表示状态： RUNNING 高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务 SHUTDOWN 高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务。调用void shutdown()方法实现 STOP 高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务。调用List&lt;Runnable&gt; shutdownNow()实现。 TIDYING 高3位为010，当线程池关闭后阻塞队列的任务已完成或线程池停止，然后workerCount（当前线程数量)为0，线程池进入该状态后会调用terminated()方法进入TERMINATED状态。 TERMINATED 高3位为011启动线程池当创建完一个ThreadPoolExecutor对象后，线程池里并没有线程。一般都是调用void execute(Runnable command)执行任务时才创建线程并启动，不过可以通过调用如下方法预先创建核心线程并启动（在addWorker方法里启动）：123456public int prestartAllCoreThreads() &#123; int n = 0; while (addWorker(null, true)) ++n; return n; &#125; 执行过程 执行过程 如上图所示，当调用void execute(Runnable command)这个方法执行任务时： 判断当前线程池线程数量是否小于核心线程池大小，是则创建线程并启动，否则到第2步 判断任务队列是否已满，未满则将任务加入阻塞队列，已满则到第3步 判断当前线程池线程数量是否小于最大线程池大小，是则创建线程并启动，否则执行饱和策略 123456789101112131415161718192021222324252627282930public void execute(Runnable command) &#123; //任务为空，抛出空指针异常 if (command == null) throw new NullPointerException(); int c = ctl.get(); //判断当前线程数量是否小于核心线程数 if (workerCountOf(c) &lt; corePoolSize) &#123; //是则添加一个核心线程(true表示核心线程)到线程池，并且启动线程执行任务（addWorker方法里会启动） if (addWorker(command, true)) return; //添加成功则返回 c = ctl.get(); &#125; //线程池处于运行状态则向阻塞队列添加该任务 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //判断线程池是否处于运行状态，不是就移除刚才添加的任务 if (! isRunning(recheck) &amp;&amp; remove(command)) //移除成功就执行饱和策略，这样整个方法就结束了 reject(command); //否则若处于运行状态或移除失败，这时无论处于哪种情况任务都在阻塞队列里，判断当前线程数量是否为0 else if (workerCountOf(recheck) == 0) 若是则添加一个线程并启动 addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command);&#125; addWorker方法boolean addWorker(Runnable firstTask, boolean core)方法的作用就是创建Worker对象并启动这个对象里的线程（Worker里一个Thread类型的字段）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private final ReentrantLock mainLock = new ReentrantLock();private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();private int largestPoolSize;private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //如果线程池不处于运行状态，理论上不应该添加一个执行该任务的线程，但如果满足下面三个条件的话就可以通过： 1. 线程池状态是关闭 2. 要执行的任务为空 3. 阻塞队列不为空 因为线程池关闭后不允许提交任务，但关闭后会执行完阻塞队列的任务，所以允许添加一个firstTask为空的线程 来帮助执行完阻塞队列里的任务 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); //若当前线程池的线程数量达到了线程池所允许的最大线程数或所指定要添加线程类型的线程数量则返回false if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //到这里前面的限制条件都通过，现在尝试将线程数量增一，成功则退出最外层的循环 if (compareAndIncrementWorkerCount(c)) break retry; //失败则重新获取线程池状态，状态改变则从最外层循环开始执行，不变则从内循环开始执行 c = ctl.get(); if (runStateOf(c) != rs) continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //构造一个Worker对象，每个Worker对象绑定一个线程 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); //若线程池处于运行状态或处于关闭且firstTask为null if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; 线程提前启动，则抛出异常 if (t.isAlive()) throw new IllegalThreadStateException(); //将w加到Worker的集合里 workers.add(w); 获取Worker集合大小，若大小比largestPoolSize大小大，则更新一下 int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; //添加成功 workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; //若添加成功则启动线程 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; //若启动失败（t线程为空或添加过程中抛出异常）则执行addWorkerFailed方法 if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; Worker类线程池维护的线程其实是一组Worker对象，Worker封装了线程也继承了AbstractQueuedSynchronizer类并实现了Runnable接口，重写了void run()方法。至于为什么要继承AbstractQueuedSynchronizer类，请看下面的runWorker方法讲解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123; private static final long serialVersionUID = 6138294804551838833L; final Thread thread; Runnable firstTask; //绑定这个对象线程已执行完成的任务数 volatile long completedTasks; Worker(Runnable firstTask) &#123; //阻止中断，在任务获取前不允许中断 setState(-1); this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; //线程启动时执行的方法 public void run() &#123; runWorker(this); &#125; protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; //获取锁，不可重入 public void lock() &#123; acquire(1); &#125; //尝试获取锁 public boolean tryLock() &#123; return tryAcquire(1); &#125; //释放锁 public void unlock() &#123; release(1); &#125; //判断锁是否被独占 public boolean isLocked() &#123; return isHeldExclusively(); &#125; //中断已开始执行的线程，这个就是为什么要设置setState(-1)的一个原因了，这个方法会被`shutdownNow()`方法调用。 void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125;&#125; runWorker方法上面说到为什么Worker类要继承AbstractQueuedSynchronizer，其实是要用锁的状态来区分空闲线程和非空闲线程，在执行runWorker方法中： 获取任务时没有加锁（空闲状态，可中断线程） 要执行任务时才加锁（不允许中断线程） 在调用void tryTerminate()和void shutdown()这两个方法时，会中断空闲线程，所以没有在执行任务的线程就可能被中断。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); //允许中断，与Worker构造函数的setState(-1)是一对的 boolean completedAbruptly = true; try &#123; //获取到任务才进入循环 while (task != null || (task = getTask()) != null) &#123; //加锁，表示非空闲状态 w.lock(); //1. 如果线程池状态大于等于STOP并且本线程未中断，则应该执行中断方法 2. 或者执行Thread.interrupted()方法判断本线程是否中断并且清除中断状态， 如果发现线程池状态大于等于STOP则执行中断方法。 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //ThreadPoolExecutor中的beforeExecute(wt, task)方法一个空方法，用来留给继承ThreadPoolExecutor的类 来重写该方法并在任务执行前执行 beforeExecute(wt, task); Throwable thrown = null; try &#123; //执行获取到的任务 task.run();![](https://user-gold-cdn.xitu.io/2017/12/30/160a72c7c9f35844?w=977&amp;h=318&amp;f=png&amp;s=14007) &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //ThreadPoolExecutor中的afterExecute(task,thrown)方法也是一个空方法，用来留给继承 ThreadPoolExecutor的类来重写该方法并在任务执行后执行 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; //该线程执行的任务加1，即使抛出异常 w.completedTasks++; //释放锁，表示回到空闲状态 w.unlock(); &#125; &#125; //执行到这一步表示是由于获取不到任务而正常退出的，所以completedAbruptly为false completedAbruptly = false; &#125; finally &#123; //无论怎样退出都要执行 processWorkerExit(w, completedAbruptly); &#125;&#125; getTask方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Runnable getTask() &#123; //表示获取任务是否已超时 boolean timedOut = false; for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //1. 若线程池状态大于等于停止状态，此时线程池不再处理队列的任务，并且会回收所有线程（不管空不空闲）， 所以此时应该把线程池线程数量减1，并且获取的任务为空 //2. 处于关闭状态且任务队列为空，表示任务队列为空且不会有任务提交，所以线程数减1，并且获取的任务为空 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); //是否启用超时机制。当允许核心线程超时或当前线程数超过核心线程则启用 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //如果线程数量超过线程池所允许的最大线程数或者启用超时机制情况下获取任务超时，理论上应该回收线程。 但是如果该线程是线程池中的最后一个线程且任务队列不为空就可以不回收，继续运行，要是还有其他线程或者任务队列为空则回收该线程。 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //尝试将线程数量减1，成功返回null，失败继续从循环开始处开始。这里为什么不是用decrementWorkerCount() 这种不会失败的方法减1而采用这种方式。是因为 wc &gt; 1，如果线程池不只有一个线程它们互相发现不只一个线程， 且它们同时执行不会失败的将线程数量减一的方法，到时线程池线程数量可能就为0了，哪么队列中的任务就没线程执行了。 if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //1. 如果启用超时机制就执行poll()方法，在keepAliveTime纳秒内还没获取就返回null。 2. 如果未启用超时机制就执行take()方法，队列没任务就一直阻塞直到有任务。 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; //到这里就是因为超时获取不到任务 timedOut = true; &#125; catch (InterruptedException retry) &#123; //在执行take()过程中被中断并不算超时 timedOut = false; &#125; &#125;&#125; processWorkerExit方法12345678910111213141516171819202122232425262728293031323334private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //由于不是获取不到任务而正常退出的，得在这里将线程数减1，正常退出的在getTask()方法有这个减1操作 if (completedAbruptly) decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; //加锁，因为HashSet和completedTaskCount不是线程安全的 mainLock.lock(); try &#123; //将线程执行的任务数统一加到线程池维护的completedTaskCount字段 completedTaskCount += w.completedTasks; workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; //尝试将线程池设置为结束状态 tryTerminate(); int c = ctl.get(); //满足当前线程池状态小于STOP（运行或关闭状态）才继续 if (runStateLessThan(c, STOP)) &#123; 若线程是异常退出runWorker方法就直接添加一个没有带初始任务的非核心线程 if (!completedAbruptly) &#123; //这三行代码找出当前线程池所至少存在的线程数 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) min = 1; //如果当前线程数已经大于等于min，就直接返回，否则添加一个没有带初始任务的非核心线程 if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; addWorker(null, false); &#125;&#125; 下图是向线程池提交任务后，线程池的正常执行过程： 线程池正常运行过程 tryTerminate方法 线程池状态转换 terminate（结束）是线程池的最后一个状态，只能由关闭或停止状态转变为结束状态。123456789101112131415161718192021222324252627282930313233343536373839final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get(); //如果满足下面任意一个条件就没办法到达结束状态 1. 线程池处于运行状态 2. 线程池状态是TIDYING或已经是结束状态 3. 线程池处于关闭状态且任务队列不为空 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; //当前线程数量不为0也无法到达结束状态 if (workerCountOf(c) != 0) &#123; //中断一个空闲线程 interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //尝试将线程池状态设置为TIDYING，失败重循环开始处开始 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; //terminated()是一个空方法，留给继承ThreadPoolExecutor的类覆盖 terminated(); &#125; finally &#123; //尝试将线程池状态设置为TERMINATED ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125;&#125; 关闭操作我们可以通过调用void shutdown()方法关闭线程池，关闭后线程池后不允许接受新任务1234567891011121314151617public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 安全策略判断 checkShutdownAccess(); //设置线程池状态为SHUTDOWN状态 advanceRunState(SHUTDOWN); //中断所有空闲线程 interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; //尝试结束线程池 tryTerminate();&#125; 停止操作我们可以在运行和关闭状态下通过调用void shutdownNow()方法停止线程池，停止后线程池后不允许接受新任务，也不会执行阻塞队列里的任务，还会中断当前所有的线程。1234567891011121314151617181920public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // 安全策略判断 checkShutdownAccess(); //设置线程池状态为STOP状态 advanceRunState(STOP); //中断所有线程，不管是空闲还是非空闲 interruptWorkers(); //取出阻塞队列的所有任务 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; //尝试结束线程池 tryTerminate(); return tasks;&#125; 3. 线程池的配置Executors提供了四种静态工厂方法来创建四种不同配置的线程池： newFixedThreadPool(int nThreads) 接受一个int类型的nThreads变量，创建一个核心线程数和最大线程数都为nThreads的线程池（即最大线程数为nThreads），且使用一个无界的阻塞队列LinkedBlockingQueue。如果不设置核心线程超时的话，创建的线程是不会超时的。 123public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newSingleThreadExecutor() 创建一个核心线程数和最大线程数都为1的线程池（即最大线程数为1)，且使用一个无界的阻塞队列LinkedBlockingQueue，不设置核心线程超时的话，创建的线程也是不会超时的。唯一线程可以保证任务的顺序执行，如果这个唯一的线程执行过程中因为异常而结束的话，在processWorkerExit方法最后会判断是否因异常而结束而创建一个新线程继续运行。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; newCachedThreadPool() 创建一个核心线程数为0，最大线程数为Integer.MAX_VALUE的线程池，超时时间为60秒，所以线程空闲时间超过60秒就会被回收。使用了一个同步队列作为阻塞队列，同步队列不存储元素，且在一端进行插入，另一端要有移除操作插入才会成功，否则插入操作会阻塞等待。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; newScheduledThreadPool() 创建一个核心线程数为corePoolSize的线程池，用于指定的时间内周期性的执行所的任务。ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"ReentrantLock源码解析","slug":"ReentrantLock源码解析","date":"2018-05-01T13:54:43.000Z","updated":"2018-05-01T13:54:43.000Z","comments":true,"path":"2018/05/01/ReentrantLock源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/05/01/ReentrantLock源码解析/","excerpt":"","text":"1. 简介 ReentrantLock与synchronized关键字一样是可重入的独占锁，不过ReentrantLock提供比synchronized关键字更加灵活的获取锁和释放锁操作，并且支持等待多个条件，但ReentrantLock必须手动释放锁，否则很有可能造成死锁。在JDK6之后，synchronized加入了偏向锁、轻量级锁、自适应自旋、锁粗化、锁消除多种优化措施使它的性能提高了很多，通常情况下表现一般比ReentrantLock好，所以在能使用synchronized功能完成的操作时，尽量不要用ReentrantLock。 ReentrantLock中大部分方法是间接调用了AbstractQueuedSynchronizer的方法，所以要想进一步探究其实现可以看看上一篇文章AbstractQueuedSynchronizer源码解析 2. 实现继承关系ReentrantLock实现了Lock接口 1public class ReentrantLock implements Lock, java.io.Serializable &#123;&#125; Lock接口提供了锁最基本的几个方法，实现该接口的类都重写了这些方法 1234567891011121314public interface Lock &#123; // 阻塞获取锁 void lock(); // 阻塞获取锁，可响应中断抛出异常 void lockInterruptibly() throws InterruptedException; // 尝试获取锁 boolean tryLock(); // 尝试在指定时间内获取锁，获取不到则阻塞直到获取到锁返回true或超时返回false boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 释放锁 void unlock(); // 创建一个等待条件，获取锁的线程可以等待条件 Condition newCondition();&#125; 属性ReentrantLock中最重要的属性就是sync，sync是个实现抽象队列同步器AbstractQueuedSynchronizer抽象方法tryAcquire和tryRelease的类的对象，其中tryAcquire方法决定了是否公平、重入的特性，而tryRelease方法对公平与非公平重入锁都适用。ReentrantLock中方法的实现基本都是调用sync的方法。 1private final Sync sync; Sync类继承关系 Sync123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -5179523762034025860L; // 添加抽象方法lock abstract void lock(); // 添加非公平获取尝试同步状态的方法，该方法体现非公平性与重入特性 final boolean nonfairTryAcquire(int acquires) &#123; // 获取当前线程 final Thread current = Thread.currentThread(); // 获取当前同步状态 int c = getState(); // 如果没有线程获取同步状态 if (c == 0) &#123; // 使用CAS方法获取同步状态，这里体现非公平性，因为没有判断等待队列里是否有其他线程在等待获取同步状态 if (compareAndSetState(0, acquires)) &#123; // 获取成功则设置独占线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 否则当前线程已经获取过同步状态 else if (current == getExclusiveOwnerThread()) &#123; // 直接在原基础状态值加上acquires，体现重入性 int nextc = c + acquires; // 如果nextc小于0表示线程获取锁的次数已经超过最大值 if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); // 设置新的同步状态 setState(nextc); return true; &#125; return false; &#125; // 重写tryRelease方法，对应公平与非公平锁都适用，体现重入性 protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; // 判断当前线程是否独占锁 protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; // 创建等待条件 final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // 获取独占锁的线程 final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; // 获取当前线程加锁次数 final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; // 是否已加锁 final boolean isLocked() &#123; return getState() != 0; &#125; private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125;&#125;### NonfairSync// 非公平锁static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; final void lock() &#123; // 如果当前线程能直接获取同步状态，则设置当前线程为独占线程 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else // 否则再调用acquire获取同步状态 acquire(1); &#125; // 重写tryAcquire方法，调用nonfairTryAcquire方法 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; FairSync12345678910111213141516171819202122232425262728293031323334static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; // 重写tryAcquire方法，该方法体现公平性与重入特性 protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); // 如果还没有线程获取同步状态 if (c == 0) &#123; // 判断等待队列中是否有后继线程，没有再使用CAS方法获取同步状态， if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; // 获取成功设置当前线程为独占线程 setExclusiveOwnerThread(current); return true; &#125; &#125; // 否则当前线程已经获取过同步状态 else if (current == getExclusiveOwnerThread()) &#123; // 直接在原基础状态值加上acquires，体现重入性 int nextc = c + acquires; // 如果nextc小于0表示线程获取锁的次数已经超过最大值 if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); // 设置新的同步状态 setState(nextc); return true; &#125; return false; &#125;&#125; 构造函数123456789// 默认创建非公平锁public ReentrantLock() &#123; sync = new NonfairSync();&#125;// 根据指定参数创建公平或非公平锁public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 获取锁方法以下获取锁的方法都是调用Sync类的方法或或从抽象队列同步器继承的方法 1234567891011121314151617181920// 阻塞获取锁public void lock() &#123; sync.lock();&#125;// 中断获取锁public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1);&#125;// 尝试获取锁public boolean tryLock() &#123; return sync.nonfairTryAcquire(1);&#125;// 超时获取锁public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout));&#125; 释放锁方法123public void unlock() &#123; sync.release(1);&#125;","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"AbstractQueuedSynchronizer源码解析","slug":"AbstractQueuedSynchronizer源码解析","date":"2018-04-26T14:58:59.000Z","updated":"2018-04-26T14:58:59.000Z","comments":true,"path":"2018/04/26/AbstractQueuedSynchronizer源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/04/26/AbstractQueuedSynchronizer源码解析/","excerpt":"","text":"1. 简介AbstractQueuedSynchronizer（抽象队列同步器）简称AQS，是一个用来构建同步组件的基础框架，JDK中java.util.concurrent这个包的许多同步组件都是基于AQS来构建的，如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock等。AQS运用了模板方法的设计模式，使我们只需重写AQS的tryAcquire、tryRelease等方法来快速构造一个同步组件，上面提到的同步组件都是用这种方式创建出来的。比如独占锁这种工具我们只需重写以下3个方法： tryAcquire：尝试获取同步状态 tryRelease：尝试释放同步状态 isHeldExclusively：是否为独占状态 2. 实现类继承关系AbstractOwnableSynchronizer这个类提供了设置和获取独占同步状态的线程的方法 123public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123;&#125; 1234567891011121314151617public abstract class AbstractOwnableSynchronizer implements java.io.Serializable &#123; /** Use serial ID even though all fields transient. */ private static final long serialVersionUID = 3737899427754241961L; protected AbstractOwnableSynchronizer() &#123; &#125; private transient Thread exclusiveOwnerThread; protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread; &#125; protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread; &#125;&#125; 等待队列队列同步器的原理是维持一个同步状态和一个FIFO等待队列，获取到同步状态的线程会存在于队列头结点，而获取同步状态失败的线程会插入到队列尾部并且不断自旋检查是否可以获取同步状态，尝试获取失败后会判断是否需要阻塞，阻塞直到释放同步状态的线程按顺序唤醒阻塞线程直到获取到同步状态退出。 AQS等待队列 结点类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static final class Node &#123; // 结点位于共享模式 static final Node SHARED = new Node(); // 结点位于独占模式 static final Node EXCLUSIVE = null; // 以下4个状态是同步队列中结点线程的等待状态 // 取消状态，表示线程取消获取同步状态，可能是因为中断或超时取消 static final int CANCELLED = 1; // 需要唤醒等待状态为SIGNAL的后继结点 static final int SIGNAL = -1; // 等待某个条件 static final int CONDITION = -2; static final int PROPAGATE = -3; // 等待状态，值为0或以上4个状态 volatile int waitStatus; // 当前结点的前驱结点 volatile Node prev; // 当前结点的后驱结点 volatile Node next; // 被结点包装的线程 volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; // 获取前驱结点 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 12345678910111213141516171819// 等待队列头结点private transient volatile Node head;// 等待队列尾结点private transient volatile Node tail;// 同步状态private volatile int state;// 获取同步状态protected final int getState() &#123; return state;&#125;// 设置同步状态protected final void setState(int newState) &#123; state = newState;&#125;// 以CAS的方式设置同步状态protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; acquire方法阻塞获取独占式同步状态。源码中的tryAcquire方法需要在子类中根据需求重写。 acquire过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public final void acquire(int arg) &#123; // 调用tryAcquire方法尝试获取同步状态，获取成功直接返回，获取失败调用addWaiter方法将当前线程封装为独占模式的等待结点加入等待队列，接着调用acquireQueued方法自旋获取同步状态。 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;private Node addWaiter(Node mode) &#123; // 创建一个指定模式的包含当前线程的等待结点 Node node = new Node(Thread.currentThread(), mode); // 当尾结点不为空，即队列不为空，使用CAS方法将新建结点添加到队尾 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 队列为空或在刚才入队时出现CAS冲突执行enq方法 enq(node); // 返回插入的新结点 return node;&#125;// 该方法使用循环重试保证node一定会入队成功private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; // 队列为空，先新建一个空结点作为头结点，使用CAS方式插入 if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 否则队列不为空使用CAS方法添加结点node到队尾，失败则重试 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125;final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取当前结点的前驱结点 final Node p = node.predecessor(); // 如果前驱结点为头结点表示当前结点为等待队列中的第一个有资格获取同步状态的结点 // 接着尝试获取同步状态 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 设置头结点为当前结点 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; // 获取同步状态失败调用shouldParkAfterFailedAcquire方法判断是否需要阻塞， // 如果需要则调用parkAndCheckInterrupt方法阻塞线程 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 获取前驱结点等待状态 int ws = pred.waitStatus; // 如果前驱结点等待状态为SIGNAL则表示当前线程需要阻塞，直接返回true if (ws == Node.SIGNAL) return true; // 如果前驱结点等待状态为CANCELLED，说明前驱结点取消获取锁，向前遍历链表，跳过等待状态为CANCELLED的结点直到找到一个等待状态不为CANCELLED的结点 if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 否则将前驱结点的等待状态使用CAS方式设置为SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;private final boolean parkAndCheckInterrupt() &#123; // 调用LockSupport.park方法阻塞当前线程，当释放同步状态的线程执行LockSupport.unpark方法唤醒当前线程或其他线程执行中断方法中断当前线程则会从LockSupport.park中返回 LockSupport.park(this); // 返回中断状态并清除 return Thread.interrupted();&#125; release方法释放独占式同步状态。源码中的tryRelease方法需要在子类中根据需求重写。 123456789101112131415161718192021222324252627282930313233public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; // 如果头结点不为空，并且等待状态不为初始状态0则唤醒后继结点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;// 唤醒后继结点private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; // 如果当前结点状态小于0则使用CAS方式将其修改为0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 获取后继结点 Node s = node.next; // 如果后继结点为空或者取消获取同步状态则后续第一个等待状态不为CANCELLED的结点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从尾结点开始向前遍历到node结点，遍历过程中记录最新的等待状态小于等于0的结点，该最新结点里的线程为需要唤醒的线程 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) // 唤醒线程 LockSupport.unpark(s.thread);&#125; acquireInterruptibly方法上面讲到的acquire方法是阻塞式获取同步状态，不支持获取过程中响应中断抛出中断异常，如果需要支持阻塞获取同步状态过程中可以响应中断抛出中断异常可以使用acquireInterruptibly方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public final void acquireInterruptibly(int arg) throws InterruptedException &#123; // 判断是否中断，是则抛出中断异常 if (Thread.interrupted()) throw new InterruptedException(); // 尝试获取同步状态，成功则返回，失败调用doAcquireInterruptibly方法 if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125;// 这个方法跟上面的acquireQueued方法基本一样，就是在被唤醒后检测到中断状态后会抛出中断异常private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 检测到中断，抛出中断异常 throw new InterruptedException(); &#125; &#125; finally &#123; // 当failed为true时，表示检查到中断抛出异常，需要执行cancelAcquire方法取消获取同步状态 if (failed) cancelAcquire(node); &#125;&#125;private void cancelAcquire(Node node) &#123; // Ignore if node doesn't exist if (node == null) return; node.thread = null; // 向前遍历，跳过等待状态为CANCELLED的结点，直到找到一个等待状态不为CANCELLED的结点 Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; Node predNext = pred.next; //设置当前结点等待状态为CANCELLED node.waitStatus = Node.CANCELLED; // 如果node为尾结点则移除尾结点 if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; int ws; // 否则如果node前驱结点不为head结点 if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; 、、 if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123;// 如果node前驱结点为head unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125; tryAcquireNanos方法该方法通过设置超时时间nanosTimeout，当在指定超时时间内未获取到同步状态将返回false，在获取过程中支持响应中断并抛出异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; // 判断是否中断，是则抛出中断异常 if (Thread.interrupted()) throw new InterruptedException(); // 尝试获取同步状态，失败则调用doAcquireNanos方法超时获取 return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125;private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; // 计算截止时间deadline final long deadline = System.nanoTime() + nanosTimeout; // 创建独占模式下的结点并入队 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); // 当前驱结点为head则尝试获取同步状态 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; // 计算还有多长时间到达截止时间 nanosTimeout = deadline - System.nanoTime(); // 如果超时时间小于0则已到达截止时间，返回false if (nanosTimeout &lt;= 0L) return false; // 判断是否要阻塞，并且超时时间大于自旋超时时间的阈值则阻塞，因为小于spinForTimeoutThreshold没必要阻塞，因为唤醒的时间可能超过该阈值 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); // 检查到中断则抛出中断异常 if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"ConcurrentHashMap源码解析","slug":"ConcurrentHashMap源码解析","date":"2018-04-25T07:09:59.000Z","updated":"2018-04-25T07:09:59.000Z","comments":true,"path":"2018/04/25/ConcurrentHashMap源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/04/25/ConcurrentHashMap源码解析/","excerpt":"","text":"1. 简介在之前写了HashMap源码解析介绍了HashMap这个数据结构，可惜它并不是线程安全的，在多线程情况下最好还是使用ConCurrentHashMap。在JDK8中它使用了CAS+synchronized实现来保证线程安全，而在JDK7中它使用了分段锁的实现方式来保证线程安全。下面我来剖析下它源码： 2. 实现类继承结构12public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;&#125; 属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Node数组最大大小private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// Node数组最大大小private static final int DEFAULT_CAPACITY = 16;// 最大数组大小，只在toArray方法中使用static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;// 默认并发级别private static final int DEFAULT_CONCURRENCY_LEVEL = 16;// 负载因子private static final float LOAD_FACTOR = 0.75f;// 链表转换为红黑树链表长度的阈值static final int TREEIFY_THRESHOLD = 8;// 红黑树转换为链表的阈值static final int UNTREEIFY_THRESHOLD = 6;// 链表转换为红黑树数组大小的阈值static final int MIN_TREEIFY_CAPACITY = 64;private static final int MIN_TRANSFER_STRIDE = 16;private static int RESIZE_STAMP_BITS = 16;// 帮助扩容的最大线程数private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;static final int MOVED = -1; // forwarding结点的Hash值static final int TREEBIN = -2; // 树根结点的Hash值static final int RESERVED = -3; // hash for transient reservationsstatic final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash// 获取可用处理器数量static final int NCPU = Runtime.getRuntime().availableProcessors();// Node结点的数组transient volatile Node&lt;K,V&gt;[] table;// private transient volatile Node&lt;K,V&gt;[] nextTable;private transient volatile long baseCount;// &lt; -1表示有-(sizeCtl + 1)个线程在扩容// == -1表示数组在初始化// 大于0表示并且数组为初始化表示要初始化数组的大小，否则表示扩容的阈值private transient volatile int sizeCtl;private transient volatile int transferIndex;private transient volatile int cellsBusy;private transient volatile CounterCell[] counterCells;private transient KeySetView&lt;K,V&gt; keySet;private transient ValuesView&lt;K,V&gt; values;private transient EntrySetView&lt;K,V&gt; entrySet; 结点类型链表结点类型123456789101112131415161718192021222324252627282930313233343536373839404142434445static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; // 使用volatile修饰来保证变量在多线程下的可见性 volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return val; &#125; public final int hashCode() &#123; return key.hashCode() ^ val.hashCode(); &#125; public final String toString()&#123; return key + \"=\" + val; &#125; public final V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; public final boolean equals(Object o) &#123; Object k, v, u; Map.Entry&lt;?,?&gt; e; return ((o instanceof Map.Entry) &amp;&amp; (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != null &amp;&amp; (v = e.getValue()) != null &amp;&amp; (k == key || k.equals(key)) &amp;&amp; (v == (u = val) || v.equals(u))); &#125; // 在以当前结点开始的链表中寻找含有k这个键的结点 Node&lt;K,V&gt; find(int h, Object k) &#123; Node&lt;K,V&gt; e = this; if (k != null) &#123; do &#123; K ek; if (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek)))) return e; &#125; while ((e = e.next) != null); &#125; return null; &#125;&#125; 红黑树结点类型1234567891011121314151617181920212223242526static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next, TreeNode&lt;K,V&gt; parent) &#123; super(hash, key, val, next); this.parent = parent; &#125; // 找出键为k的结点 Node&lt;K,V&gt; find(int h, Object k) &#123; return findTreeNode(h, k, null); &#125; /** * Returns the TreeNode (or null if not found) for the given key * starting at given root. */ final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) &#123; // 省略代码 &#125;&#125; 12345678910111213141516171819202122// 用于存放红黑树的结构static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; root; volatile TreeNode&lt;K,V&gt; first; // TreeNode根结点 volatile Thread waiter; // 等待线程 volatile int lockState; // 锁状态 // values for lockState static final int WRITER = 1; // set while holding write lock static final int WAITER = 2; // set when waiting for write lock static final int READER = 4; // increment value for setting read lock static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; //省略后面大部分代码 构造函数在构造函数中并不会创建Node数组，而是延迟到第一次put方法时才创建Node数组 123456789101112131415161718192021222324252627282930313233343536373839404142public ConcurrentHashMap() &#123;&#125;public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap;&#125;public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123; this(initialCapacity, loadFactor, 1);&#125;public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads // 键值对数量 / 数组大小 &lt;= 加载因子，根据initialCapacity与加载因子求出数组大小 long size = (long)(1.0 + (long)initialCapacity / loadFactor); // 如果数组大小最大等于数组大小则设置数组初始大小为MAXIMUM_CAPACITY， // 否则调用tableSizeFor函数求出一个不小于size的第一个2的n次幂的正整数 int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); // 设置要初始化的数组大小 this.sizeCtl = cap;&#125;// 求出一个不小于c的第一个2的n次幂的正整数private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 散列函数通过高16位与低16位的异或运算得出新的散列值以减少碰撞几率 123static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; put方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//插入键值对，如果键已存在，默认更改其值public V put(K key, V value) &#123; return putVal(key, value, false);&#125;/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; // 键与值不得为空 if (key == null || value == null) throw new NullPointerException(); // 计算出键的散列值 int hash = spread(key.hashCode()); // 指定数组位置上结点的个数 int binCount = 0; // 通过使用循环直到添加成功退出循环 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; // 如果数组未初始化，则调用initTable方法初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); // 否则计算出键所在的桶，如果桶为空则调用casTabAt方法尝试在该位置添加结点 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 添加结点成功退出循环，否则表示有其他线程也尝试在此位置插入结点，出现冲突 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125;// 如果该位置不为空，并且该结点Hash值为MOVED表示当前正在扩容，调用helpTransfer方法帮助扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; // 使用synchronized关键字对该头结点进行加锁，只有获取头结点的锁的线程才有资格对该桶的链表或数组添加结点 synchronized (f) &#123; // 再一次判断加锁的结点是否为头结点 if (tabAt(tab, i) == f) &#123; // 如果头结点Hash值大于等于0则表示该桶存放的是链表，遍历链表添加结点 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; // 找到该结点 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; // 判断是否替换旧值 if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; // 否则判断头结点是否为为TreeBin的实例，如果是则该桶存放的是一棵红黑树 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; // 调用putTreeVal方法添加结点 if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; // 判断是否替换旧值 if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // 如果binCount不等于0则表示添加结点或替换新值成功 if (binCount != 0) &#123; // 如果结点数量大于等于8，将链表树形化 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); // 如果值不为空直接返回旧值 if (oldVal != null) return oldVal; break; &#125; &#125; &#125; // 添加新结点成功，调用addCount方法判断是否需要扩容 addCount(1L, binCount); return null;&#125; initTable方法这个方法是在调用put方法时数组未初始化时调用的，用于创建初始数组 12345678910111213141516171819202122232425262728293031private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; // 使用循环来保证初始化成功 while ((tab = table) == null || tab.length == 0) &#123; // 如果sizeCtl小于0表示数组在初始化或者扩容 if ((sc = sizeCtl) &lt; 0) // 调用Thread.yield方法尝试让出CPU给其他相同优先级的线程 Thread.yield(); // lost initialization race; just spin // 否则使用CAS更新SIZECTL为-1，表示要初始化数组 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; // 再一次判断数组是否未初始化 if ((tab = table) == null || tab.length == 0) &#123; // 若在构造对象时未给出初始化大小则使用默认大小16 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") // 创建新数组 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; // 设置下次扩容阈值为当前数组大小的0.75倍 sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; // 无论是否初始化成功，更新sizeCtl的值 sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125; helpTransfer方法当发现数组正在扩容时调用helpTransfer方法帮助数组转移结点到新数组 12345678910111213141516171819final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table;&#125;","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"LinkedHashMap源码解析","slug":"LinkedHashMap源码解析","date":"2018-04-17T04:55:53.000Z","updated":"2018-04-17T04:55:53.000Z","comments":true,"path":"2018/04/17/LinkedHashMap源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/04/17/LinkedHashMap源码解析/","excerpt":"","text":"1. 简介Map是一种关联容器，其中键是唯一的，每个键都有与之对应的值，我们可以通过键获取到唯一的值。JDK中，HashMap是其中的一种实现，只不过HashMap是无序的，不能记录插入顺序与访问顺序，而LinkedHashMap恰好能记录插入顺序或访问顺序，至于为什么能够实现，是因为它在内部维护了一个链表专门来记录插入顺序或访问顺序，接着我们来剖析其内部实现。 2. 实现类继承关系从下面的类继承关系可以看出LinkedHashMap是继承了HashMap的，内部复用了HashMap的代码。 123public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;&#125; 结点结构这里的Entry类继承了HashMap.Node类，并增加了两个引用字段before, after，可以看出该链表是一个双向链表,这个类其实是为链表准备的，两个引用分别指向当前链表结点前后结点。 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 因为从JDK8开始，HashMap开始采用红黑树，当每个桶中的链表长度大于8时会转为红黑树存储。所以为了保证TreeNode能够插入到LinkedHashMap维护的链表，TreeNode需要继承LinkedHashMap.Entry。 12345678910static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125;&#125; 属性123456// 链表的头结点transient LinkedHashMap.Entry&lt;K,V&gt; head;// 链表的尾结点transient LinkedHashMap.Entry&lt;K,V&gt; tail;// 为false表示链表中结点按照键值对的插入顺序排序，为true表示按照访问顺序，即最近插入与访问的结点都在链表尾部final boolean accessOrder; 构造函数以下构造函数都是先调用父类的构造函数创建一个HashMap，接着将accessOrder设置为false表示按照链表按照键值对插入顺序排序 12345678910111213141516171819202122232425262728public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125;// 这里讲accessOrder设置为给定值public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 创建结点每次我们创建HashMap使用的结点都使用以下两个方法创建，内部实现会维护双向链表 1234567891011121314151617181920212223242526272829303132Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; // 创建一个链表结点 LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); // 将该结点添加到双向链表尾部 linkNodeLast(p); return p;&#125;TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; // 创建一个红黑树结点 TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(hash, key, value, next); // 将该结点添加到双向链表尾部 linkNodeLast(p); return p;&#125;// 将该结点添加到双向链表尾部private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; // 设置上一个结点为当前尾结点 LinkedHashMap.Entry&lt;K,V&gt; last = tail; // 将新结点设置为尾结点 tail = p; // 如果上一个结点为空，则当前头结点应该为新结点 if (last == null) head = p; else &#123; // 否则新结点的上一个结点 p.before = last; last.after = p; &#125;&#125; get方法1234567891011121314151617181920212223242526272829303132333435363738public V get(Object key) &#123; Node&lt;K,V&gt; e; // 找到key对应的Node结点，为null则不存在，返回null if ((e = getNode(hash(key), key)) == null) return null; // 如果accessOrder为true则调用afterNodeAccess方法将最近访问的结点从链表中移动到链表尾部 if (accessOrder) afterNodeAccess(e); //返回找到的值 return e.value;&#125;// 将结点e移动到链表尾部void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; // 当按accessOrder为true按访问次序排序并且尾结点不是当前需要移动的结点才需要移动 if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 其他方法1234567891011121314151617181920212223// 执行remove方法从哈希表中删除键值对后调用，将该结点从链表中移除void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125;// 执行put方法成功插入后调用，目的是移除最旧的结点，即头结点void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"Vector源码解析","slug":"Vector源码解析","date":"2018-04-15T04:19:23.000Z","updated":"2018-04-15T04:19:23.000Z","comments":true,"path":"2018/04/15/Vector源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/04/15/Vector源码解析/","excerpt":"","text":"1. 简介Vector跟ArrayList一样是一个基于数组实现的List，只不过Vector是线程安全的，在可能出现线程安全性问题的方法，Vector都加上了关键字synchronized。与ArrayList一样，Vector查找元素的时间复杂度是O(1)，插入删除时间复杂度为O(n)。 2. 实现属性12345678// 数组最大大小private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;// 存储元素的数组protected Object[] elementData;// 元素数量protected int elementCount;// 扩容增量protected int capacityIncrement; 构造函数1234567891011121314151617181920// 自定义初始容量与扩容增量public Vector(int initialCapacity, int capacityIncrement) &#123; super(); // 初始容量小于0抛出非法参数异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125;// 未给出扩容增量默认为0，以后每次扩容后大小都为原来大小的2倍public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;// 默认初始容量为10public Vector() &#123; this(10);&#125; 扩容函数12345678910111213141516171819202122// 确保最小容量为minCapacityprivate void ensureCapacityHelper(int minCapacity) &#123; // 判断是否需要扩容，需要则扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;// 扩容函数private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 如果扩容增量大于0则扩大capacityIncrement，否则扩容为原来的2倍大小 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); // 确保新容量不小于最小容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 创建新数组并转移旧数组中的所有元素到新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 增删改查方法Vector在这些方法的实现上与ArrayList基本一致，但为保证线程安全所以在所有可能出现线程安全问题的方法一律加上synchronized关键字，这在非多线程下使用效率不及ArrayList高，而要想要高效的使用线程安全的List，CopyOnWriteArrayList是一个更好的选择。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 获取数组指定索引上的元素E elementData(int index) &#123; return (E) elementData[index];&#125;// 获取指定索引上的值，增加了index的有效范围判断public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125;// 更改指定索引上元素的值并返回旧值public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;// 添加元素e到List后面public synchronized boolean add(E e) &#123; modCount++; // 确保最小容量 ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;// 移除指定索引上的元素public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue;&#125;","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"ArrayList源码解析","slug":"ArrayList源码解析","date":"2018-04-15T04:19:18.000Z","updated":"2018-04-15T04:19:18.000Z","comments":true,"path":"2018/04/15/ArrayList源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/04/15/ArrayList源码解析/","excerpt":"","text":"1. 简介List是一种支持插入、删除、查找，元素可重复，可为null的数据结构，在JDK中有不同的实现类，其中ArrayList基于数组实现，支持随机访问，非线程安全，插入与删除时间复杂度为O(n)。 2. 实现ArrayList内部是使用数组来实现的，所以可以做到随机访问时间为O(1)，如果不一开始设置好最终的大小，可能在不断添加元素的过程中多次扩容而导致效率问题。 属性12345678910111213//默认容量private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//数组最大大小private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//元素存放的数组，设置为transient的目的是序列化对象时忽略该数组，因为数组可能不是存满的，我们只序列化必要的对象以节省空间时间。transient Object[] elementData; // non-private to simplify nested class access//已经添加的元素数量private int size; 构造函数12345678910111213141516public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;// 如果未给出大小，默认大小是数组大小10，只不过这个大小为10的数组是延迟到添加元素创建的，所以这里// 一开始数组大小是0。public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 扩容函数123456789101112131415161718192021222324252627282930private void ensureCapacityInternal(int minCapacity) &#123; // 这里就是默认大小数组延迟创建的开始部分了 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 判断是否需要扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新数组的大小为旧数组的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 增删改查方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 获取指定位置上的元素public E get(int index) &#123; //范围检查，index超出范围抛出异常 rangeCheck(index); return elementData(index);&#125;// 修改指定位置上的元素并返回旧元素public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;// 添加元素到列表尾部public boolean add(E e) &#123; // 判断是否需要扩容，如需要则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;// 添加元素到指定索引位置public void add(int index, E element) &#123; // 范围检查 rangeCheckForAdd(index); // 判断是否需要扩容，如需要则扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 移动元素 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;// 移除指定位置上的元素并返回其值public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;// 若存在对象o则移除public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;// 清空所有对象public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; toArray方法1234// 复制出一个具有原数组所有元素的新数组public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125; subList方法创建出一个子List，对该List的操作将作用于到原List上 12345public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; // 检查索引范围是否合法 subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);&#125; sort方法List接口中存在默认的sort方法，只不过该方法是为LinkedList非基于数组实现的List准备的，所以ArrayList重写了sort方法，通过调用Arrays.sort()方法直接对数组进行排序效率比默认的高。 12345678public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125; 3. 适用场景 ArrayList内部基于数组实现，查找效率非常高，但是当出现大量的插入或删除操作，每次都要移动大量元素，明显效率很低。所以ArrayList应该适合于那种查找操作多于插入删除操作的场景。 ArrayList比LinkedList节省空间，因为ArrayList核心就是一个存储该类元素的数组。在64位虚拟机下，不开启指针压缩情况下： ArrayList存储元素消耗的空间为 24字节（数组对象头）+ 数组长度 * 8字节 LinkedList存储元素消耗的空间为 元素数量 * 40字节（结点对象头 + 前后结点指针 + 元素指针） 总的来说，每存储一个元素，ArrayList平均消耗8个字节的引用空间，而LinkedList除了消耗8个字节的引用空间还要32字节的空间（结点对象头 + 前后结点指针）","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"LinkedList源码解析","slug":"LinkedList源码解析","date":"2018-04-15T04:17:53.000Z","updated":"2018-04-15T04:17:53.000Z","comments":true,"path":"2018/04/15/LinkedList源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/04/15/LinkedList源码解析/","excerpt":"","text":"1. 简介LinkedList基于链表实现，非线程安全，其既实现了List接口又实现了Deque接口，所以既可以做为列表使用又可以做双端队列使用，队头队尾插入删除时间复杂度都为O(1)，查找效率为O(n)。 2. 实现结点类型12345678910111213private static class Node&lt;E&gt; &#123; E item; // 下一个结点 Node&lt;E&gt; next; // 上一个结点 Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 属性12345678// 结点数量transient int size = 0;// 指向链表头结点transient Node&lt;E&gt; first;// 指向链表尾结点transient Node&lt;E&gt; last; 构造函数123// 构造函数为空public LinkedList() &#123;&#125; 获取索引对应的结点用链表实现的List不同于数组，查找对应索引的结点不支持随机访问，只能遍历链表找到对应位置的结点。因为持有头尾结点的引用所以可以根据索引位于List中的位置而搜索对应的部分进一步提高搜索效率。 123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 如果索引位于List的前半部分则从头结点开始搜索 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 否则从尾结点开始搜索 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 增删改查方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 将新结点插入到List后面void linkLast(E e) &#123; final Node&lt;E&gt; l = last; // 创建新结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 尾指针指向新结点 last = newNode; // 如果之前不存在尾结点则设置头指针为新结点 if (l == null) first = newNode; else // 否则将原来的尾结点指向新结点 l.next = newNode; size++; modCount++;&#125;// 调用linkLast方法将元素e作为新结点插入List后面public boolean add(E e) &#123; linkLast(e); return true;&#125;public boolean remove(Object o) &#123; // 如果要移除的结点为空则从头结点开始遍历直到找到值为空的结点将其链接释放 if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; //否则找到一个值相等的结点 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;// 遍历链表把每一个结点的属性都设置为nullpublic void clear() &#123; for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125;// 获取指定位置上的值public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;// 找到其对应结点修改其值并返回旧值public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;// 将元素作为新结点插入到指定位置public void add(int index, E element) &#123; // 判断插入位置是否在有效范围 checkPositionIndex(index); // 如果插入位置在尾部则调用linkLast方法插入 if (index == size) linkLast(element); else // 找到对应位置上的结点插入其前面 linkBefore(element, node(index));&#125;public E remove(int index) &#123; // 判断索引位置是否合法 checkElementIndex(index); // 找到指定位置对应的结点将其释放其链接 return unlink(node(index));&#125; toArray方法创建一个数组，将链表所有结点的值都一一赋值到该数组上 1234567public Object[] toArray() &#123; Object[] result = new Object[size]; int i = 0; for (Node&lt;E&gt; x = first; x != null; x = x.next) result[i++] = x.item; return result;&#125;","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"JVM参数","slug":"JVM参数","date":"2018-02-20T14:19:19.000Z","updated":"2018-02-20T14:19:19.000Z","comments":true,"path":"2018/02/20/JVM参数/","link":"","permalink":"https://xiepuhuan.github.io/2018/02/20/JVM参数/","excerpt":"","text":"1. 使用方式使用 -XX:+PrintFlagsFinal参数输出所有参数的名称和默认值，参数的使用方式如下： -XX:+&lt;option&gt;开启option参数 -XX:-&lt;option&gt;开启option参数 -XX:&lt;option&gt;=&lt;value&gt;开启option参数的值设置为value 2. 内存管理 参数名称 描述 -Xms 初始堆大小 -Xmx 最大堆大小 -Xmn 新生代大小 -SurvivorRatio 新生代中Eden区与Survivor区的比值，默认为8 -Xss 栈大小 -XX:PermSize 初始方法区大小 -XX:MaxPermSize 最大方法区大小","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://xiepuhuan.github.io/categories/Java虚拟机/"}],"tags":[]},{"title":"超文本传输协议(HTTP)","slug":"超文本传输协议(HTTP)","date":"2018-02-10T18:03:21.000Z","updated":"2018-02-10T18:03:21.000Z","comments":true,"path":"2018/02/11/超文本传输协议(HTTP)/","link":"","permalink":"https://xiepuhuan.github.io/2018/02/11/超文本传输协议(HTTP)/","excerpt":"","text":"1. 简介HTTP是位于应用层的一个无状态的协议，默认HTTP的端口号为80，HTTPS的端口号为443。HTTP协议本身是不可靠的实现，要实现可靠地数据传输需要依靠底层的TCP协议。 2. 实现HTTP的报文包括请求报文和响应报文两种 请求报文请求报文是浏览器向服务器发出请求的报文，由第一行的请求行和后面的首部行组成，每一行都由回车换行(\\r\\n)结尾，当请求的方法是POST的时候，会在首部行结尾再回车换行加上POST携带的实体数据。 请求行 \\r\\n首部行 \\r\\n\\r\\n实体行 请求行 方法字段： GET（主要方法） POST HEAD PUT DELETE URI字段：请求对象的标识 HTTP版本字段：有HTTP/1.0和HTTP/1.1两种 首部行 Host：要访问的主机名 Connection：值为keep-alive表示该连接为持续连接，为close表示非持续连接。 Accept： 可接受的MIME类型，即报文类型。 User-Agent: 用户代理， 表示请求的浏览器的类型。 Referer: 表示发出请求时处于哪个页面，可用做反盗链。 Accept-Encoding: 告诉服务器自己接受的页面编码。 Accept-Language: 告诉服务器自己接受的网页语言。 Cookie: 将服务器存储在浏览器本地的Cookie值发送给服务器，实现无状态的。HTTP协议的会话跟踪。 响应报文请求报文是服务器向浏览器发出响应报文，由第一行的状态行、接着首部行、最后的实体行组成，每一行都由回车换行(\\r\\n)结尾，其中实体行就是请求的数据。 状态行 \\r\\n首部行 \\r\\n\\r\\n实体行 状态行 协议版本：有HTTP/1.0和HTTP/1.1两种 状态码： 200：成功。 301：内容已经永久移动，浏览器会重定向到响应指定的新URI。 302：内容临时移动 304：内容未被修改，响应不包含内容 400：请求不能被服务器理解。 403：无权访问该文件。 404：不能找到请求文件。 500：服务器内部错误。 501：服务器不支持请求的方法。 505：服务器不支持请求的版本。 状态信息：状态码的含义 首部行 Connection：值为keep-alive表示该连接为持续连接，为close表示非持续连接。 Date：表示报文发送的时间。 Server：Web服务器用来处理请求的软件信息。 Cache-control：缓存控制 ETag：响应对象的标识符 Last-Modfied：对象创建或者最后修改的时间。 Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。 Content-Length：被发送的对象的字节数。 Content-Type：表示响应的实体行的对象类型。 缓存机制HTTP的缓存机制是通过Cache-control字段来控制，Cache-control是一个通用首部，请求和响应的首部都可以使用，有几个常见的值： private： 只允许发出请求的客户端缓存 public： 允许客户端和代理服务器缓存 max-age=x： 缓存的有效期为x秒 no-cache： 不直接使用缓存，使用前得向服务器发出请求验证缓存有效性 If-None-Match/Etag：当缓存的内容具有Etag标识，就向服务器发送含有If-None-Match字段的请求报文以判断缓存的内存是否与服务器上的内容一致，如果一致，服务器就会返回304状态的响应报文表示可以直接使用缓存，否则返回200状态含有新资源实体的响应报文。 If-Modified-Since/Last-Modified：当缓存的内容具有Last-Modified（最后修改时间），就向服务器发送含有If-Modified-Since字段的请求报文以判断缓存的内存在服务器上的是否改变，如果时间一致，就会返回304状态的响应表示可以直接使用缓存，否则返回200状态含有新资源实体的响应报文。 no-store： 所有内容都不会缓存 HTTP缓存的使用 HTTPSHTTPS中的S指的是SSL（安全套接字层）或TLS（传输层安全），TLS是基于SSL开发的。 HTTP的缺点HTTP属于不安全的通信协议： 使用明文不加密，内容容易被窃读 不能验证对方身份，对方可能是一个伪装的通讯方 无法验证报文的完整性，报文可能被篡改 加密算法要解决第一个问题必须采用加密算法对报文进行加密，常见的加密算法有对称加密(AES算法，加密解密使用同一把秘钥)、非对称加密(RSA算法，加密和解密采用不同秘钥)，HTTPS采用混合加密算法集合和两者的优点。由于非对称加密开销比对称加密大，所以通信过程中报文的加密采用对称加密，而非对称加密用于一开始共享秘钥的传输。 通信过程 客户端发出请求报文，报文包含客户端支持的SSL协议版本、加密算法。 服务器发送数字证书，数字证书可以向数字证书认证机构申请，证书包含以下内容： 证书的发布机构CA 证书的有效期 证书所有人的名称 公开秘钥 签名算法 数字签名（证书内容摘要值的加密结果） 客户端收到证书后验证证书的合法性。数字签名是数字证书机构使用私钥进行加密的结果，得在浏览器本地可以找到对应的公钥进行解密，为了保证证书没有被篡改，客户端会根据签名算法计算出证书内容的摘要值（哈希算法），如与解密后的数字签名一致的话就证明内容没有被篡改并且对方是一个合法通信方。 随后客户端产生一个pre-master secret的随机数用于对称加密，使用数字证书里的公开秘钥对随机数加密并发送给服务器。 服务器收到包含共享秘钥的报文后用自己的私钥解密得到共享秘钥。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xiepuhuan.github.io/categories/计算机网络/"}],"tags":[]},{"title":"传输控制协议(TCP)","slug":"传输控制协议(TCP)","date":"2018-02-10T10:14:07.000Z","updated":"2018-02-10T10:14:07.000Z","comments":true,"path":"2018/02/10/传输控制协议(TCP)/","link":"","permalink":"https://xiepuhuan.github.io/2018/02/10/传输控制协议(TCP)/","excerpt":"","text":"1. 简介TCP提供一种可靠的面向连接的全双工服务，位于传输层。 2. TCP报文段结构TCP报文段包括首部字段和数据字段，其中数据字段来自于应用层的数据，最大长度为MSS。 首部字段 源端口号(16 bit)：发送进程所占用的端口号 目的端口号(16 bit)：接收进程所占用的端口号 序号(32 bit)：传输方向上对数据字节流中的每一个字节编号，这个序号就是发送方要传输的报文段中数据流的第一个字节的序号。 确认号(32 bit)：接受方对接受到的报文段作出确认，确认号即是希望接受的下一个报文段数据字段中的第一个字节的编号。 首部长(4 bit)：标识首部的大小以多少个4字节为单位，最大为15，即60字节。 标志位(6 bit)： URG：表示紧急指针是否有效。 ACK：表示确认号是否有效。 PSH：表示接收方应立即从缓冲读走数据，将数据传给上层。 RST：表示要求对方重新建立连接。 SYN：表示请求建立一个连接。 FIN：表示关闭连接。 接受窗口(16 bit)：用于告知接收方自己还有多少缓存空间可用，因为TCP是全双工通信，双方都维持一个接受窗口。 检验和(16 bit)：接收端用检验和检验报文段有无损坏。 紧急数据指针(16 bit)：当URG位为1时，此紧急数据指针指向紧急数据的最后一个字节。 选项字段：该字段是可选和变长的字段，可用于发送方与接收方协商最大报文段长度(MSS)。 3. 可靠性实现连接建立（三次握手） 第一次：客户端发送SYN报文请求建立连接，然后进入SYN_SEND状态。 第二次：服务器收到SYN报文，确定建立连接并发送SYN + ACK报文，然后进入SYN_RECV状态。 第三次：客户端收到SYN + ACK报文，并对服务器的请求进行确认，发送ACK报文，然后进入ESTABLISH状态。 为什么要三次握手？ 现在考虑两次握手的情况：&lt;&lt;计算机网络&gt;&gt;谢仁希版里面说防止已失效的连接请求报文段，意思是TCP第一次握手客户端发给服务器的SYN报文段出现延迟，然后客户端发现超时重传SYN报文段，这一次服务器收到并回应一个ACK报文，服务器端的连接建立，收到ACK报文的客户端也成功建立了连接。然而此时第一次发出的已失效的SYN报文此时到达了服务器，服务器以为发现是客户端的连接建立请求，同一建立起连接，然后发回一个ACK报文，客户端收到后不理睬，那服务器白白浪费TCP通信资源。但采用三次握手可以解决这个问题。 连接拆除（四次挥手） 第一次：客户端发送FIN+ACK报文，进入FIN_WAIT_1状态，表示没有数据要发送了。 第二次： 服务器收到了FIN+ACK报文，知道了断开请求，发送一个ACK报文，然后服务器进入CLOSE_WAIT状态，表示可能还有数据要发送。 客户端收到了服务器的ACK报文进入了FIN_WAIT_2状态。 第三次：服务器向客户端发送FIN+ACK报文，然后进入LAST_ACK状态等待客户端的回应。 第四次：客户端收到FIN+ACK报文，知道了断开连接的请求，接着客户端发送ACK报文然后进入TIME_WAIT状态，等待2MSL时间服务器没有在响应就最终进入CLOSE状态。 为什么要等待2MSL时间？ MSL是一个IP数据报在网络中的最大生存时间，如果客户端不等待2MSL而是直接进入CLOSED状态，服务端可能没有接收到最后一次ACK包会在超时重传FIN包，此时因为客户端已经进入CLOSED状态，所以服务端就不会收到ACK报文而是收到RST报文。所以等待2MSL时间是防止最后一次握手ACK报文没有到达对方而触发重传FIN准备的。 让前一次使用这个端口的连接传输的数据到达接收方或消失，避免与新建立的连接数据混淆。 流量控制TCP是全双工的通信协议，在通信两端都维持有一个发送窗口和接受窗口，对于一个发送方和一个接收方来说，接收方的接收窗口大小受到接收缓存大小的限制，如果发送方发送窗口大小持续增大导致发送速率增加，而接受缓存过快填满而导致接收窗口大小减小，结果数据可能溢出。所以动态调整接收窗口就变得非常重要，可以通过TCP报文的窗口字段告知发送方本方还有多少缓存空间可用，这也就是流量控制。 拥塞控制拥塞控制是对于整体网络（包括路由器、交换机）出现拥塞的进行控制， 不同于流量控制的点对点控制，TCP的拥塞控制由4个核心算法组成。 慢启动(Slow Start) 在发送方维持一个额外的拥塞窗口变量cwnd(congestion window)，这个拥塞窗口的大小取决于网络的拥塞程度，而流量控制的窗口取决于接收方的接受缓存，最终发送方的发送窗口大小应该为两者中的最小值。 一开始，拥塞窗口的大小设置为一个MSS大小，即允许发送一个报文段 发送完窗口所允许发送的报文段后，接收到一个对该报文段ACK报文段后，cwnd翻倍（cwnd = cwnd * 2） 接着再发送完所有允许发送的2个报文段后，接收到两个ACK报文段后cwnd再次翻倍 直到网络出现拥塞 拥塞避免(Congestion Avoidance)上面说到慢启动的过程持续到网络出现拥塞，即出现超时还未收到ACK报文，此时就要进行拥塞避免： 将慢启动阈值ssthresh设置为当前拥塞窗口cwnd的一半 将cwnd的大小设置为1个MSS，重新执行慢启动算法 当cwnd的大小达到ssthresh后的增量变成1，即只增加1个MSS大小 快速重传(Fast Retransmit)快速重传的目的是想让发送方在超时之前快速重传丢失的报文段。当发送方连续收到3个冗余的ACK就会执行快速重传。 快速恢复(Fast Recovery)连续收到3个冗余的ACK其实也表示网络出现拥塞导致丢包，这时执行与拥塞避免的类似操作： 将慢启动阀值ssthresh设置为当前拥塞窗口cwnd的一半 将cwnd的大小也设置为当前拥塞窗口cwnd的一半，执行拥塞避免算法 第一步与拥塞避免的第一步相同，但cwnd不从1个MSS大小开始执行慢启动指数增长，而是减半执行拥塞避免线性增长，进行快速恢复。 4. 最后现在总结下TCP的可靠性具体表现在： 连接建立与拆除的可靠性实现 确认与重传机制 数据校验 流量控制 拥塞控制","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xiepuhuan.github.io/categories/计算机网络/"}],"tags":[]},{"title":"代理模式(Proxy-Pattern)","slug":"代理模式(Proxy-Pattern)","date":"2018-01-25T14:03:00.000Z","updated":"2018-01-25T14:03:00.000Z","comments":true,"path":"2018/01/25/代理模式(Proxy-Pattern)/","link":"","permalink":"https://xiepuhuan.github.io/2018/01/25/代理模式(Proxy-Pattern)/","excerpt":"","text":"1. 简介代理模式属于设计模式中的结构型模式，有静态代理和动态代理两种实现方式。代理模式使用代理类来控制访问委托类中方法或者增强委托类的功能。 2. 实现静态代理静态代理即是代理类在编译期间已知。 UML类图 UML类图 如上图所示： Subject接口定义了代理类Proxy和委托类RealSubject共同的方法request() RealSubject委托类，它是被代理和控制访问的对象 Proxy代理类引用了RealSubject的对象，实现了对它的访问控制 代码实现123456789101112131415161718192021222324252627282930interface Subject&#123; void request();&#125;class RealSubject implements Subject&#123; @Override public void request() &#123; System.out.println(\"request\"); &#125; public void run()&#123; System.out.println(\"run\"); &#125;&#125;class Proxy implements Subject&#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; @Override public void request() &#123; System.out.println(\"before\"); subject.request(); System.out.println(\"after\"); &#125;&#125; 动态代理动态代理即是代理类在运行期间产生，这个需要用到Java的反射机制，使用JDK的java.lang.reflect这个包中的一个接口和类： InvocationHandler接口是个调用处理器，通过重写invoke(Object proxy, Method method, Object[] args)方法来对委托类中的方法进行控制访问。 Proxy类提供几个静态方法： getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)方法通过传入类加载器和委托类实现的接口这些参数来生成一个代理类，生成的代理类继承了Proxy并且实现了所有委托类的接口 newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)方法创建一个代理类实例 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091interface Subject&#123; void request();&#125;/委托类class RealSubject implements Subject &#123; @Override public void request() &#123; System.out.println(\"request\"); &#125; public void run()&#123; System.out.println(\"run\"); &#125;&#125;/调用处理器class ProxyInvocationHandler implements InvocationHandler&#123; private Object realSubject; public ProxyInvocationHandler(Object realSubject)&#123; this.realSubject = realSubject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"before\"); Object returnObject = method.invoke(realSubject, args); System.out.println(\"after\"); return returnObject; &#125;&#125;class ProxyClass &#123; private Class&lt;?&gt; proxy; private ProxyInvocationHandler handler; private Object realSubject; public ProxyClass(ProxyInvocationHandler handler, Object realSubject) &#123; this.handler = handler; this.realSubject = realSubject; this.proxy = productProxyClass(); &#125; /产生代理类 private Class&lt;?&gt; productProxyClass() &#123; ClassLoader loader = ClassLoader.getSystemClassLoader(); Class&lt;?&gt;[] interfaces = realSubject.getClass().getInterfaces(); return Proxy.getProxyClass(loader, interfaces); &#125; public Class&lt;?&gt; getProxy() &#123; return proxy; &#125; /创建代理类对象 public Object newInstance() &#123; try &#123; Constructor constructor = proxy.getDeclaredConstructor(InvocationHandler.class); return constructor.newInstance(handler); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125;public class DynamicProxy&#123; public static void main(String[] args)&#123; /创建委托类对象 Subject realSubject = new RealSubject(); /创建代理类调用处理器 ProxyInvocationHandler handler = new ProxyInvocationHandler(realSubject); ProxyClass proxyClass = new ProxyClass(handler, realSubject); 生成代理类对象 Subject proxy = (Subject) proxyClass.newInstance(); proxy.request(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xiepuhuan.github.io/categories/设计模式/"}],"tags":[]},{"title":"JVM类加载机制","slug":"JVM类加载机制","date":"2018-01-23T13:11:38.000Z","updated":"2018-01-23T13:11:38.000Z","comments":true,"path":"2018/01/23/JVM类加载机制/","link":"","permalink":"https://xiepuhuan.github.io/2018/01/23/JVM类加载机制/","excerpt":"","text":"1. 简介Java代码编译成字节码后，字节码需要通过虚拟机的加载才能运行 2. 类加载过程类加载的全过程分为5个阶段，其中验证、准备、解析属于连接阶段 加载 验证 准备 解析 初始化 加载加载是类加载过程的一个阶段，此阶段可以分为三步 通过一个类的全限定名（如java.lang.Object）来获取此类的二进制流 将这个字节流所代表的静态数据结构方法区运行时的数据结构 在内存中生成代表这个类的Class对象（Java虚拟机规范并没有明确规定这个对象在Java堆里，但是对于HotSpot虚拟机而言，Class对象存在于方法区中） 这个阶段是由类加载器(ClassLoader)来完成 验证验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求。包括四个方面的验证： 文件格式验证 元数据验证 字节码验证 符号引用验证 准备准备阶段时正式为类变量分配内存并设置类变量初始值的阶段，初始值一般是零值，不一般的情况就是类变量用 final修饰初始值是绑定的常量值。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 初始化 初始化阶段是执行类构造器()方法的过程，即静态语句块。 虚拟机会保证父类的()方法先执行。而如果初始化的是接口，并不需要先执行父接口的()方法，只有在使用父接口定义的变量时才会执行。 虚拟机会保证执行()方法时会正确加锁同步。 3. 类加载器类加载的加载阶段是由类加载器来完成的。即使是同一个类，由不同的类加载器来加载，两个类也是不相等的，体现在： Class对象的equals()方法 Class对象的isAssignableFrom方法 Class对象的isInstance()方法 使用instanceof关键字判断对象所属的类 类加载器的分类对于虚拟机来说只存在两种不同的类加载器： 启动类加载器(Bootstrap ClassLoader) 使用C++实现，属于虚拟机自身的一部分。 这个类负责加载&lt;JAVA_HOME&gt;\\lib目录下，或者被-Xbootclasspath参数指定的路径，并且能够被虚拟机识别的类 启动类加载器无法直接被Java程序引用 其他类加载器。使用Java实现，独立于虚拟机外部。并且继承与抽象类java.lang.ClassLoader 扩展类加载器(Extension ClassLoader) 这个类加载器是由sun.misc.Launcher$ExtClassLoader实现 负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录中的，或者被java.ext.dirs系统变量指定的路径的所有类库 扩展类加载器可以直接使用 应用程序类加载器(Application ClassLoader) 这个类加载器是由sun.misc.Launcher$AppClassLoader实现 负责加载用户类路径(ClassPath)上的类库 应用程序类加载器可以直接使用，同时这个类加载器也是ClassLoader类的getSystemClassLoader()静态方法的返回值 类加载器的层次关系(双亲委派模型)双亲委派模型下图是类加载器之间的层次关系，也称为双亲委派模型(Parents Delegation Model)。可以看出除了启动类加载器之外，其他类加载器都有自己的父加载器，但这里的层次关系是以组合来实现，而不是继承(extends)。 双亲委派模型 工作方式双亲委派模型的工作方式是：当一个类加载器收到加载类的请求时，它会先把这个加载请求委托给父类加载器，如果父类加载器不能完成加载（如在自己的搜索路径下找不到该类），这时再由自己来完成加载这个类。通过这个方法，加载请求会委托到启动加载器，如果启动类加载器完成不了再依次向下的类加载器加载。 作用双亲委派模型的作用是所有的加载请求都最先由顶层的类加载器去完成，这样可以保证加载出来的类是同一个，不会混乱。打个比方，我们自己实现了两个类加载器，而这个两个类加载器都不是按照双亲委派模型去实现的，而是自己去对应目录下加载类。现在我们让两个类加载器加载去加载java.lang.Object类，加载出来的两个类必定是不同的（不同的类加载器加载出来的类是不同的）。 自定义类加载器1234567891011121314151617181920212223242526272829303132333435363738394041public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false);&#125;protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 上面的代码是抽象类ClassLoader的loadClass方法，通过类的全限定名来加载类，其中loadClass(String name, boolean resolve)方法实现了双亲委派法。具体步骤为： 通过findLoadedClass方法检查当前类加载器是否加载过该类，加载过就直接返回该Class对象。 如果没有加载过就将该加载请求委托给父加载器，如果没有父加载器则委托给启动类加载器。 如果父加载器无法完成请求则自己使用findClass方法加载该类 所以现在自定义类加载器想依照双亲委派模型去实现可以直接继承ClassLoader类并重写findClass方法。要是不想受照双亲委派模型约束可以直接重写loadClass方法。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://xiepuhuan.github.io/categories/Java虚拟机/"}],"tags":[]},{"title":"Java异常","slug":"Java异常","date":"2018-01-19T16:43:47.000Z","updated":"2018-01-19T16:43:47.000Z","comments":true,"path":"2018/01/20/Java异常/","link":"","permalink":"https://xiepuhuan.github.io/2018/01/20/Java异常/","excerpt":"","text":"1. 简介异常类继承图 异常 Java的错误类(Error)和异常类(Exception)都是Throwable的子类，基本由这两大类展开的。 ErrorError这个类通常指的是系统级的错误，如OutOfMemoryError（内存溢出）、StackOverflowError（栈溢出）这些错误，当出现这些错误时基本是系统问题，基本不能通过捕获去恢复，所以不要求捕获或声明。此时可以由它抛出异常然后记录下来，事后分析。 ExceptionException其实也分为两类异常 不受检查异常（RuntimeException）不受检查异常即是RuntimeException和RuntimeException的子类，如NullPointerException（空指针异常）、ArrayIndexOutOfBoundsException（数组下标越界异常）、IllegalArgumentException（非法参数异常）。这类异常不要求try catch捕获或throws声明抛出，因为出现此类异常通常是由于代码问题，如果任由程序运行下去可能会出现意想不到后果，所以不应该捕获处理试图恢复。 受检查异常受检查异常即除了RuntimeException外Exception类和Exception下的子类，如InterruptedException、IOException。出现此类异常必须在编译前捕获或声明抛出，否则编译不通过。此类异常通常是可以捕获并有效处理所以不能忽略。 2. 注意 只针对异常的情况使用异常机制，不应该将他们用于正常的控制流 对可恢复的情况使用受检查异常，对编程错误使用运行时异常 避免不必要地使用受检查异常 优先使用标准的异常（JDK中的异常） 不要忽略异常","categories":[{"name":"Java","slug":"Java","permalink":"https://xiepuhuan.github.io/categories/Java/"}],"tags":[]},{"title":"HashMap源码解析","slug":"HashMap源码解析","date":"2018-01-13T14:55:06.000Z","updated":"2018-01-13T14:55:06.000Z","comments":true,"path":"2018/01/13/HashMap源码解析/","link":"","permalink":"https://xiepuhuan.github.io/2018/01/13/HashMap源码解析/","excerpt":"","text":"1. 简介HashMapJava中的HashMap是符号表的一种哈希实现（采用拉链法），HashMap用来存储键值对，键和值都可以为Null，其中键是唯一的。在Java7中的实现是用数组+链表，在Java8中的实现是数组+链表+红黑树。因为引进了红黑树的，所以Java8中的HashMap的查找效率提高了不少。以下的讲解的源码也是Java8的源码。 拉链法 拉链法是一种处理哈希冲突的一种方法，其他的还有线性探测法、平方探测法、双散列法。 拉链法将产生冲突的元素放在数组冲突位置上的一个存储结构上（一般是链表） 2. 实现HashMap内部结构 在HashMap中，数组table的大小是2的n次幂。 当HashMap中的键值对数量超过threshold这个阈值时，需要对数组进行扩容。为了避免数组过小导致每个数组位置存储的链表过长或红黑树过大，导致查找效率低下。这其实是一种以空间换时间的方法。 当数组中的链表超过8时，将链表换成红黑树以提高查找效率。 HashMap内部结构图 属性12345678910111213static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; /默认初始容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /最大容量static final float DEFAULT_LOAD_FACTOR = 0.75f; /加载因子static final int TREEIFY_THRESHOLD = 8; /由链表转换为红黑树时链表长度的阈值static final int UNTREEIFY_THRESHOLD = 6; /由红黑树转换为链表时红黑树大小的阈值static final int MIN_TREEIFY_CAPACITY = 64; /由链表转换为红黑树时桶的阈值transient Node&lt;K,V&gt;[] table; transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; transient int size; /哈希表当前的键值对数量transient int modCount; /哈希表内部结构发生变化的次数int threshold; /扩容的阈值final float loadFactor; /负载因子 结点类型在HashMap中存储的键值对都是Node或是Node的子类，链表的结点类型是Node，红黑树的结点类型是TreeNode。123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; /储存对key使用hash方法得出来的值 final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 构造函数 initialCapacity参数用来确定哈希表初始容量（桶的数量），不过并不直接使用initialCapacity来作为初始容量，而是使用由tableSizeFor方法来得出不小于initialCapacity的第一个2的n次幂的正整数（例如输入8返回8，输入9返回16）作为初始容量。 loadFactor用来指定负载因子 当构造函数执行完并不会创建Node的数组，而是等到put方法执行时由resize方法创建。1234567891011121314151617181920212223public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; hash方法进行查找操作最重要的一步就是确定键在哪个桶中，其中第一步就用到hash方法，使用到hash方法是为了使键在数组中的分布更加均匀，减少冲突：1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 接着利用(n - 1) &amp; hash（n是数组table的大小）得出键在哪个桶中，那这里为什么不用hash % n呢？因为位运算的速度比求余快。这里的table的大小必须是2的n次幂，原因有两个： 因为n - 1之后高位为0，低位部分为1，使得哈希方法结果在参与与运算之后有意义，从而减少冲突。 为之后的扩容方法做优化 put方法数组table就是第一次执行put方法时创建出来的。 put方法执行流程图 put方法执行流程图 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; /数组还没创建或者数组大小为0 if ((tab = table) == null || (n = tab.length) == 0) /执行扩容操作 n = (tab = resize()).length; /求得键所在的桶，并判断是否为空 if ((p = tab[i = (n - 1) &amp; hash]) == null) /若为空直接添加结点作为链表头结点到该位置上 tab[i] = newNode(hash, key, value, null); else &#123; /e是用来存储找到的结点 Node&lt;K,V&gt; e; K k; /如果该桶的第一个结点就是，则找到 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; /否则判断该桶存储的是否为一棵红黑树 else if (p instanceof TreeNode) /调用putTreeVal方法向该树插入该结点，如果返回为空则插入成功，否则在树中找到该结点 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; /遍历该桶的链表 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; /当发现下个结点为空，证明已经遍历完所有结点还没发现key所在的结点 那就直接插入新结点 p.next = newNode(hash, key, value, null); /判断链表长度是否超过8，是就将链表树形化 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; /找到key所在的结点则退出 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; /判断结点是否为空，不为空则找到 if (e != null) &#123; // existing mapping for key V oldValue = e.value; /如果允许结点存在时替换旧的值或者旧的值为null则替换旧值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 扩容方法Java 1.8里的扩容方法比较特别的一个优化就是扩容后结点的转移，例如对于原数组的一个桶中的所有元素要转移到新数组中需要一个个重新用hash &amp; (n - 1)计算新位置吗？当然不用。得益于数组大小的特点（2的n次幂），我们可以轻易知道原数组的一个桶中所有结点转移到新数组中只会存在于两个位置： 原索引 原索引 + oldCap image 关于这个的原理观察一下这个hash &amp; (n - 1)和上图你就能发现扩容后改变的是n，而与hash进行与运算的n - 1比原来多了一位1，与运算后出来的索引比原来多一种可能，而这种可能就是在原索引的基础上加上oldCap。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; /若原数组的大小已经大于0 if (oldCap &gt; 0) &#123; / 若原数组大小已经达到最大值，则设置阈值为Integer.MAX_VALUE，即以后不能再执行扩容方法 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125;/否则将数组扩大一倍， else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) /扩容后数组的大小未达到最大值并且旧数组大小不小于默认初始容量则将阈值也扩大一倍 newThr = oldThr &lt;&lt; 1; &#125;/否则如果旧阈值大于0（即在构造函数中给出了initialCapacity） else if (oldThr &gt; 0) newCap = oldThr; else &#123; /未给定initialCapacity就使用默认初始容量，阈值也是默认的 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; /如果没有设置新阈值 if (newThr == 0) &#123; /计算出新阈值 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; /当旧数组不为空时，将旧数组里的所有结点转移到新数组里去 if (oldTab != null) &#123; /遍历数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; /判断桶是否为空 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; /如果该桶只有一个结点，就直接将该结点转移到新数组对应的桶中 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; /否则如果结点是TreeNode类型，执行split方法 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order /两条链表 第一条是代表原索引位置上的链表 第二条是代表原索引 + oldCap位置上的链表 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; /遍历该链表 do &#123; next = e.next; /若该结点在新数组中的索引为原索引 if ((e.hash &amp; oldCap) == 0) &#123; /若链表为空，添加该结点为头结点 if (loTail == null) loHead = e; else /否则在尾部添加该结点 loTail.next = e; loTail = e; &#125;/否则该结点在新数组中的索引为原索引 + oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); /如果链表不为空将该链表添加到新数组 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 树形化当添加一个结点后如果结点所在链表的长度大于8时，要将链表树形化（转换为红黑树）。但是进行树形化还需要满足一个条件，就是数组的大小要不小于MIN_TREEIFY_CAPACITY。1234567891011121314151617181920final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; remove方法remove方法执行过程图 remove方法执行过程图 源码分析 matchValue是一个布尔型参数，为false表示不需要匹配值，为true表示需要匹配值，值一样才算找到 movable表示移除红黑树结点时需不需要移动其他结点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; /只有在表不为空且找到键所在的桶也不为空才能继续 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; /判断第一个结点是否是要找的结点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; /否则当存在下一个结点才继续 else if ((e = p.next) != null) &#123; /判断桶中的结点是否是红黑树的结点 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123;/否则遍历链表寻找结点 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; /结点不为空则为找到 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 迭代器在HashMap里一共有三种迭代器： KeyIterator ValueIterator EntryIterator 这三种迭代器都继承了HashIterator类并实现了Iterator接口供KeySet、Values、EntrySet使用。其中最重要的HashIterator是用来迭代哈希表中的结点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; /找到第一个不为空的桶 if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; /如果modCount != expectedModCount则表示可能有其他线程修改了哈希表或者当前线程调用非迭代器的方法修改 if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); /设置current为当前结点并找到下一个结点赋值给next if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125;&#125; 在HashMap中的modCount是和迭代器中expectedModCount搭配起来提供快速失败机制（fail-fast）的。 体现在用迭代器遍历HashMap时，如果遍历过程中对集合对象的内容进行了修改，可能会导致迭代器遍历出现异常。所以每次使用next、remove方法都会先判断modCount与expectedModCount是否相等，如果不相等则表示被修改过，就会抛出ConcurrentModificationException。在迭代器遍历HashMap时如果想移除遍历到的值可以使用Iterator的remove方法。 3. 最后 HashMap是无序的，即无法维持键值对的先后插入顺序，也无法提供按键排序的功能，如要使用有序的map（符号表），可以使用下面两种： LinkedHashMap：LinkedHashMap是HashMap的子类，可以保证插入的先后顺序，用迭代器遍历LinkedHashMap时，先得到的记录是先插入的，也可以在构造时指定参数，按照访问次序进行排序。 TreeMap: TreeMap实现SortedMap接口，可以把记录按键的大小排序，默认是升序排序，也可以指定比较器进行排序，当用迭代器遍历TreeMap时，得到的记录是排过序的。 HashMap不是线程安全的类，不能适用于多线程的环境。不过有三种方式使用线程安全的map（符号表）： Hashtable： 已过时的类不推荐使用。 ConcurrentHashMap：推荐使用，使用CAS机制使得并发情况下效率比Hashtable高 Collections.synchronizedMap(map)：使用静态工厂方法将HashMap对象封装成一个线程安全的类，因为SynchronizedMap使用了synchronized关键字，所以并发效率不如ConcurrentHashMap高。","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"地址解析协议(ARP)","slug":"地址解析协议(ARP)","date":"2017-12-09T03:58:03.000Z","updated":"2017-12-09T03:58:03.000Z","comments":true,"path":"2017/12/09/地址解析协议(ARP)/","link":"","permalink":"https://xiepuhuan.github.io/2017/12/09/地址解析协议(ARP)/","excerpt":"","text":"1. 简介同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。如果知道其IP地址，则可以通过ARP（Address Resolution Protocol，地址解析协议）查询到其MAC地址。ARP仅用于IPv4，IPv6使用ICMPv6。 2. ARP帧格式 ARP帧格式 上图是一个以太网封装上层ARP包后的以太网帧，其中的一些字段，如 硬件类型：硬件地址类型，如以太网的值为0x0001 协议类型：映射的协议的地址类型，如IPv4的值为0x0800 硬件地址长度：硬件地址占多少个字节的长度，如以太网占6个字节，该值就为6 协议地址长度：协议地址占多少个字节的长度，如IPv4占4个字节，该值就为4 OP：指出这个ARP包是一个请求或响应包，请求为1，响应为2 3. 原理 ARP抓包结果 以主机A(192.168.1.103)向所在子网的主机B(192.168.1.101)发送数据为例： 当主机A发送数据时，主机A会在本机的ARP缓存表中寻找是否有主机B的IP地址。 如果找到就知道主机B的MAC地址为主机B的MAC地址，直接把主机B的MAC地址写入帧首部发送数据。 如果在ARP缓存表中没有找到主机B的MAC地址，主机A就会在网络上广播一个ARP请求帧。如下图： ARP请求结果 同一子网上的主机都会收到这个帧，并且根据ARP包的内容更新自己的ARP缓存表。但只有主机B接收到这个帧时，单播一个目的IP地址为192.168.1.103的ARP响应帧，其他主机则丢弃这个请求帧。 ARP响应结果 ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xiepuhuan.github.io/categories/计算机网络/"}],"tags":[]},{"title":"动态主机配置协议(DHCP)","slug":"动态主机配置协议(DHCP)","date":"2017-12-06T16:18:11.000Z","updated":"2017-12-06T16:18:11.000Z","comments":true,"path":"2017/12/07/动态主机配置协议(DHCP)/","link":"","permalink":"https://xiepuhuan.github.io/2017/12/07/动态主机配置协议(DHCP)/","excerpt":"","text":"1. 简介 计算机要互联通信自身肯定需要网络 ，如IP地址、子网掩码、DNS服务器地址等。而为了实现IP地址的自动设置与统一分配，DHCP就这样孕育而生了。 动态主机配置协议(DHCP)是一个应用层协议，也就是位于TCP/IP 5层协议模型的第5层，同时它也是一个客户机-服务器协议。 DHCP的设计基于早期的Internet引导程序协议(BOOTP)，使用UDP/IP协议，客户端使用端口68，服务端使用端口67。 DHCP服务器可提供三种地址分配： 手动分配由网络管理员在DHCP服务器手工配置DHCP客户机的IP地址。 自动分配当DHCP客户机第一次向DHCP服务器请求到IP地址后，这个地址就永久地分配给了该DHCP客户机，不可撤销。 动态分配（最常见）与自动分配采用相同的方法，只不过获得的IP地址是有租约期限的，一旦租约到期，地址就会被回收，不过可以通过续订租约以延长期限。 2. 消息格式DHCP扩展了BOOTP，DHCP消息格式的定义也采用了扩展BOOTP的方式以保持两种协议之间的兼容性。消息格式由一个固定大小的初始部分和一个可变长度的选项部分组成。 DHCP消息格式 字段说明初始部分 字段 说明 Op 消息类型，1表示请求，2表示响应 HW Type 硬件地址类型，1表示以太网 HW Len 硬件地址长度，如以太网地址长度6个字节值就为6 Hops 保存消息传输过程中继的的次数，默认为0 Transaction ID 事物ID。客户机所选择的一个随机数，服务器把它复制到响应消息中，用于将应答和请求匹配 Secs 获取到IP地址或者续约过程开始到现在所消耗的时间，以秒为单位。在没有获得IP地址前该字段始终为0 Flags 标志字段。该16位比特字段的最左边的位为 0 ，表示单播，为 1 表示广播 Client IP address 客户机IP地址 “Your” IP address DHCP服务器为客户机提供的IP地址存放在此字段 (Next) Server IP address 下一个为DHCP客户端分配IP地址等信息的DHCP服务器IP地址。仅在DHCP Offer、DHCP ACK报文中显示，其他报文中显示为0。 Gateway (Relay) IP address 由DHCP或BOOTP中继器填写，如果消息没有经过中继器则此字段为0 Client Hardware address 客户机硬件地址 Server Name 可选的服务器主机名，是一个null结尾的字符串，由服务器填写 Boot File Name 引导文件名。是一个null结尾的字符串，DHCP OFFER 报文中提供有效的文件路径，其他消息中不显示， 一般不使用 Options 选项字段。可变字段，格式为”代码+长度+数据”，是DHCP消息和BOOTP消息的区别之处 选项部分 代码 字段名称 1 子网掩码 3 路由器地址 6 域名服务器 15 域名 50 请求的IP地址 51 地址租用期 53 DHCP消息类型 54 服务器标识符 55 参数请求列表 56 DHCP错误信息 58 租约更新时间 59 租约重新绑定时间 61 客户机标识符 119 域搜索列表 255 结束 其中53（DHCP消息类型选项）有多个可能的值： DHCP DISCOVER DHCP OFFER DHCP REQUEST DHCP ARK DHCP NAK DHCP DECLINE DHCP RELEASE DHCP INFORM DHCP FORCERENEW DHCP LEASEQUERY DHCP LEASEUNASSIGNED DHCP LEASEUNKNOWN DHCP LEASEACTIVE 3. 操作和状态操作过程 上图显示的是当一个DHCP客户端向DHCP服务器新请求一个IP地址的过程： Wireshark抓包结果 获取过程 发现阶段 由于不知DHCP服务器的IP地址和Mac地址，DHCP客户机通过向本地网络广播一个DHCP DISCOVER请求报文以向网络中的DHCP服务器请求网络配置信息。 最后本地网络上每个DHCP服务器都会接收到DHCP发现报文，而同时其他主机也会收到此报文，只不过当拆包后发现源IP地址是0.0.0.0后就会抛弃这个包。 提供阶段 当DHCP服务器收到发现报文，它就从它的地址池中选出一个空闲IP填充到DHCP OFFER的“Your” IP address字段，并在选项字段加上子网掩码，路由器，DNS，服务器标识，IP地址租用时间等字段。再广播此报文（因为此时还不知客户机的IP地址） 请求阶段 最后客户机可能会收到多个DHCP服务器的DHCP OFFER报文，一般是选最先到达那个报文并作出回应请求，即广播发出一个 包含服务器选项字段的DHCP REQUEST报文。这里还使用广播的目的是因为要让所有的DHCP服务器知道客户机选择了哪个服务器提供的IP。 DHCP服务器收到来自客户机的DHCP REQUEST报文，而只有符合服务器标识这个选项字段的DHCP服务器才会对此作出响应： 如果服务器可以分配此IP则以DHCP ACK报文进行响应。 如果服务器无法分配此IP则以DHCP NAK报文进行响应。 其他DHCP服务器则清除与此请求相关的状态。响应方式还是跟提供阶段一样广播此报文。 当DHCP客户机收到的响应是DHCP NAK报文，则会重新发送 DHCP DISCOVER报文。 若收到的是DHCP ACK报文则会执行地址冲突检测(ACD)探测获得的IP地址是否未被使用。 如果已经被使用则向DHCP服务器发送一个DHCP DECLINE报文以通知该地址已经不能被使用。之后经过默认的10秒延时后客户机可再次重试。 如果未被使用则获得了该IP地址在租用期间的使用权。 成功获取后的所有网络配置信息可以通过一条命令查看Windows下： ipconfig /all Linux下： ifconfig 租约更新过程因为实在获得可以使用是IP地址的基础上进行租约时间的更新，所以不必向获取过程那么麻烦，只需要向DHCP服务器发送DHCP REQUEST报文，DHCP服务器收到请求报文如果响应一个DHCP ACK则更新成功。同样这个更新租约时间的过程也可以用一条命令来实现Windows下： ipconfig /renew Linux下： dhclient ###租约的释放如果想在租约结束前释放以获取的IP地址，可以向DHCP服务器发送DHCP RELEASE报文。同样这个释放操作也可以用一条命令来实现Windows下： ipconfig /release Linux下： dhclient -r","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xiepuhuan.github.io/categories/计算机网络/"}],"tags":[]},{"title":"JVM垃圾回收机制(Garbage-Collection)","slug":"JVM垃圾回收机制(Garbage-Collection)","date":"2017-09-16T12:01:21.000Z","updated":"2017-09-16T12:01:21.000Z","comments":true,"path":"2017/09/16/JVM垃圾回收机制(Garbage-Collection)/","link":"","permalink":"https://xiepuhuan.github.io/2017/09/16/JVM垃圾回收机制(Garbage-Collection)/","excerpt":"","text":"1. 概述在Java内存区域里讲了Java的内存运行时数据区域分为如下5个部分 程序计数器(Program Counter) 虚拟机栈(Virtual Machine Stack) 本地方法栈(Native Method Stack) 堆(Heap) 方法区(Method Area) 其中前三个数据区域随着线程的启动而创建，终止而销毁，这三个区域的内存回收具有确定性，不需要过多考虑回收问题。所以JVM的垃圾回收机制的注意力就集中于堆和方法区，其中对堆的GC性价比是最高的，一般可以回收70%~95%的空间。 2. GC过程首先讨论的是对堆的GC，在这之前我们应该知道要进行垃圾回收的步骤应该是 知道哪些对象需要回收？ 用什么方式去回收？ 判断对象的存活针对第一个问题我们得确定堆中对象的“存活”，一个对象的“存活”其实就是能否通过任何途径使用该对象，下面通过一段Code看下就明白：123456public class Main&#123; public static void main(String[] args)&#123; A a = new A(); a = null; &#125;&#125; 在这段Code里面，一开始创建一个A类型的对象，变量a持有这个对象的引用，接着a被赋值为null后。从此就无法通过任何变量来使用这个对象了，那么这个对象也就是所谓的“死亡”了，而GC的 就是这些对象。接下来有两种方法可以找出堆中存活和死亡的对象。 引用计数法(Reference Counting)给每一个对象添加一个引用计数器，每当对象被引用，就对该对象的引用计数器加一，当引用失效时引用计数器就减一。直到对象的引用计数器为0时该对象就是已死亡，可被GC。这种方法看起来简单高效，但JVM却没有使用它来判断对象的存活，原因是它很难解决对象之间相互引用的问题。还是来一段Code看下：123456789101112public class Main&#123; public static void main(String[] args)&#123; A a = new A(); B b = new B(); a.ref = b; b.ref = a; a = null; b = null; &#125;&#125; 在这段Code中，a和b两个引用最后都null，也就是无法通过它们来使用一开始创建的两个对象，虽然这样它们却无法回收，原因是创建的两个对象相互引用导致两个对象的引用计数器都不为0。所以也就有了第二种方法（可达性分析）来解决这个问题。 可达性分析算法(Reachability Analysis)把堆中所有对象当成一幅有向图中的所有点，对象之间的引用构成了点与点的之间的路径。接着从一系列被称为GC Roots（一些被引用的对象）的点出发遍历整个图，图中所有可以到达的点都是存活的对象，而那些不可到达的点则为死亡对象，将被GC。可充当GC Roots的对象有下面几种： 虚拟机栈中栈帧中本地变量表中变量引用的对象 本地方法栈中本地的方法引用的对象 方法区中类静态变量引用的对象 方法区中常量引用的对象 垃圾回收算法解决完第一个问题（判断对象的存活）后，就可以去回收这些对象占用的内存了，至于怎么回收这些内存，有下面几种算法： 标记-清除算法(Mark-Sweep)标记-清除算法如同它的名字一样，有标记和清除两个阶段。其中的标记阶段就是上面说到的确定对象的存活阶段，确定了要回收的对象后就回收死亡的对象，存活的对象留在原地。标记清除算法是最基础的回收算法，它有两个缺点： 标记和清除阶段效率都不高 清除之后内存会产生大量不连续的碎片，导致分配大内存对象困难 标记清除算法 复制算法(Copying)复制算法将内存分为大小相等的两块，每次只使用一块，待这块内存用完，将这一块上存活的对象复制到另一块上，再把存在垃圾对象的那一块占用的内存一次清掉。这样做效率高的原因是存活的对象远远少于死亡的对象，从而只需复制少量的存活对象。 复制算法 复制算法解决了标记-清除算法的清除阶段效率低的问题和碎片问题但却使可用内存减少一半。其实有个办法可以解决这个问题： IBM公司的专业研究表明新生代中的对象98%是“朝生夕死”的，所以并不用按照1:1来划分空间，而是将内存分为3块。一块80%大小的Eden空间和两块10%大小的Survivor空间，每次使用一块Eden和一块Survivor，当需要回收时，将使用中的Eden和Survivor上的存活对象复制到另一块Survivor上，最后直接清理使用过的Eden和Survivor的内存空间。这样就使得空间的利用率达到90%。但如果存活的对象超过10%的话，Survivor的空间就不够用了，这时就需要依赖老年代进行分配担保。 标记整理算法(Mark-Compact)相比于复制算法，标记整理算法使用与适用于老年代这种对象存活率高的区域。标记整理和标记清除很相似，前面的标记步骤都一样，不一样在标记整理在清除前多做了整理步骤让存活的对象向一端移动，最后在清除掉端边界以外的内存。 标记整理算法 分代收集算法(Generational Collection)因为现在的商用JVM的垃圾回收都采用分代收集算法，所以一般把堆内存划分为新生代和老年代。刚创建的对象存在于新生代中，当有一些对象经历垃圾回收达到一定次数还存活下来的话，这些对象将进入老年代，所以老年代里的对象每次GC存活率都很高。因此针对于新生代和老年代对象的不同存活率，可以分别采取不同的垃圾回收算法，对于对象存活率低的新生代采用复制算法，而对于对象存活率高的老年代采用标记清除或标记整理算法。 以上介绍的是关于堆中的GC，下面来说下方法区的GC。 方法区的GC方法区在HotSpot虚拟机中是永久代，相比于堆中的新生代和老年代，永久代进行垃圾回收的性价比更低。方法区的垃圾回收主要回收废弃常量和无用的类，其中常量来自于方法区的常量池，包括字面值常量和符号引用。回收常量跟回收堆中对象非常类似，以字面值常量为例，如果不存在其他对象引用该字面值常量，如果发生GC且有必要的话，该字面值常量会被回收。对于无用的类的判断比较苛刻，必须同时满足下列三个条件： 该类的所以实例都被回收 加载该类的类加载器已经被回收 该类对应的Class对象没有在任何地方被引用 不过也可以满足了上面的三个条件也不进行回收，可以通过设置虚拟机参数来控制回收。 3. 内存分配策略 对象优先在 Eden 分配对象优先在新生代的 Eden 区分配，当 Eden 区空间不够时，执行Minor GC 大对象直接进入老年代设置 -XX:PretenureSizeThreshold 参数，大于该参数的值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制 长期存活的对象进入老年代对象头的Mark word拥有一个存储分代年龄字段，每经历一次 Minor GC 存活下来该年龄字段加1，直到该年龄超过 XX:MaxTenuringThreshold 设置的值（默认15），则移动到老年代。 动态对象年龄判定若 Survivor 区中同年龄所有对象大小总和大于 Survivor 空间一半，则年龄大于等于该年龄的对象可以直接进入老年代。 空间分配担保在发生 Minor GC 之前，JVM 先检查老年代最大可用连续空间是否大于新生代所有对象大小，成立的话 Minor GC 确认是安全的，则进行Minor GC；否则如果 HandlePromotionFailure 设置的值为true并且老年代最大可用连续空间大于历次晋升到老年代对象的平均大小，则进行 Minor GC，否则进行 Full GC。 4. Minor GC 与 Full GC触发条件 Minor GC：当 Eden 区空间满时，就将触发 Minor GC Full GC： 调用 System.gc() 大多情况下回触发Full GC，通过 -XX:+ DisableExplicitGC 来禁止 RMI 调用System.gc()。 老年代空间不足 空间分配担保失败 JDK 1.7 及以前的永久代空间不足","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://xiepuhuan.github.io/categories/Java虚拟机/"}],"tags":[]},{"title":"Java内存区域","slug":"Java内存区域","date":"2017-09-03T08:19:40.000Z","updated":"2017-09-03T08:19:40.000Z","comments":true,"path":"2017/09/03/Java内存区域/","link":"","permalink":"https://xiepuhuan.github.io/2017/09/03/Java内存区域/","excerpt":"","text":"Java虚拟机(Java Virtual Machine)在执行Java程序时会把它所管理的内存划分为如下5个不同的运行时数据区域。 1. 程序计数器(Program Counter)对于一个运行中的Java程序来说，每当启动一个线程时都会创建一个属于自己的程序计数器，各个线程之间的计数器互不影响。如果线程执行的是一个方法(非本地方法)，那么计数器记录的是正在执行的虚拟机字节码指令的地址；要是线程执行的是一个本地方法(Native Method)，那么计数器则为空(Undefined)。 2. 虚拟机栈(Virtual Machine Stack)与程序计数器一样，每当启动一个线程时都会创建一个属于自己的虚拟机栈，各个线程之间的虚拟机栈互不影响。线程执行时每调用一个方法，就会创建一个栈帧(Stack Frame)压到虚拟机栈中，当方法执行完正常返回或者抛出异常导致终止都会弹出栈帧。栈帧用于存储本地变量表，操作数栈，动态链接，方法出口等信息。本地变量表的大小在编译时就已经确定并存在于class文件中，在方法运行时大小不会再改变。 3. 堆(Heap)堆是所有线程共享的内存区域，几乎所有的对象实例和数组都在堆上分配。 4. 本地方法栈(Native Method Stack)本地方法栈是为执行本地方法服务的。 5. 方法区(Method Area)方法区是所有线程共享的内存区域，用于存储类信息，常量，静态变量，即时编译器编译后的代码等数据。其中方法区有一个常量池(Constant Pool)，在编译期间确定用于存放编译期生成的字面值常量和符号引用，这部分将在类加载后进入方法区的常量池存放。","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://xiepuhuan.github.io/categories/Java虚拟机/"}],"tags":[]},{"title":"单例模式(Singleton-Pattern)","slug":"单例模式(Singleton-Pattern)","date":"2017-09-01T16:59:00.000Z","updated":"2017-09-01T16:59:00.000Z","comments":true,"path":"2017/09/02/单例模式(Singleton-Pattern)/","link":"","permalink":"https://xiepuhuan.github.io/2017/09/02/单例模式(Singleton-Pattern)/","excerpt":"","text":"1. 引言单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，属于设计模式中的创建型模式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。单例模式应用于要求只存在一个单例类对象的场景，如线程池，注册表，如果创建出不只一个该类的实例那就会出现问题。 2. 注意单例模式的实现有多种不同的实现，每种实现都有其优缺点，有些缺点明显，选择合适的实现非常重要。 3. 实现饿汉式 优点 缺点 线程安全 非懒加载 效率高 不能阻止反射攻击 实现简单 123456789class Singleton&#123; private static final Singleton INSTANCE = new Singleton(); private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 优点： 同样饿汉式里的线程安全性是由类加载机制保证。 因为调用方法获取实例时不需要进行同步，相比需要线程同步的实现方式效率更高。 代码量少，实现简单 缺点： 非懒加载是指类初始化时就创建实例对象，而不等到需要该对象时调用getInstance()方法才创建对象，导致提早创建对象，如果对象很大时而之后不需要用，那就太占有内存了。 即使构造函数是私有的，但是却可以利用反射机制去访问构造函数从而创建出不只一个对象，这就违背了单例模式的原则。 懒汉式（非线程安全） 优点 缺点 懒加载 非线程安全 效率高 不能阻止反射攻击 实现简单 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; if (instance == null) instance = new Singleton(); return instance; &#125;&#125; 缺点： 不具备线程安全性，严格意义来说不能算单例模式。 懒汉式（线程安全） 优点 缺点 线程安全 效率低 懒加载 不能阻止反射攻击 实现简单 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton()&#123;&#125;; public static synchronized Singleton getInstance()&#123; if (instance == null) instance = new Singleton(); return instance; &#125;&#125; 缺点：虽然实现了线程安全性，但是这种实现方法导致每次访问getInstance()方法时都要加锁，效率大大下降。 双重检验锁(Double Checked Locking) 优点 缺点 线程安全 不能阻止反射攻击 效率高 较复杂 懒加载 123456789101112131415class Singleton&#123; private volatile static Singleton instance; private Singleton()&#123;&#125;; public static Singleton getInstance()&#123; if (instance == null)&#123; synchronized (Singleton.class)&#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 优点：DCL的线程安全性是通过加锁来保证的，而且加锁的过程只是发生在第一次获取对象的时候，所以效率还是很高。还有一个重要的点就是instance字段要用volatile修饰来禁止指令重排。 静态内部类(Static Inner Class) 优点 缺点 线程安全 不能阻止反射攻击 效率高 懒加载 123456789101112class Singleton&#123; private Singleton()&#123;&#125;; private static class SingletonHolder&#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonHolder.INSTANCE; &#125;&#125; 枚举(Enum) 优点 缺点 线程安全 非懒加载 效率高 实现简单 可阻止反射攻击 提供序列化机制，并且反序列化时可避免出现多个实例 123enum Singleton &#123; INSTANCE; &#125; 优点： 枚举里面的INSTANCE字段是public static final Singleton类型的，线程安全性有类加载阶段保证，因此不需要进行额外的同步操作，效率高，实现简单。 反射机制已经针对了枚举类型的对象做了处理，可以保证不能通过反射机制创建多个对象，所以可以阻止反射攻击。 同样的，序列化机制也对枚举类型的对象做了处理，在序列化的时候仅仅是将枚举对象的name属性序列化，反序列化的时候则是通过Enum 的 valueOf() 方法来根据名字查找枚举对象。因此反序列化后的实例也会和之前被序列化的对象实例相同。 现在发现只有枚举提供了阻止反射攻击和避免反序列化多个不同实例的序列化机制，那其他实现方法可不可以提供这两种功能呢，答案是可以的。1. 对于反射来说，虽然构造函数是私有的，但反射可以通过访问私有的构造函数来创建多个对象。既然是单例模式，那么我们可以在创建第二个抛出异常。只需修改构造函数，如下：12345678private static boolean TAG;private Singleton()&#123; if (TAG)&#123; throw new IllegalArgumentException(\"Cannot create object\"); &#125;else &#123; TAG = true; &#125; &#125; 2.要让对象支持序列化操作，该对象的类需要implements Serializable，并且在类中增加一个方法private Object readResolve()，这个方法会在反序列化完后调用，其中返回的对象替代了原来反序列化生成的对象。如下：123private Object readResolve()&#123; return INSTANCE; &#125; 4. 最后就以上来看，我觉得实现单例的最佳方式应该是静态内部类和枚举，其中静态内部类真是优点满满啊。对于枚举来说，别看简简单单只写出两三行代码，其实它是java的一颗语法糖，反编译过后你就知道它干货满满。而且要知道它背后反射和序列化对它做的优化，知识点真心不少。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://xiepuhuan.github.io/categories/设计模式/"}],"tags":[]},{"title":"Internet控制报文协议(ICMP)","slug":"Internet控制报文协议(ICMP)","date":"2017-08-25T04:50:23.000Z","updated":"2017-08-25T04:50:23.000Z","comments":true,"path":"2017/08/25/Internet控制报文协议(ICMP)/","link":"","permalink":"https://xiepuhuan.github.io/2017/08/25/Internet控制报文协议(ICMP)/","excerpt":"","text":"1. 简介IP协议本身没有为终端提供直接的方法来发现那些发往目的地址失败的IP数据包、相关的诊断信息等。为了解决这些问题，Internet控制报文协议(Internet Control Message Protocol，ICMP)出现了，ICMP被主机和路由器用来沟通网络层信息。ICMP既不是网络层协议，也不是传输层协议，而是介于两者之间。 2. ICMP报文格式 ICMP报文格式","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xiepuhuan.github.io/categories/计算机网络/"}],"tags":[]},{"title":"Class文件","slug":"Class文件","date":"2017-08-22T19:12:15.000Z","updated":"2017-08-22T19:12:15.000Z","comments":true,"path":"2017/08/23/Class文件/","link":"","permalink":"https://xiepuhuan.github.io/2017/08/23/Class文件/","excerpt":"","text":"1. 简介Class文件是一种与平台无关的字节码文件，每一个Class文件都对应一个类或接口的定义信息，它包含了Java虚拟机指令集和符号表以及其他辅助信息。Class文件只与Java虚拟机有关，可以由不同的语言编写的源代码编译而来。 2. 结构Class文件是一组以8个字节为基础单位的字节流。在下表的数据项中： u1、u2、u4、u8类型分别代表1个字节、2个字节、4个字节、8个字节的无符号数 _info结尾的类型是表类型，是由多个无符号数或其他表作为数据项的复合数据类型 类型 名称 数量 u4 magic（魔数） 1 u2 minor_version（副版本号） 1 u2 major_version（主版本号） 1 u2 constant_pool_count（常量池计数器） 1 cp_info constant_pool（常量池） constant_pool_count-1 u2 access_flags（访问标志） 1 u2 this_class（类索引） 1 u2 super_class（父类索引） 1 u2 interfaces_count（接口计数器） 1 u2 interfaces（接口表） interfaces_count u2 fields_count（字段计数器） 1 field_info fields（字段表） fields_count u2 methods_count（方法计数器） 1 method_info methods（方法表） methods_count u2 attributes_count（属性计数器） 1 attribute_info attributes（属性表） attributes_count 数据项含义magic（魔数）每个Class文件头4个字节就是魔数，魔数的作用是确定这个文件是否为一个能被虚拟机所接受的Class文件。魔数的值固定为0xCAFEBABE。 主版本号 &amp; 副版本号主副版本号共同构成了Class文件的版本号，规定了这个版本号的Class文件只能由不低于这个版本号的虚拟机执行。 constant_pool_count（常量池计数器）常量池计数器的值代表了常量池的容量。这里需要注意一点常量池的容量比常量池的常量数据项还要多1，因为常量池常量的索引是从1开始的。举个例子：常量池有8个常量，那么常量池的索引就是1-8，空出了0这个索引，那么常量池计数器表示为常量池容量就为9（即0-8）。 constant_pool（常量池）常量池中主要存放两大类常量： 字面值 字符串 声明为final的常量 符号引用 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 access_flags（访问标志）访问标志用于表示某个类或者接口的访问权限及基础属性 类索引（this_class）类索引的是一个u2类型的数据项，它的值表示指向常量池中当前类或接口的索引，即一个CONSTANT_Class_info类型的符号引用。 super_class（父类索引）父类索引的是一个u2类型的数据项，它的值表示指向常量池中父类的索引，即一个CONSTANT_Class_info类型的符号引用。 interfaces_count（接口计数器)接口计数器表示该类或接口实现的接口数量 interfaces（接口表）一个数据项类型为u2的集合，每一项表示指向常量池中接口的索引，即一个CONSTANT_Class_info类型的符号引用。 fields_count（字段计数器）字段计数器表示类或接口声明的变量的数量，不包括方法中声明的变量。 fields（字段表）一个数据项类型为field_info的集合，描述了各个字段，field_info的结构如下： 类型 名称 数量 u2 access_flags（访问标记，修饰符） 1 u2 name_index（常量池中该字段简单名称的索引） 1 u2 descriptor_index（常量池中该字段描述符的索引） 1 u2 attributes_count 1 attribute_info attributes attributes_count methods_count（方法计数器）方法计数器表示类或接口中定义的方法数量 methods（方法表）一个数据项类型为method_info的集合，描述了各个方法，field_info的结构如下： 类型 名称 数量 u2 access_flags（访问标记，修饰符） 1 u2 name_index（常量池中该字段简单名称的索引） 1 u2 descriptor_index（常量池中该字段描述符的索引） 1 u2 attributes_count 1 attribute_info attributes attributes_count","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://xiepuhuan.github.io/categories/Java虚拟机/"}],"tags":[]},{"title":"数据库基本概念","slug":"数据库基本概念","date":"2017-08-22T03:41:30.000Z","updated":"2017-08-22T03:41:30.000Z","comments":true,"path":"2017/08/22/数据库基本概念/","link":"","permalink":"https://xiepuhuan.github.io/2017/08/22/数据库基本概念/","excerpt":"","text":"1. 事务定义事务也是在存储引擎层实现的，可以这么说，事务本质就是一组SQL语句，但是这些SQL语句要么全部执行，要么都不执行。为了保证数据完整性，数据库系统必须维护下面四个性质（即ACID）： 原子性：一个事务是不可分割的，要么事务中的SQL语句全部成功提交，要么全部回滚。 一致性：数据库从一个一致的状态转移到另一个一致的状态，前后数据库的完整性没有被破坏。 隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行。数据库系统中有4种隔离级别。 持久性：事务提交后，所做的修改会一直保存在数据库中。 SQL语句MySQL中开始一个事务并提交的过程如下：1234START TRANSACTION;SELECT * FROM user;DELETE FROM user;COMMIT; 如果想回滚来撤销开始事务之后的SQL语句可以使用ROLLBACK，不过不可以撤销SELECT、CREATE、DROP的操作。 隔离级别事务的隔离性一共有4个隔离级别： READ UNCOMMITTED（未提交读）：对事务的修改即使还未提交，对其他事务也是可见的，即可以读取未提交的数据，会出现脏读的情况。 READ COMMITTED（提交读）：事务从开始到提交前所做的修改对其他事务是不可见的，但是执行同样的查询可能会出现不一样的结果，所以也叫不可重复读。 REPEATABLE READ（可重复读）：可重复读是MySQL事务的默认隔离级别，它解决了脏读的问题，并且保证执行同样的查询的结果相同。 SERIALIZABLE（可串行化）：强制事务串行执行，数据一致性好，但会导致大量锁竞争的问题，并发性弱。 ANSI SQL隔离级别 隔离级别 脏读可能性 不可重复读可能性 幻读可能性 加锁读 READ UNCOMMITTED（未提交读） 是 是 是 否 READ COMMITTED（提交读） 否 是 是 否 REPEATABLE READ（可重复读） 否 否 是 否 SERIALIZABLE（可串行化） 否 否 否 是 幻读幻读是指当某个事物前后执行两条SQL查询语句查询记录，发现前后查询的记录不一致，这时可能其他事务在两次查询之间插入了新记录。MySQL的InnoDB存储引擎通过多版本并发控制(MVCC)解决了幻读问题。 2. 范式范式是关系数据库理论的基础，也是在设计数据库结构过程中所要遵循的规则和指导方法。目前共有8种范式：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的基本是前三个范式： 第一范式(1NF)第一范式指的是字段的原子性，即字段不可再分，但这取决于所面临的场景，如姓名这个字段其实可以分为姓氏和名字。 第二范式(2NF)第二范式要求要有主键约束，即每一条记录都是唯一的，并且其他字段完全依赖于主键。 第三范式(3NF)第三范式即消除传递依赖，非主键字段直接依赖于主键字段。例如在学生表中存在学号、姓名、年龄等字段，其中主键为学号，这时所有非主键字段都直接依赖于学号，这时如果将系编号、系别、系主任加到学生表中就出现传递依赖了，具体就是系别、系主任直接依赖与系编号，而系编号依赖于主键，这时应该通过拆分形成学生表和系别表从而消除传递依赖。 3. 索引索引之于数据库犹如目录之于书籍，在MySQL中，索引在存储引擎层实现，索引可以用于快速查找到特定的记录。索引是存储某列或某几列字段的数据结构，这种数据结构有多种实现方式，如：B树、B+树、哈希表，在MySQL中的默认存储引擎InnoDB默认使用B+树来实现索引。 4. 存储引擎查看当前支持的存储引擎1show engines 更改表使用的存储引擎1ALTER TABLE my_table ENGINE=InnoDB InnoDBMySQL默认的存储引擎就是InnoDB，它具有以下特性： 事务 行级锁 *","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiepuhuan.github.io/categories/MySQL/"}],"tags":[]},{"title":"阻塞队列(Blocking-Queue)","slug":"阻塞队列(Blocking-Queue)","date":"2017-08-17T14:14:18.000Z","updated":"2017-08-17T14:14:18.000Z","comments":true,"path":"2017/08/17/阻塞队列(Blocking-Queue)/","link":"","permalink":"https://xiepuhuan.github.io/2017/08/17/阻塞队列(Blocking-Queue)/","excerpt":"","text":"1. 简介阻塞队列顾名思义本质上是一个先进先出的队列，不过阻塞队列是一个并发的容器，是线程安全的，并且在提供常用的队列获取方法之外还提供了阻塞与超时方法。 2. 实现Queue接口现在来回顾一下队列接口Queue，如下所示： 1234567891011121314public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; //添加元素，成功返回true，失败抛出异常java.lang.IllegalStateException: Queue full boolean add(E e); //添加元素，成功返回true，失败返回false boolean offer(E e); //移除队头元素，成功返回移除元素值，失败抛出异常java.util.NoSuchElementException E remove(); //移除队头元素，成功返回移除元素值，失败返回null E poll(); //获取队头元素，没有抛出异常java.util.NoSuchElementException E element(); //获取队头元素，没有返回null E peek();&#125; BlockingQueue接口而BlockingQueue接口则在Queue的基础上增加了阻塞方法和超时方法： 123456789101112131415161718public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; boolean add(E e); boolean offer(E e); //添加元素，如队列已满则一直阻塞直到添加成功返回，该方法可在阻塞过程中响应中断 void put(E e) throws InterruptedException; //添加元素，如队列已满则一直阻塞直到添加成功或超时返回，该方法可在阻塞过程中响应中断 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; //移除队头元素，如队列为空则一直阻塞直到队列不为空，该方法可在阻塞过程中响应中断 E take() throws InterruptedException; //移除队头元素，如队列为空则一直阻塞直到移除成功或超时返回，该方法可在阻塞过程中响应中断 E poll(long timeout, TimeUnit unit) throws InterruptedException; int remainingCapacity(); boolean remove(Object o); public boolean contains(Object o); //一次性从BlockingQueue获取所有可用的元素存储在集合c中 int drainTo(Collection&lt;? super E&gt; c); int drainTo(Collection&lt;? super E&gt; c, int maxElements);&#125; BlockingQueue的实现类 BlockingQueue的实现 如上图所示，阻塞队列有7个实现： ArrayBlockingQueue ：一个由数组实现的有界阻塞队列。 LinkedBlockingQueue ：一个由链表实现的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个由优先级队列实现的无界延时阻塞队列。 SynchronousQueue：同步队列，一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表实现的无界阻塞队列，具有transfer相关方法。 LinkedBlockingDeque：一个由链表实现的双端阻塞队列。","categories":[{"name":"JDK源码解析","slug":"JDK源码解析","permalink":"https://xiepuhuan.github.io/categories/JDK源码解析/"}],"tags":[]},{"title":"红黑树(Red-Black-Tree)","slug":"红黑树(Red-Black-Tree)","date":"2017-07-07T18:27:23.000Z","updated":"2017-07-07T18:27:23.000Z","comments":true,"path":"2017/07/08/红黑树(Red-Black-Tree)/","link":"","permalink":"https://xiepuhuan.github.io/2017/07/08/红黑树(Red-Black-Tree)/","excerpt":"","text":"1. 简介 红黑树（Red Black Tree） 是一种自平衡二叉查找树，是二叉查找树的变种之一。它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick修改为如今的“红黑树”。 2008年 Robert Sedgewick 对其进行了改进，并命名为 LLRBT(Left-leaning Red Black Tree 左倾红黑树)。左倾红黑树相比1978年的红黑树要简单很多，实现的代码量也少很多。Robert Sedgewick也是Algorithms（中文版叫《算法》）这本书的作者，在这本书中就讲了基于2-3树的左倾红黑树。 现在的使用的工程代码中的红黑树都是基于78年的算法，比如JDK中的TreeMap。其实红黑树就是2-3-4树的具体实现，所以要想理解红黑树就得先理解2-3-4树。而08年左倾红黑树则是基于2-3树。 2. 定义红黑树是2-3-4树的实现，所以在讲红黑树之前想讲下2-3-4树有助于理解红黑树。因为红黑树是一棵自平衡二叉搜索树，通过结点颜色改变和局部旋转来维持平衡，所以除了一些会改变树结构的操作之外，其他的操作都和普通的二叉搜索树相同。因此这里就只讲插入删除操作。因为我要用红黑树实现一个符号表，所以结点需要存储键值对，而且实现的红黑树是基于2-3-4树。 2-3-4树的定义 2-3-4树可以存在三种类型结点。 2-结点是一个结点有2条链接和1个键，其中两条链接对应于二叉搜索树中的左右链接。 3-结点是一个结点有3条链接和2个键。 4-结点是一个结点有4条链接和3个键。 一棵2-3-4树 红黑树的定义 每个结点都有颜色，不是黑色就是红色。 根结点是黑色的。 如果一个空结点都是黑色的。 如果一个结点是红色的，则与它相连的结点都只能是黑色的，也就是不可以有两个红色结点相连。 每个空结点到根结点的简单路径中所含的黑色结点数目相同。 一棵红黑树 通过观察以上两图基本能看出两者的关系了 第一张图已经存在三种结点了，其中1和3都是2-结点，2和4构成一个3-结点，5和6和7构成一个4-结点。 第二张图则是第一张图中2-3-4树在红黑树的表现形式。现在我总结一下2-3-4树中三种结点在红黑树中的表示： 2-结点 2-结点 3-结点 3-结点 3-结点 4-结点 4-结点 3. 实现实现部分的代码用Java 结点的定义每个结点的类型是Node，里面有5个字段。123456789101112131415private class Node &#123; Key key; Value value; Node left; Node right; boolean color; public Node(Key key, Value value, Node left, Node right, boolean color) &#123; this.key = key; this.value = value; this.left = left; this.right = right; this.color = color; &#125; &#125; 红黑树的插入当我们想要在树中插入一个新结点时，先在树中搜索与插入结点键相同的结点。 如果找到该结点则直接修改对应的Value字段就完成了。 如果找不到该结点则创建一个新的结点并把这个新结点设置为红色（因为插入一个红色结点不会改变红黑树的性质5），随后插到对应树底部对应的结点下。然而插入树底部对应结点下，那这个对应的结点有三种可能，分别是上面说到的2-，3-，4-结点。 如果插到2-结点下，由于2-结点是黑色结点则不会破坏红黑树的任何性质，所以不用做任何操作就完成了。 如果插到3-结点下，从上面3-结点的图看，3-结点有三个位置可以插入。 如果插入黑色结点的位置下则变成4-结点也不用做任何操作就完成了。 如果插到3-结点的红色结点下，则破坏了红黑树的性质4。如下图新插入的0003结点，因为插入位置在右边，则需要对0001做一个左旋操作： 如果插入位置在左边，如下图新插入的0002结点。则需要对插入结点的父节点做一个右旋操作，再对0001做一个左旋操作： 先右旋再左旋 无论插到4-结点的哪个地方都会破坏性质4，这时只要将4-结点分解为两个2-结点并将中间结点往上传给父结点。如下图新插入的0004结点： 分解4-结点 红黑树的删除首先要删除一个结点的话，这个结点有两种可能的颜色： 删除一个红色结点不会破坏红黑树的任何性质，可以像删除普通二叉树搜索树结点一样删除 如果删除的是一个黑色结点则会破坏红黑树的性质5，所以我们只要保证删除的结点是红色的就不会破坏红黑树的性质。具体步骤如下：在自顶向下搜索要删除结点过程中，保证当前结点是红色的。如果当前结点不是要删除的结点，在接着再往下搜索时判断下一个结点的颜色，定义下一个结点为左结点，（下个结点为右结点的情况与左结点相反）： 如果下个结点是红色或者为空，则不需要做任何操作 如果下个结点为黑色且下个结点的兄弟结点也是黑色的话，直接将当前结点和两个子结点合并为一个4-结点。 如果下个结点为黑色而下个结点的兄弟结点是红色的话，直接对当前结点做一个左旋操作变成一个4-结点。 当自顶向下删除完结点后，需要向上回溯消除所有破坏红黑树性质4的情况，这一步通过平衡操作来实现。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339import java.util.*;public class RBTree &lt;Key extends Comparable&lt;Key&gt;, Value&gt;&#123; private class Node &#123; Key key; Value value; Node left; Node right; boolean color; public Node(Key key, Value value, Node left, Node right, boolean color) &#123; this.key = key; this.value = value; this.left = left; this.right = right; this.color = color; &#125; &#125; private static final boolean RED = true; private static final boolean BLACK = false; private int size; private Node root; public boolean isEmpty() &#123; return root == null; &#125; private boolean isRed(Node node) &#123; return node != null &amp;&amp; node.color; &#125; //颜色转换 private void flipColors(Node h) &#123; h.color = !h.color; h.left.color = !h.left.color; h.right.color = !h.right.color; &#125; //左旋 private Node rotationLeft(Node node) &#123; Node x = node.right; node.right = x.left; x.left = node; x.color = node.color; node.color = RED; return x; &#125; //右旋 private Node rotationRight(Node node) &#123; Node x = node.left; node.left = x.right; x.right = node; x.color = node.color; node.color = RED; return x; &#125; //平衡操作 private Node balance(Node node) &#123; if (isRed(node.left) &amp;&amp; isRed(node.right) &amp;&amp; !isRed(node)) &#123; if ((isRed(node.left.left) || isRed(node.left.right) || isRed(node.right.left) || isRed(node.right.right))) flipColors(node); &#125; else &#123; if (isRed(node.left))&#123; if (isRed(node.left.right)) node.left = rotationLeft(node.left); if (isRed(node.left) &amp;&amp; isRed(node.left.left)) node = rotationRight(node); &#125;else if (isRed(node.right))&#123; if (isRed(node.right) &amp;&amp; isRed(node.right.left)) node.right = rotationRight(node.right); if (isRed(node.right) &amp;&amp; isRed(node.right.right)) node = rotationLeft(node); &#125; if (isRed(node.left) &amp;&amp; isRed(node.right) &amp;&amp; !isRed(node)) &#123; if ((isRed(node.left.left) || isRed(node.left.right) || isRed(node.right.left) || isRed(node.right.right))) flipColors(node); &#125; &#125; return node; &#125; private Node max(Node node) &#123; if(node == null) &#123; return null; &#125; else &#123; while(node.right != null) &#123; node = node.right; &#125; return node; &#125; &#125; private Node min(Node node) &#123; if(node == null) &#123; return null; &#125; else &#123; while(node.left != null) &#123; node = node.left; &#125; return node; &#125; &#125; public Value max() &#123; return root == null ? null : max(root).value; &#125; public Value min() &#123; return root == null ? null : min(root).value; &#125; //插入 public void put(Key key, Value value) &#123; root = put(key, value, root); root.color = BLACK; &#125; private Node put(Key key, Value value, Node node) &#123; if(node == null) &#123; ++size; return new Node(key, value, null, null, RED); &#125; else &#123; int cmp = key.compareTo(node.key); if(cmp &lt; 0) &#123; node.left = put(key, value, node.left); &#125; else if (cmp &gt; 0)&#123; node.right = put(key, value, node.right); &#125;else&#123; node.value = value; &#125; return balance(node); &#125; &#125; public void deleteMin()&#123; if (!isEmpty())&#123; root.color = RED; root = deleteMin(root); --size; if (!isEmpty()) root.color = BLACK; &#125; &#125; private Node deleteMin(Node node)&#123; if (node.left == null)&#123; return node.right; &#125; if (!isRed(node.left)) &#123; if(!isRed(node.left) &amp;&amp; !isRed(node.right)) flipColors(node); else node = rotationLeft(node); &#125; node.left = deleteMin(node.left); return balance(node); &#125; public void deleteMax()&#123; if (!isEmpty())&#123; root.color = RED; root = deleteMax(root); --size; if (!isEmpty()) root.color = BLACK; &#125; &#125; private Node deleteMax(Node node)&#123; if (node.right == null)&#123; return node.left; &#125; if (!isRed(node.right)) &#123; if(!isRed(node.left) &amp;&amp; !isRed(node.right)) flipColors(node); else node = rotationRight(node); &#125; node.right = deleteMax(node.right); return balance(node); &#125; //删除 public void delete(Key key)&#123; if (!isEmpty())&#123; root.color = RED; root = delete(key, root); if (!isEmpty()) root.color = BLACK; &#125; &#125; private Node delete(Key key, Node node)&#123; if (node == null) return null; int cmp = key.compareTo(node.key); if (cmp &lt; 0)&#123; if (node.left != null &amp;&amp; !isRed(node.left)) &#123; if(!isRed(node.right)) flipColors(node); else node = rotationLeft(node); &#125; node.left = delete(key, node.left); &#125;else if (cmp &gt; 0)&#123; if (node.right != null &amp;&amp; !isRed(node.right)) &#123; if(!isRed(node.left)) flipColors(node); else node = rotationRight(node); &#125; node.right = delete(key, node.right); &#125;else &#123; --size; if (node.left == null) return node.right; if (node.right == null) return node.left; Node x = min(node.right); node.key = x.key; node.value = x.value; node.right = deleteMin(node.right); &#125; return balance(node); &#125; //判断树是否为一棵红黑树 public boolean isRBTree() &#123; return isRBTree(root); &#125; public boolean isRBTree(Node node) &#123; if(node == null) &#123; return true; &#125; else if(node.color == RED) &#123; return false; &#125; else &#123; Node x = node; int count = 0; for(; x != null; x = x.left) &#123; if(x.color == BLACK) &#123; ++count; &#125; &#125; return isRBTree(node, count, 0); &#125; &#125; private boolean isRBTree(Node node, int count, int k) &#123; if(node == null) &#123; return count == k; &#125; else if((isRed(node.left) &amp;&amp; isRed(node.left.left)) ||(isRed(node.left) &amp;&amp; isRed(node.left.right)) ||(isRed(node.right) &amp;&amp; isRed(node.right.right)) ||(isRed(node.right) &amp;&amp; isRed(node.right.left))) &#123; return false; &#125; else &#123; if(node.color == BLACK) &#123; ++k; &#125; return node.left == null &amp;&amp; node.right == null ? k == count:isRBTree(node.left, count, k) &amp;&amp; isRBTree(node.right, count, k); &#125; &#125; //树的中序遍历 public void inTraverse()&#123; inTraverse(root); &#125; private void inTraverse(Node node)&#123; if (node == null) return; inTraverse(node.left); System.out.print(node.key + \" \"); inTraverse(node.right); &#125; //测试 public static void main(String[] args) &#123; int n = 3000, a; Random random = new Random(); RBTree&lt;Integer, String&gt; rbt = new RBTree(); for (int i = 1; i &lt;= n; ++i) &#123; a = random.nextInt(50000); rbt.put(a, \"naoko\"); &#125; for (int i = 0; i &lt; 1500; ++i) &#123; rbt.delete(i); &#125; if (!rbt.isRBTree()) &#123; System.out.println(\"不是红黑树\"); return; &#125; rbt.inTraverse(); System.out.print(\"是红黑树\"); &#125;&#125; 算法复杂度红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持树的平衡，从而获得较高的查找性能。不同的是红黑树并不是向AVL树那样追求完美平衡，而是黑色平衡，即从根结点到任意一个空结点的简单路径上黑色结点数都相同。因为一棵红黑树的高度最高不超过2lg(N+1)，因此其查找时间复杂度也是O(lgN)级别的。而对于插入和删除操作产生不平衡情况都会在3次旋转之内快速解决，所以复杂度基本为O(lgN)级别，也因为这一点红黑树的效率比AVL树快。 最后红黑树的插入和删除操作都有自顶向下和自顶向上两种方法，其中自顶向下较为容易，我的删除操作实现属于自顶向下的方法。在JDK中的TreeMap中插入和删除就用了自底向上的方法。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiepuhuan.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"AVL树","slug":"AVL树","date":"2017-06-06T09:12:32.000Z","updated":"2017-06-06T09:12:32.000Z","comments":true,"path":"2017/06/06/AVL树/","link":"","permalink":"https://xiepuhuan.github.io/2017/06/06/AVL树/","excerpt":"","text":"1. 简介AVL树得名于它的发明者—前苏联的数学家G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。 2. 定义AVL树其实是一棵高度平衡的二叉搜索树，它是依靠平衡因子来维持树的高度。 对于每个结点来说，它的左右子树高度差的绝对值（平衡因子）不会超过1。 它具有和二叉搜索树一样的性质，也就是说除了二叉搜索树中那些会改变树的高度的操作（插入，删除），其他的操作都可以用在AVL树中。 3. 实现因为AVL树除了插入，删除这些可能改变树高度的操作之外，其他操作的与二叉搜索树无异，所以这里只讲插入和删除操作。 每个叶子结点的高度都为1 每个结点都有高度，其高度为左右孩子中最高孩子的高度加上1 每个结点的高度差为左子树的高度减去右子树的高度 每当插入或删除一个结点后，可能导致某个结点的平衡因子超过1，这时候就需要对以这个结点进行旋转操作来维持平衡。 旋转操作：1. 左左旋转： 需要进行左左旋转 如上图，当插入一个0001这个结点后，导致0003的平衡因子超过1，此时0003结点需要通过左左旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的左孩子的左孩子上，取名左左旋转，旋转后的结果如下图： 左左旋转后 代码实现：12345678//左左旋转private Node rotationLeft(Node node)&#123; Node x = node.left; node.left = x.right; x.right = node; updateHeight(node); return x; &#125; 2. 右右旋转： 需要进行右右旋转 如上图，当插入一个0003这个结点后，导致0001的平衡因子超过1，此时0003结点需要通过右右旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的右孩子的右孩子上，取名右右旋转，旋转后的结果如下图： 右右旋转后 代码实现：12345678//右右旋转 private Node rotationRight(Node node)&#123; Node x = node.right; node.right = x.left; x.left = node; updateHeight(node); return x; &#125; 3. 右左旋转： 需要进行右左旋转 如上图，当插入一个0002这个结点后，导致0001的平衡因子超过1，此时0001结点需要通过右左旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的右孩子的左孩子上，取名右左旋转，旋转后的结果如下图： 右左旋转后 代码实现：123456//右左旋转 private Node rotationRightLeft(Node node)&#123; node.right = rotationLeft(node.right); updateHeight(node.right); return rotationRight(node); &#125; 4.左右旋转： image.png 如上图，当插入一个0002这个结点后，导致0003的平衡因子超过1，此时0003结点需要通过左右旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的左孩子的右孩子上，取名左右旋转，旋转后的结果如下图： 左右旋转后 代码实现：123456//左右旋转private Node rotationLeftRight(Node node)&#123; node.left = rotationRight(node.left); updateHeight(node.left); return rotationLeft(node); &#125; 4. 时间复杂度由于AVL树是一个高度平衡的二叉搜索树，所以树的高度几乎是lgN，所以无论查找，插入还是删除操作最坏情况的时间复杂度为O(lgN)。 5. 代码实现其中的插入删除操作都是用递归来实现的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226import java.util.*;public class AVL &lt;Key extends Comparable&lt;Key&gt;, Value&gt;&#123; private class Node&#123; Key key; Value value; int height; Node left; Node right; public Node(Key key, Value value, int height, Node left, Node right)&#123; this.key = key; this.value = value; this.height = height; this.left = left; this.right = right; &#125; &#125; private Node root; private int size; public int size()&#123; return size; &#125; //获取树高度 public int height(Node node)&#123; return node == null ? 0 : node.height; &#125; //高度差 private int altitude(Node node)&#123; return height(node.left) - height(node.right); &#125; //更新树高度 private void updateHeight(Node node)&#123; node.height = Math.max(height(node.left), height(node.right)) + 1; &#125; //右旋 private Node rotationRight(Node node)&#123; Node x = node.right; node.right = x.left; x.left = node; updateHeight(node); return x; &#125; //左旋 private Node rotationLeft(Node node)&#123; Node x = node.left; node.left = x.right; x.right = node; updateHeight(node); return x; &#125; //左右旋转 private Node rotationLeftRight(Node node)&#123; node.left = rotationRight(node.left); updateHeight(node.left); return rotationLeft(node); &#125; //右左旋转 private Node rotationRightLeft(Node node)&#123; node.right = rotationLeft(node.right); updateHeight(node.right); return rotationRight(node); &#125; //平衡 private Node balance(Node node, int altitude)&#123; if (altitude == 2) node = height(node.left.left) &gt; height(node.left.right) ? rotationLeft(node) : rotationLeftRight(node); else if (altitude == -2) node = height(node.right.left) &gt; height(node.right.right) ? rotationRightLeft(node) : rotationRight(node); updateHeight(node); return node; &#125; //插入 public void put(Key key, Value value)&#123; root = put(key, value, root); ++size; &#125; private Node put(Key key, Value value, Node node) &#123; if (node == null) return new Node(key, value, 1, null, null); int cmp = key.compareTo(node.key); if (cmp &lt; 0) node.left = put(key, value, node.left); else if (cmp &gt; 0) node.right = put(key, value, node.right); else &#123; node.value = value; return node; &#125; return balance(node, altitude(node)); &#125; private Node max(Node node)&#123; if (node == null) return null; while (node.right != null) node = node.right; return node; &#125; public Value max() &#123; return root == null ? null : max(root).value; &#125; public void deleteMax()&#123; if (root != null) &#123; root = deleteMax(root); --size; &#125; &#125; private Node deleteMax(Node node)&#123; if (node.right == null) return node.left; node.right = deleteMax(node.right); return balance(node, altitude(node));&#125; private Node deleteMin(Node node)&#123; if (node.left == null) return node.right; node.left = deleteMin(node.left); return balance(node, altitude(node)); &#125; public void deleteMin()&#123; if (root != null) &#123; root = deleteMin(root); --size; &#125; &#125; public Value delete(Key key)&#123; Node node = delete(key, root); if (node != null) return node.value; return null; &#125; private Node delete(Key key, Node node)&#123; if (node == null) return null; int cmp = key.compareTo(node.key); if (cmp &lt; 0) node.left = delete(key, node.left); else if (cmp &gt; 0) node.right = delete(key, node.right); else &#123; --size; if (node.left == null) return node.right; if (node.right == null) return node.left; Node x = max(node.right); node.key = x.key; node.value = x.value; node.right = deleteMax(node.right); &#125; return balance(node, altitude(node)); &#125; //中序遍历 private void inorderTraverse(Node node, Set&lt;Key&gt; keySet)&#123; if (node == null) return; inorderTraverse(node.left, keySet); keySet.add(node.key); inorderTraverse(node.right, keySet); &#125; //返回一个把键从小到大排序的迭代器 public Iterable&lt;Key&gt; keySet()&#123; Set&lt;Key&gt; keySet = new TreeSet&lt;&gt;(); inorderTraverse(root, keySet); return keySet; &#125; public static void main(String[] args)&#123; AVL&lt;Integer, String&gt; tree = new AVL&lt;&gt;(); Random random = new Random(); for (int i = 0; i &lt; 500; ++i) tree.put(random.nextInt(), \"naoko\" + i); tree.deleteMax(); tree.deleteMin(); for (int i : tree.keySet()) System.out.println(i); System.out.println(\"符号表的大小：\" + tree.size()); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiepuhuan.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"二叉搜索树(Binary-Search-Tree)","slug":"二叉搜索树(Binary-Search-Tree)","date":"2017-06-05T08:50:57.000Z","updated":"2017-06-05T08:50:57.000Z","comments":true,"path":"2017/06/05/二叉搜索树(Binary-Search-Tree)/","link":"","permalink":"https://xiepuhuan.github.io/2017/06/05/二叉搜索树(Binary-Search-Tree)/","excerpt":"","text":"1. 定义二叉搜索树(BST)又叫二叉查找树，二叉排序树。二叉搜索树就是一棵二叉树，但是它又具有搜索树的特征： 每个结点都比它的左结点大，比右结点小。 每个结点的左右子树都是一课二叉搜索树。 对一棵二叉搜索树进行中序遍历结果是从小到大排序的结果。 2. 时间复杂度二叉搜索树结合了链表插入删除的灵活性和数组的查找的高效性。 最好情况：最好情况下的二叉搜索树是一棵满二叉树，这时从根结点到所有叶子结点的长度都为lgN，对应树的高度也为lgN。此时无论查找，插入，删除都可以在O(lgN)时间内完成。 最坏情况：最坏情况下的二叉搜索树的每个结点只有一个孩子，几乎是链表的形状了，对应树的高度为N。此时查找，插入，删除的时间复杂度为O(N)。 平均情况：二叉搜索树的平均情况应该是介于最好和最好情况之间。 3. 实现接下来我用二叉搜索树来实现一个符号表，符号表就是一个存储键值对的数据结构，其中键不可以重复，值可以重复。定义了如下操作： put(Key key, Value value) 将键key和值value插入符号表 delete(Key key) 删除指定的键值对 get(Key key) 获取键对应的值，如果不存在该键则返回null deleteMax() 删除最大的键对应的键值对 deleteMin() 删除最小的键对应的键值对 min() 获取最小的键 max() 获取最大的键 size() 获取符号表的大小 isEmpty() 判断符号表否为空 代码用java描述，使用了泛型。因为需要进行比较操作，所以键都必须实现Comparable接口。在BST这个类中，使用了一个内部类Node来表示二叉搜索树的结点，同时也是一个键值对。所有操作都是采用迭代的方式。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private class Node &#123; Key key; Value value; Node left; Node right; public Node(Key key, Value value, Node left, Node right)&#123; this.key = key; this.value = value; this.left = left; this.right = right; &#125; &#125; private Node root; private int size; public int size()&#123; return size; &#125; public boolean isEmpty()&#123; return root == null; &#125; public Value get(Key key)&#123; Node node = root; int cmp; while(node != null)&#123; cmp = key.compareTo(node.key); if (cmp &lt; 0) node = node.left; else if (cmp &gt; 0) node = node.right; else return node.value; &#125; return null; &#125; public void put(Key key, Value value)&#123; if (root == null) &#123; root = new Node(key, value, null, null); size = 1; return; &#125; Node node = root; Node parent = null; int cmp; while (node != null)&#123; parent = node; cmp = key.compareTo(node.key); if (cmp &lt; 0) node = node.left; else if (cmp &gt; 0) node = node.right; else &#123; node.value = value; return; &#125; &#125; if (key.compareTo(parent.key) &lt; 0) parent.left = new Node(key, value, null, null); else parent.right = new Node(key, value, null, null); ++size; &#125; private Node max(Node node)&#123; if (node == null) return null; while (node.right != null) node = node.right; return node; &#125; private Node min(Node node)&#123; if (node == null) return null; while (node.left != null) node = node.left; return node; &#125; public Key max()&#123; Node node = max(root); return node == null ? null : node.key; &#125; public Key min()&#123; Node node = min(root); return node == null ? null : node.key; &#125; private Node deleteMax(Node node) &#123; Node x = node; if (node == null) return null; Node parent = null; while (node.right != null)&#123; parent = node; node = node.right; &#125; --size; if (parent == null) return node.left; else parent.right = node.left; return x; &#125; private Node deleteMin(Node node) &#123; Node x = node; if (node == null) return null; Node parent = null; while (node.left != null)&#123; parent = node; node = node.left; &#125; --size; if (parent == null) return node.right; else parent.left = node.right; return x; &#125; public void deleteMax()&#123; root = deleteMax(root); &#125; public void deleteMin()&#123; root = deleteMin(root); &#125; public void traverse()&#123; traverse(root); &#125; //中序遍历 private void traverse(Node node)&#123; if (node == null) return; traverse(node.left); System.out.println(node.key); traverse(node.right); &#125; public void delete(Key key) &#123; if (root == null) return; Node node = root; Node parent = root; int cmp; while (node != null)&#123; cmp = key.compareTo(node.key); if (cmp == 0) &#123; --size; cmp = key.compareTo(parent.key); if (node.left == null)&#123; if (cmp &lt; 0) parent.left = node.right; else if (cmp &gt; 0) parent.right = node.right; else root = node.right; return; &#125; if (node.right == null)&#123; if (cmp &lt; 0) parent.left = node.left; else if (cmp &gt; 0) parent.right = node.left; else root = node.left; return; &#125; Node x = min(node.right); node.key = x.key; node.value = x.value; node.right = deleteMax(node.right); &#125; else &#123; parent = node; if (cmp &lt; 0) node = node.left; else node = node.right; &#125; &#125; &#125; public static void main(String[] args)&#123; BST&lt;Integer, String&gt; bst = new BST&lt;&gt;(); bst.put(2, \"qw\"); bst.put(3, \"fy\"); bst.put(5, \"naoko\"); bst.put(1, \"qw\"); bst.put(4, \"naoko\"); bst.put(-3, \"naoko\"); bst.deleteMax(); bst.deleteMin(); bst.delete(10); bst.traverse(); &#125;&#125; 4. 最后二叉搜索树虽然简单但在最坏情况下表现得并不好。不过它是其他树类型的数据结构的基础，二叉搜索树还有其他变种如AVL树，红黑树，Treap树等。在C++，Java的集合API中，符号表或是Set的实现一般都是用红黑树。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiepuhuan.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"快速排序(Quick-Sort)","slug":"快速排序(Quick-Sort)","date":"2017-05-30T10:29:06.000Z","updated":"2017-05-30T10:29:06.000Z","comments":true,"path":"2017/05/30/快速排序(Quick-Sort)/","link":"","permalink":"https://xiepuhuan.github.io/2017/05/30/快速排序(Quick-Sort)/","excerpt":"","text":"1. 简介快速排序是由C.A.R.Hoare在1960年发明的。快速排序可能是应用最广泛的排序算法了，快速排序的实现简单，平均时间复杂度是O(NlgN)，而且它是原地排序。其实在快排的实现有一些坑，如果不仔细一点，快排也许就变成慢排了。接下来所讲的排序都是从小到大排序的，代码也是java描述的： 与归并排序一样，快速排序也采用了分而治之的思想。 在数组中选取一个元素作为主元 将数组切分成左右两半，左边一半的元素小于等于主元，右边一半的元素大于等于主元 将左边排序 将右边排序 因为左边已经小于等于右边了，所以当左右两边都排完序，整体也就有序了 2. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class QuickSort &#123; //交换数组中两个元素的位置 private static void swap(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; //切分数组的函数 private static int partition(Comparable[] a, int left, int right)&#123; swap(a, (left + right) / 2, left); Comparable v = a[left]; //v是主元 int i = left, j = right + 1; while (true) &#123; while (a[++i].compareTo(v) &lt; 0) if (i == right) break; while (a[--j].compareTo(v) &gt; 0) if (j == left) break; if (i &lt; j) swap(a, i, j); else break; &#125; swap(a, j, left); return j; &#125; private static void sort(Comparable[] a, int left, int right)&#123; if (left &gt;= right) return; int i = partition(a, left, right); //切分数组，返回切分的位置，也就是主元的位置 sort(a, left, i - 1); //对数组的左半边排序 sort(a, i + 1, right); //对数组的右半边排序 &#125; public static void sort(Comparable[] a)&#123; sort(a, 0, a.length - 1); &#125; //测试 public static void main(String[] args) &#123; Integer[] a = new Integer[]&#123;1, 3, 4, 7, 9, 2&#125;; sort(a); &#125;&#125; 辅助函数：这一段是快速排序的简单实现，还有一些可以优化的地方。先来介绍一下实现过程需要用的辅助函数： 因为排序过程中需要与主元进行比较且参与排序的元素是类变量，所以要求排序的元素需要实现Comparable接口重写compareTo()函数。 在与主元比较后可能需要交换位置所以用一个swap()函数交换两个元素的位置。 3. 快速排序性能与复杂度分析快速排序的运行时间取决于切分是否平衡，而是否平衡又依赖于切分的元素，也就是主元的选择。 最坏情况假设我们每次选择的主元恰好是待排数组中的极值且元素都不重复时，例如最小值：根据切分函数，指针i在遇到第一个元素就停下来，而j却一直向左遍历直到遇到主元才停下来。最终切分的位置变成了left，切分出一个大小为0的数组和一个大小为n - 1的数组，不烦假设每次都出现这种不平等的切分，切分的操作时间复杂度为O(n)，对一个大小为0的数组递归调用排序会直接返回，因此T(0) = O(1)。于是算法的运行时间的递归式可表达为：T(n) = T(0) + T(n - 1) + O(n) = T(n - 1) + O(n)，T(n)的解是O(n^2)。 最好情况最好的情况是每次切分后的两个数组大小都不大于n / 2时，这时一个的数组的大小为[n / 2 - 1]，另一个为[n / 2]，此时算法运行时间的递归式为：T(n) = 2T(n / 2) + O(n)，T(n)的解是O(nlgn)。 平均情况快速排序的平均运行时间其实更接近与最好情况，而非最坏情况。 4. 算法优化 1. 切换到插入排序 对于小数组，快速排序比插入排序慢 因为递归，快速排序的sort()方法在小数组中也会调用自己 所以可以当数组在大小在M以内时调用插入排序，M的取值可以是5 ~ 15。 2. 选择合适的主元如我上面所说，假设我们每次选择的主元恰好是待排数组中的极值时，那就是最坏的情况，如果要避免这种情况的发生，那就是要选择合适的主元。我们可以在待排数组取左，中，右3个数，取其中位数作为主元。这样就可以在一定程度上避免最坏情况。 3. 重复的元素不必排序当数组中存在大量的重复元素时，如果我们用上面所实现的快排，时间复杂度还是要O(nlgn)，这开销是在太大相对于插入排序来说。这时我们可以采用三向切分来实现快排。如下所示： left part center part right part * +--------------------------------------------------------------+ * | &lt; pivot | ==pivot | ? | &gt; pivot | * +--------------------------------------------------------------+ * ^ ^ ^ * | | | * lt i gt 通过维持三个指针来控制[left, lt )小于主元(pivot)，[lt, i)等于主元，[i, gt]未知，(gt, right]大于主元。一开始，lt指向主元的位置left，gt指向right，而i从left右边接下来的第一个索引开始遍历，每当遇到一个数，就判断它与主元之间的大小关系，有三种情况： 小于主元就把这个数与lt指向的数交换，然后lt,i都自增1，然后继续遍历 大于主元就把这个数与gt指向的数交换，gt自减1，此时i还得不能自增，因为它不知道gt用一个什么样的元素跟它交换，所以留到下一次循环判断交换过来的这个元素的去留 等于主元就不用跟谁进行交换，直接自增1就可以 三向切分快速排序如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Quick &#123; //获取中位数 private static int getMedian(Comparable[] a, int i, int j, int k)&#123; return a[i].compareTo(a[j]) &gt; 0 ? (a[i].compareTo(a[k]) &lt; 0 ? i : a[j].compareTo(a[k]) &gt; 0 ? j : k) : (a[i].compareTo(a[k]) &gt; 0 ? i : a[j].compareTo(a[k]) &lt; 0 ? j : k); &#125; private static void swap(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; //插入排序 private static void insertSort(Comparable[] a, int left, int right) &#123; for (int i = left; i &lt;= right; ++i) &#123; int j; Comparable value = a[i]; for (j = i - 1; j &gt;= left &amp;&amp; value.compareTo(a[j]) &lt; 0; --j) a[j + 1] = a[j]; a[j + 1] = value; &#125; &#125; private static void sort(Comparable[] a, int left, int right)&#123; if (right - left &lt; 15) &#123; insertSort(a, left, right); return; &#125; swap(a, getMedian(a, left, (left + right) / 2, right), left); Comparable v = a[left]; int lt = left, i = left + 1, gt = right; while (i &lt;= gt)&#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) swap(a, lt++, i++); else if (cmp &gt; 0) swap(a, i, gt--); else i++; &#125; sort(a, left, lt - 1); sort(a, gt + 1, right); &#125; public static void sort(Comparable[] a)&#123; sort(a, 0, a.length - 1); &#125;//测试 public static void main(String[] args) &#123; int size = 10000000; Integer[] a = new Integer[size]; for (int i = 0; i &lt; 10000000; ++i) a[i] = 88; sort(a); &#125;&#125; 5. 注意：目前所实现的三向切分并不完美，虽然它解决了大量重复元素的不必要排序，将排序时间从线性对数级别降到线性级别，但它在数组元素重复不多的情况下，它的交换次数比标准的二分法多很多。不过在90年代J.Bently和D.Mcllroy找到一个聪明的办法解决了这个问题。接下来的快速三向切分就是解决办法。 快速的三向切分 * left part center part right part * +----------------------------------------------------------+ * | == pivot | &lt; pivot | ? | &gt; pivot | == pivot | * +----------------------------------------------------------+ * ^ ^ ^ ^ * | | | | * p i j q 在这个算法中，[p, i)里面的元素小于主元，(j, q]里面的元素大于主元，而左右两端[left, p)和(q, right]等于主元。在算法一开始，p 和 i都指向left后面的第一个元素， j和q都指向right，先把i从左到右遍历时每遇到一个元素都会有三种情况： 等于主元，这时只要与p指向的元素交换然后各自自增1即可 小于主元，这就是指针p和i所要维护的元素，直接把i自增1跳过就可以 大于主元，这时就是j和q所要维护的元素，先退出循环等待与他们交换 同理，对于j从right向左遍历也是一样。当 i &gt; j 时，切分也就结束，最后还要把数组调整为左边小右边大，中间等于主元的形式，再依次排序左边和右边。在这个算法中，既解决了重复元素排序的问题，又解决了少量元素重复时，交换次数过多的问题。接下来是我的实现，不过我觉得我有些地方实现的不太好，凑合着用吧。 快速的三向切分的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class Quick3WayPartitionSort &#123; //获取中位数 private static int getMedian(Comparable[] a, int i, int j, int k)&#123; return a[i].compareTo(a[j]) &gt; 0 ? (a[i].compareTo(a[k]) &lt; 0 ? i : a[j].compareTo(a[k]) &gt; 0 ? j : k) : (a[i].compareTo(a[k]) &gt; 0 ? i : a[j].compareTo(a[k]) &lt; 0 ? j : k); &#125; private static void swap(Comparable[] a, int i, int j)&#123; Comparable t = a[i]; a[i] = a[j]; a[j] = t; &#125; public static void insertSort(Comparable[] a, int left, int right) &#123; for (int i = left; i &lt;= right; ++i) &#123; int j; Comparable value = a[i]; for (j = i - 1; j &gt;= left &amp;&amp; value.compareTo(a[j]) &lt; 0; --j) a[j + 1] = a[j]; a[j + 1] = value; &#125; &#125; //调整数组 private static void adjust(Comparable[] a, int start, int end, int toStart)&#123; for (int i = start; i &lt;= end; ++i) swap(a, i, toStart++); &#125; public static void sort(Comparable[] a)&#123; temps = new Comparable[a.length]; sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int left, int right)&#123; if (right - left &lt; 10) &#123; insertSort(a, left, right); return; &#125; swap(a, getMedian(a, left, (left + right) / 2, right), left); Comparable v = a[left]; int p = left + 1, i = p, j = right, q = j; while (true)&#123; while (i &lt;= j)&#123; int cmp = a[i].compareTo(v); if (cmp == 0) swap(a, i++, p++); else if (cmp &lt; 0) i++; else break; &#125; while (i &lt;= j)&#123; int cmp = a[j].compareTo(v); if (cmp == 0) swap(a, j--, q--); else if (cmp &gt; 0) j--; else break; &#125; if (i &lt; j) swap(a, i++, j--); else break; &#125; if (p - left &gt; i - p) adjust(a, p, i - 1, left); else adjust(a, left, p - 1, left + i - p); if (right - q &gt; q - j) adjust(a, j + 1, q, right - q + j); else adjust(a, q + 1, right, j + 1); sort(a, left, left + i - p - 1); sort(a, right + j - q - 1, right); &#125; public static void main(String[] args) &#123; &#125;&#125; 6. 最后快速排序不是稳定的排序算法，所谓稳定就是当待排数组中存在重复元素的时候，排序后重复元素的相对顺序不会改变。在多关键字排序时，稳定的排序算法就很有用处。比如当一个学生按照学号先排序，然后再根据成绩进行排序，因为成绩存在重复的值，此时稳定的排序算法就会导致排序后具有相同成绩的学生按照学号排序，不会混乱。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://xiepuhuan.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"DDL","slug":"DDL","date":"2017-05-22T08:11:27.000Z","updated":"2017-05-22T08:11:27.000Z","comments":true,"path":"2017/05/22/DDL/","link":"","permalink":"https://xiepuhuan.github.io/2017/05/22/DDL/","excerpt":"","text":"DDL主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或修改表的结构，数据类型，表之间的链接和约束等工作上，他们大多在建立表时使用。 #一、数据库操作 1. 查看数据库 show databases; 2. 新建数据库 CREATE DATABASE &lt;数据库名&gt;; 3. 连接数据库 use &lt;数据库名&gt;; 4. 查看数据库中的表 show tables; 5. 删除数据库 DROP DATABASE 数据库名; #二、数据表操作 ##1. 创建数据表 ####1.1创建表的语法格式 CREATE TABLE 要创建的表名字 ( 字段名1 数据类型(字段大小) [约束条件] , 字段名2 数据类型(字段大小) [约束条件] ); ####1.2主键约束(PRIMARY KEY CONSTRAINT)主键能够唯一的标识表中的一行记录，因此主键不能有重复且不能为空。主键又分单字段主键和复合主键两种类型。 单字段主键可以在定义列时一起指定 字段名 数据类型(字段大小) PRIMARY KEY 也可以在定义完所有列后指定 [CONSTRAINT &lt;约束名&gt;] PRIMARY KEY 字段名 复合主键 [CONSTRAINT &lt;约束名&gt;] PRIMARY KEY(字段1,字段2) ####1.3外键约束(FOREIGN KEY CONSTRAINT) 外键用来在两个表的数据之间建立连接，对应的是参照完整性。外键必须是另一个表的主键，和主键一样它可以是一列或多列，不过与主键不一样的是：一个表可以有多个外键。主表名是外键所依赖的表的名字。 [CONSTRAINT &lt;约束名&gt;] FOREIGN KEY(字段1, 字段2) REFERENCES 主表名(字段1, 字段2) ####1.4非空约束(NOT NULL CONSTRAINT) 非空约束是指该列的值不能为空，在插入一条记录时如果没有给定值，数据库系统就会报错。 字段名 数据类型 NOT NULL ####1.5唯一性约束(UNIQUE CONSTRAINT) 唯一性约束是指该列的值不允许重复，允许一个空值。 字段名 数据类型 UNIQUE ####1.6默认约束(DEFAULT CONSTRAINT)默认约束是指该列有默认值，在插入一条记录时，如果没有指定该字段的值，则自动为该字段赋默认值。 字段名 数据类型 DEFAULT 默认值 ####1.7设置属性值自动增加 这个功能的意思就是每插入一条新记录时自动生成字段的主键值。可以通过为主键设置AUTO_INCREMENT关键字来实现。它初始化为1，每添加一条记录，就会增加1。一个表只能为一个字段添加AUTO_INCREMENT，且该字段必须是主键或为主键的一部分。 字段名 数据类型 AUTO_INCREMENT ##2.查看数据表结构 ####2.1查看表基本结构 DESCRIBE/DESC语句可以查看表的字段信息，包括：字段名，数据类型，约束条件等。 DESCRIBE 表名或DESC 表名 ####2.2查看表详细结构 SHOW CREATE TABLE语句可以查看创建表时的建表语句，存储引擎，字符编码等 SHOW CREATE TABLE 表名\\G \\G可加可不加，加的话显示效果会更加直观。 ##3.修改数据表 ####3.1修改表名 ALTER TABLE 原表名 RENAME [TO] 新表名;RENAME TABLE 原表名 TO 新表名; ####3.2修改字段数据类型 ALTER TABLE 表名 MODIFY 字段名 数据类型; ####3.3修改字段名 ALTER TABLE 表名 CHANGE 原字段名 新字段名 新数据类型; 注：如果不想改变数据类型，可以设置跟原来一样，但不能为空。 ####3.4添加新字段 一个新字段需要字段名，数据类型，完整性约束。FIRST作用是将字段设置为表中第一个字段，AFTER是把新添加的字段放在指定的字段名后面 ALTER TABLE 表名 ADD 新字段 数据类型 [约束条件] [FIRST | AFTER 字段名]; ####3.5删除字段 ALTER TABLE 表名 DROP 字段名; ####3.6修改字段的位置 ALTER TABLE 表名 MODIFY 字段 数据类型 FIRST;ALTER TABLE 表名 MODIFY 字段 数据类型 AFTER 字段名; ####3.7更改表的存储引擎 我们可以为每张表选用不同的存储引擎。 查看MySQL支持的存储引擎 SHOW ENGINES; 更改表的存储引擎 ALTER TABLE 表名 ENGINE=新的存储引擎名 ####3.8删除表的外键约束 外键约束一旦删除，就会解除主从表之间的关系。 ALTER TABLE 表名 DROP FOREIGN KEY 外键约束名; ####3.9修改表中某个值 大多数时候我们需要做的修改是表中的某一个或几个数据，这就需要我们用下面这条命令达到精确的修改 UPDATE 表名字 SET 列1=值1,列2=值2 WHERE 条件; ####3.10删除一行记录 DELETE FROM 表名字 WHERE 条件; ##4. 删除数据表 ####4.1删除没有被关联的表在MySQL中，我们可以使用DROP TABLE语句一次删除一张或多张没有被其他表关联（主键被其他表设置为外键）的数据表。 DROP TABLE [IF EXISTS] 表1,表2,……表n; ####4.2删除被其他表关联的表 当要删除的表被其他表所关联的话，直接删除会报错，但有两个办法： 先删除与之关联的子表，再删除被关联的父表。 将与之关联的子表的外键约束解除，就可以只删除父表。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://xiepuhuan.github.io/categories/MySQL/"}],"tags":[]}]}