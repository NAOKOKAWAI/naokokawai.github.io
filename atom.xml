<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>谢朴欢</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xiepuhuan.github.io/"/>
  <updated>2017-08-25T08:11:27.000Z</updated>
  <id>https://xiepuhuan.github.io/</id>
  
  <author>
    <name>谢朴欢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DDL</title>
    <link href="https://xiepuhuan.github.io/2017/08/25/DDL/"/>
    <id>https://xiepuhuan.github.io/2017/08/25/DDL/</id>
    <published>2017-08-25T08:11:27.000Z</published>
    <updated>2017-08-25T08:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>DDL主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或修改表的结构，数据类型，表之间的链接和约束等工作上，他们大多在建立表时使用。</p><p>#一、数据库操作</p><p><strong>1. 查看数据库</strong></p><blockquote><p>show databases;</p></blockquote><p><strong>2. 新建数据库</strong></p><blockquote><p>CREATE DATABASE &lt;数据库名&gt;;</p></blockquote><p><strong>3. 连接数据库</strong></p><blockquote><p>use &lt;数据库名&gt;;</p></blockquote><p><strong>4. 查看数据库中的表</strong></p><blockquote><p>show tables;</p></blockquote><p><strong>5. 删除数据库</strong></p><blockquote><p>DROP DATABASE 数据库名;</p></blockquote><p>#二、数据表操作</p><p>##1. 创建数据表</p><p>####1.1创建表的语法格式</p><blockquote><p>CREATE TABLE 要创建的表名字</p></blockquote><blockquote><p>(</p></blockquote><blockquote><p>字段名1 数据类型(字段大小) [约束条件] ,</p></blockquote><blockquote><p>字段名2 数据类型(字段大小) [约束条件] </p></blockquote><blockquote><p>);</p></blockquote><p>####1.2主键约束(PRIMARY KEY CONSTRAINT)<br>主键能够唯一的标识表中的一行记录，因此主键不能有重复且不能为空。主键又分单字段主键和复合主键两种类型。</p><p><strong>单字段主键</strong><br>可以在定义列时一起指定</p><blockquote><p>字段名 数据类型(字段大小)  PRIMARY KEY </p></blockquote><p>也可以在定义完所有列后指定</p><blockquote><p>[CONSTRAINT  &lt;约束名&gt;]   PRIMARY KEY 字段名</p></blockquote><p><strong>复合主键</strong></p><blockquote><p>[CONSTRAINT  &lt;约束名&gt;]  PRIMARY KEY(字段1,字段2)</p></blockquote><p>####1.3外键约束(FOREIGN KEY CONSTRAINT)</p><p>外键用来在两个表的数据之间建立连接，对应的是参照完整性。外键必须是另一个表的主键，和主键一样它可以是一列或多列，不过与主键不一样的是：一个表可以有多个外键。主表名是外键所依赖的表的名字。</p><blockquote><p>[CONSTRAINT  &lt;约束名&gt;]  FOREIGN KEY(字段1, 字段2) REFERENCES 主表名(字段1, 字段2)</p></blockquote><p>####1.4非空约束(NOT NULL CONSTRAINT)</p><p>非空约束是指该列的值不能为空，在插入一条记录时如果没有给定值，数据库系统就会报错。</p><blockquote><p>字段名 数据类型 NOT NULL</p></blockquote><p>####1.5唯一性约束(UNIQUE CONSTRAINT)</p><p>唯一性约束是指该列的值不允许重复，允许一个空值。</p><blockquote><p>字段名 数据类型 UNIQUE</p></blockquote><p>####1.6默认约束(DEFAULT CONSTRAINT)<br>默认约束是指该列有默认值，在插入一条记录时，如果没有指定该字段的值，则自动为该字段赋默认值。</p><blockquote><p>字段名 数据类型 DEFAULT 默认值</p></blockquote><p>####1.7设置属性值自动增加</p><p>这个功能的意思就是每插入一条新记录时自动生成字段的主键值。可以通过为主键设置AUTO_INCREMENT关键字来实现。它初始化为1，每添加一条记录，就会增加1。一个表只能为一个字段添加AUTO_INCREMENT，且该字段必须是主键或为主键的一部分。</p><blockquote><p>字段名 数据类型 AUTO_INCREMENT</p></blockquote><p>##2.查看数据表结构</p><p>####2.1查看表基本结构</p><p>DESCRIBE/DESC语句可以查看表的字段信息，包括：字段名，数据类型，约束条件等。</p><blockquote><p>DESCRIBE 表名<br>或<br>DESC 表名</p></blockquote><p>####2.2查看表详细结构</p><p>SHOW CREATE TABLE语句可以查看创建表时的建表语句，存储引擎，字符编码等</p><blockquote><p>SHOW CREATE TABLE 表名\G</p></blockquote><p>\G可加可不加，加的话显示效果会更加直观。</p><p>##3.修改数据表</p><p>####3.1修改表名</p><blockquote><p>ALTER TABLE 原表名  RENAME [TO]  新表名;<br>RENAME TABLE  原表名  TO  新表名;</p></blockquote><p>####3.2修改字段数据类型</p><blockquote><p>ALTER TABLE 表名  MODIFY  字段名  数据类型;</p></blockquote><p>####3.3修改字段名</p><blockquote><p>ALTER TABLE  表名  CHANGE  原字段名  新字段名  新数据类型;</p></blockquote><p><strong>注：如果不想改变数据类型，可以设置跟原来一样，但不能为空。</strong></p><p>####3.4添加新字段</p><p>一个新字段需要字段名，数据类型，完整性约束。FIRST作用是将字段设置为表中第一个字段，AFTER是把新添加的字段放在指定的字段名后面</p><blockquote><p>ALTER TABLE 表名  ADD 新字段 数据类型 [约束条件]  [FIRST | AFTER  字段名];</p></blockquote><p>####3.5删除字段</p><blockquote><p>ALTER TABLE  表名  DROP  字段名;</p></blockquote><p>####3.6修改字段的位置</p><blockquote><p>ALTER TABLE  表名  MODIFY  字段 数据类型  FIRST;<br>ALTER TABLE  表名  MODIFY  字段 数据类型  AFTER 字段名;</p></blockquote><p>####3.7更改表的存储引擎</p><p>我们可以为每张表选用不同的存储引擎。</p><p>查看MySQL支持的存储引擎</p><blockquote><p>SHOW ENGINES;</p></blockquote><p>更改表的存储引擎</p><blockquote><p>ALTER TABLE 表名  ENGINE=新的存储引擎名</p></blockquote><p>####3.8删除表的外键约束</p><p>外键约束一旦删除，就会解除主从表之间的关系。</p><blockquote><p>ALTER TABLE  表名  DROP FOREIGN KEY  外键约束名;</p></blockquote><p>####3.9修改表中某个值</p><p>大多数时候我们需要做的修改是表中的某一个或几个数据，这就需要我们用下面这条命令达到精确的修改</p><blockquote><p>UPDATE  表名字  SET  列1=值1,列2=值2  WHERE  条件;</p></blockquote><p>####3.10删除一行记录</p><blockquote><p>DELETE  FROM  表名字  WHERE  条件;</p></blockquote><p>##4. 删除数据表</p><p>####4.1删除没有被关联的表<br>在MySQL中，我们可以使用DROP TABLE语句一次删除一张或多张没有被其他表关联（主键被其他表设置为外键）的数据表。</p><blockquote><p>DROP TABLE [IF EXISTS]  表1,表2,……表n;</p></blockquote><p>####4.2删除被其他表关联的表</p><p>当要删除的表被其他表所关联的话，直接删除会报错，但有两个办法：</p><ol><li><p>先删除与之关联的子表，再删除被关联的父表。</p></li><li><p>将与之关联的子表的外键约束解除，就可以只删除父表。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;DDL主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或修改表的结构，数据类型，表之间的链接和约束等工作上，他们大多在建立表时使用。&lt;/p&gt;
&lt;p&gt;#一、数据库操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 查看数据库&lt;/strong&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://xiepuhuan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Internet控制报文协议(ICMP)</title>
    <link href="https://xiepuhuan.github.io/2017/08/25/Internet%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE(ICMP)/"/>
    <id>https://xiepuhuan.github.io/2017/08/25/Internet控制报文协议(ICMP)/</id>
    <published>2017-08-25T04:50:23.000Z</published>
    <updated>2017-08-25T04:50:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>IP协议本身没有为终端提供直接的方法来发现那些发往目的地址失败的IP数据包、相关的诊断信息等。为了解决这些问题，<strong>Internet控制报文协议</strong>(Internet Control Message Protocol，ICMP)出现了，ICMP被主机和路由器用来沟通网络层信息。ICMP既不是网络层协议，也不是传输层协议，而是介于两者之间。</p><h1 id="2-ICMP报文格式"><a href="#2-ICMP报文格式" class="headerlink" title="2. ICMP报文格式"></a>2. ICMP报文格式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-9470b6d561460057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ICMP报文格式" title="">                </div>                <div class="image-caption">ICMP报文格式</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;IP协议本身没有为终端提供直接的方法来发现那些发往目的地址失败的IP数据包、相关的诊断信息等。为了解决这些问题，&lt;str
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://xiepuhuan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://xiepuhuan.github.io/2017/08/25/AVL%E6%A0%91/"/>
    <id>https://xiepuhuan.github.io/2017/08/25/AVL树/</id>
    <published>2017-08-24T19:37:32.000Z</published>
    <updated>2017-08-24T19:37:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>AVL树得名于它的发明者—前苏联的数学家<strong>G.M. Adelson-Velsky</strong> 和 <strong>E.M. Landis</strong>，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。</p><h1 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h1><p>AVL树其实是一棵<strong>高度平衡</strong>的二叉搜索树，它是依靠平衡因子来维持树的高度。</p><ul><li>对于每个结点来说，它的左右子树高度差的绝对值（平衡因子）不会超过1。</li><li>它具有和二叉搜索树一样的性质，也就是说除了二叉搜索树中那些会改变树的高度的操作（插入，删除），其他的操作都可以用在AVL树中。</li></ul><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>因为AVL树除了插入，删除这些可能改变树高度的操作之外，其他操作的与二叉搜索树无异，所以这里只讲插入和删除操作。</p><ul><li>每个叶子结点的高度都为1</li><li>每个结点都有高度，其高度为左右孩子中最高孩子的高度加上1</li><li>每个结点的高度差为左子树的高度减去右子树的高度</li><li>每当插入或删除一个结点后，可能导致某个结点的平衡因子超过1，这时候就需要对以这个结点进行旋转操作来维持平衡。</li></ul><h2 id="旋转操作："><a href="#旋转操作：" class="headerlink" title="旋转操作："></a>旋转操作：</h2><p><strong>1. 左左旋转：</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-2f934a6544648e09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要进行左左旋转" title="">                </div>                <div class="image-caption">需要进行左左旋转</div>            </figure><br>如上图，当插入一个<strong>0001</strong>这个结点后，导致<strong>0003</strong>的平衡因子超过1，此时<strong>0003</strong>结点需要通过左左旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的左孩子的左孩子上，取名左左旋转，旋转后的结果如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-f0e8f7ce0e7d9035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左左旋转后" title="">                </div>                <div class="image-caption">左左旋转后</div>            </figure><br><strong>代码实现：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotationLeft</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node x = node.left;</span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>2. 右右旋转：</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-a4a0637dd9bb9f8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要进行右右旋转" title="">                </div>                <div class="image-caption">需要进行右右旋转</div>            </figure><br>如上图，当插入一个<strong>0003</strong>这个结点后，导致<strong>0001</strong>的平衡因子超过1，此时<strong>0003</strong>结点需要通过右右旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的右孩子的右孩子上，取名右右旋转，旋转后的结果如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-f0e8f7ce0e7d9035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右右旋转后" title="">                </div>                <div class="image-caption">右右旋转后</div>            </figure><br><strong>代码实现：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationRight</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node x = node.right;</span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>3. 右左旋转：</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-63418e739c1c947c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要进行右左旋转" title="">                </div>                <div class="image-caption">需要进行右左旋转</div>            </figure><br>如上图，当插入一个<strong>0002</strong>这个结点后，导致<strong>0001</strong>的平衡因子超过1，此时<strong>0001</strong>结点需要通过右左旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的右孩子的左孩子上，取名右左旋转，旋转后的结果如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-f0e8f7ce0e7d9035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右左旋转后" title="">                </div>                <div class="image-caption">右左旋转后</div>            </figure><br><strong>代码实现：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右左旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationRightLeft</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.right = rotationLeft(node.right);</span><br><span class="line">        updateHeight(node.right);</span><br><span class="line">        <span class="keyword">return</span> rotationRight(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><p><strong>4.左右旋转：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-f63c503241adc565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" title="">                </div>                <div class="image-caption">image.png</div>            </figure><p>如上图，当插入一个<strong>0002</strong>这个结点后，导致<strong>0003</strong>的平衡因子超过1，此时<strong>0003</strong>结点需要通过左右旋转来维持平衡。因为破坏平衡的结点在发现不平衡的结点的左孩子的右孩子上，取名左右旋转，旋转后的结果如下图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-f0e8f7ce0e7d9035.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左右旋转后" title="">                </div>                <div class="image-caption">左右旋转后</div>            </figure><br><strong>代码实现：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotationLeftRight</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.left = rotationRight(node.left);</span><br><span class="line">        updateHeight(node.left);</span><br><span class="line">        <span class="keyword">return</span> rotationLeft(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="4-时间复杂度"><a href="#4-时间复杂度" class="headerlink" title="4. 时间复杂度"></a>4. 时间复杂度</h1><p>由于AVL树是一个高度平衡的二叉搜索树，所以树的高度几乎是<code>lgN</code>，所以无论查找，插入还是删除操作最坏情况的时间复杂度为<code>O(lgN)</code>。</p><h1 id="5-代码实现"><a href="#5-代码实现" class="headerlink" title="5. 代码实现"></a>5. 代码实现</h1><p>其中的插入删除操作都是用递归来实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVL</span> &lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        <span class="keyword">int</span> height;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, <span class="keyword">int</span> height, Node left, Node right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.height = height;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取树高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="number">0</span> : node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高度差</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">altitude</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height(node.left) - height(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新树高度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.height = Math.max(height(node.left), height(node.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationRight</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node x = node.right;</span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationLeft</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node x = node.left;</span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationLeftRight</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.left = rotationRight(node.left);</span><br><span class="line">        updateHeight(node.left);</span><br><span class="line">        <span class="keyword">return</span> rotationLeft(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右左旋转</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationRightLeft</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.right = rotationLeft(node.right);</span><br><span class="line">        updateHeight(node.right);</span><br><span class="line">        <span class="keyword">return</span> rotationRight(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//平衡</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">balance</span><span class="params">(Node node, <span class="keyword">int</span> altitude)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (altitude == <span class="number">2</span>)</span><br><span class="line">            node =  height(node.left.left) &gt; height(node.left.right) ? rotationLeft(node) : rotationLeftRight(node);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (altitude == -<span class="number">2</span>)</span><br><span class="line">            node =  height(node.right.left) &gt; height(node.right.right) ? rotationRightLeft(node) : rotationRight(node);</span><br><span class="line"></span><br><span class="line">        updateHeight(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        root = put(key, value, root);</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Key key, Value value, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = put(key, value, node.left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = put(key, value, node.right);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> balance(node, altitude(node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            node = node.right;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">null</span> : max(root).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = deleteMax(root);</span><br><span class="line">            --size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.left;</span><br><span class="line"></span><br><span class="line">        node.right = deleteMax(node.right);</span><br><span class="line">        <span class="keyword">return</span> balance(node, altitude(node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line"></span><br><span class="line">        node.left = deleteMin(node.left);</span><br><span class="line">        <span class="keyword">return</span> balance(node, altitude(node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = deleteMin(root);</span><br><span class="line">            --size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node node = delete(key, root);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Key key, Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            node.left = delete(key, node.left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            node.right = delete(key, node.right);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> node.right;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> node.left;</span><br><span class="line">            Node x = max(node.right);</span><br><span class="line">            node.key = x.key;</span><br><span class="line">            node.value = x.value;</span><br><span class="line">            node.right = deleteMax(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> balance(node, altitude(node));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraverse</span><span class="params">(Node node, Set&lt;Key&gt; keySet)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorderTraverse(node.left, keySet);</span><br><span class="line">        keySet.add(node.key);</span><br><span class="line">        inorderTraverse(node.right, keySet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个把键从小到大排序的迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keySet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Key&gt; keySet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        inorderTraverse(root, keySet);</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        AVL&lt;Integer, String&gt; tree = <span class="keyword">new</span> AVL&lt;&gt;();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; ++i)</span><br><span class="line">            tree.put(random.nextInt(), <span class="string">"naoko"</span> + i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tree.deleteMax();</span><br><span class="line">        tree.deleteMin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : tree.keySet())</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"符号表的大小："</span> + tree.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;AVL树得名于它的发明者—前苏联的数学家&lt;strong&gt;G.M. Adelson-Velsky&lt;/strong&gt; 和 &lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://xiepuhuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM参数</title>
    <link href="https://xiepuhuan.github.io/2017/08/24/JVM%E5%8F%82%E6%95%B0/"/>
    <id>https://xiepuhuan.github.io/2017/08/24/JVM参数/</id>
    <published>2017-08-24T06:17:19.000Z</published>
    <updated>2017-08-24T06:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1. 使用方式"></a>1. 使用方式</h1><p>使用 <code>-XX:+PrintFlagsFinal</code>参数输出所有参数的名称和默认值，参数的使用方式如下：</p><ul><li><code>-XX:+&lt;option&gt;</code>开启option参数</li><li><code>-XX:-&lt;option&gt;</code>开启option参数</li><li><code>-XX:&lt;option&gt;=&lt;value&gt;</code>开启option参数的值设置为value</li></ul><h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h1><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-Xms</td><td style="text-align:left">初始堆大小</td></tr><tr><td style="text-align:left">-Xmx</td><td style="text-align:left">最大堆大小</td></tr><tr><td style="text-align:left">-Xmn</td><td style="text-align:left">新生代大小</td></tr><tr><td style="text-align:left">-SurvivorRatio</td><td style="text-align:left">新生代中Eden区与Survivor区的比值，默认为8</td></tr><tr><td style="text-align:left">-Xss</td><td style="text-align:left">栈大小</td></tr><tr><td style="text-align:left">-XX:PermSize</td><td style="text-align:left">初始方法区大小</td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td style="text-align:left">最大方法区大小</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-使用方式&quot;&gt;&lt;a href=&quot;#1-使用方式&quot; class=&quot;headerlink&quot; title=&quot;1. 使用方式&quot;&gt;&lt;/a&gt;1. 使用方式&lt;/h1&gt;&lt;p&gt;使用 &lt;code&gt;-XX:+PrintFlagsFinal&lt;/code&gt;参数输出所有参数的名称和默认值，
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://xiepuhuan.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>LinkedList源码解析</title>
    <link href="https://xiepuhuan.github.io/2017/08/24/LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://xiepuhuan.github.io/2017/08/24/LinkedList源码解析/</id>
    <published>2017-08-24T04:47:53.000Z</published>
    <updated>2017-08-24T04:47:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>LinkedList</strong>基于链表实现，非线程安全，其既实现了List接口又实现了Deque接口，所以既可以做为列表使用又可以做双端队列使用，队头队尾插入删除时间复杂度都为O(1)，查找效率为O(n)。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="结点类型"><a href="#结点类型" class="headerlink" title="结点类型"></a>结点类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    <span class="comment">// 上一个结点</span></span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结点数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向链表头结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向链表尾结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取索引对应的结点"><a href="#获取索引对应的结点" class="headerlink" title="获取索引对应的结点"></a>获取索引对应的结点</h2><p>用链表实现的List不同于数组，查找对应索引的结点不支持随机访问，只能遍历链表找到对应位置的结点。<br>因为持有头尾结点的引用所以可以根据索引位于List中的位置而搜索对应的部分进一步提高搜索效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">// 如果索引位于List的前半部分则从头结点开始搜索</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则从尾结点开始搜索</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增删改查方法"><a href="#增删改查方法" class="headerlink" title="增删改查方法"></a>增删改查方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将新结点插入到List后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 尾指针指向新结点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果之前不存在尾结点则设置头指针为新结点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 否则将原来的尾结点指向新结点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用linkLast方法将元素e作为新结点插入List后面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果要移除的结点为空则从头结点开始遍历直到找到值为空的结点将其链接释放</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则找到一个值相等的结点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历链表把每一个结点的属性都设置为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        Node&lt;E&gt; next = x.next;</span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    first = last = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置上的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到其对应结点修改其值并返回旧值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素作为新结点插入到指定位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断插入位置是否在有效范围</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 如果插入位置在尾部则调用linkLast方法插入</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 找到对应位置上的结点插入其前面</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断索引位置是否合法</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 找到指定位置对应的结点将其释放其链接</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h2><p>创建一个数组，将链表所有结点的值都一一赋值到该数组上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    Object[] result = <span class="keyword">new</span> Object[size];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        result[i++] = x.item;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;LinkedList&lt;/strong&gt;基于链表实现，非线程安全，其既实现了List接口又实现了Deque
      
    
    </summary>
    
      <category term="JDK源码解析" scheme="https://xiepuhuan.github.io/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>LinkedHashMap源码解析</title>
    <link href="https://xiepuhuan.github.io/2017/08/24/LinkedHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://xiepuhuan.github.io/2017/08/24/LinkedHashMap源码解析/</id>
    <published>2017-08-24T03:21:53.000Z</published>
    <updated>2017-08-24T03:21:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Map是一种关联容器，其中键是唯一的，每个键都有与之对应的值，我们可以通过键获取到唯一的值。JDK中，HashMap是其中的一种实现，只不过HashMap是无序的，不能记录插入顺序与访问顺序，而<code>LinkedHashMap</code>恰好能记录插入顺序或访问顺序，至于为什么能够实现，是因为它在内部维护了一个链表专门来记录插入顺序或访问顺序，接着我们来剖析其内部实现。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="类继承关系"><a href="#类继承关系" class="headerlink" title="类继承关系"></a>类继承关系</h2><p>从下面的类继承关系可以看出<code>LinkedHashMap</code>是继承了<code>HashMap</code>的，内部复用了HashMap的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h2><p>这里的<code>Entry</code>类继承了<code>HashMap.Node</code>类，并增加了两个引用字段<code>before</code>, <code>after</code>，可以看出该链表是一个双向链表,这个类其实是为链表准备的，两个引用分别指向当前链表结点前后结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为从JDK8开始，HashMap开始采用红黑树，当每个桶中的链表长度大于8时会转为红黑树存储。所以为了保证<code>TreeNode</code>能够插入到LinkedHashMap维护的链表，TreeNode需要继承<code>LinkedHashMap.Entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的头结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">// 链表的尾结点</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">// 为false表示链表中结点按照键值对的插入顺序排序，为true表示按照访问顺序，即最近插入与访问的结点都在链表尾部</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>以下构造函数都是先调用父类的构造函数创建一个HashMap，接着将accessOrder设置为false表示按照链表按照键值对插入顺序排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里讲accessOrder设置为给定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h2><p>每次我们创建HashMap使用的结点都使用以下两个方法创建，内部实现会维护双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个链表结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 将该结点添加到双向链表尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个红黑树结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    <span class="comment">// 将该结点添加到双向链表尾部</span></span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将该结点添加到双向链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置上一个结点为当前尾结点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    <span class="comment">// 将新结点设置为尾结点</span></span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="comment">// 如果上一个结点为空，则当前头结点应该为新结点</span></span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则新结点的上一个结点</span></span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 找到key对应的Node结点，为null则不存在，返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果accessOrder为true则调用afterNodeAccess方法将最近访问的结点从链表中移动到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="comment">//返回找到的值</span></span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结点e移动到链表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 当按accessOrder为true按访问次序排序并且尾结点不是当前需要移动的结点才需要移动</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行remove方法从哈希表中删除键值对后调用，将该结点从链表中移除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行put方法成功插入后调用，目的是移除最旧的结点，即头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Map是一种关联容器，其中键是唯一的，每个键都有与之对应的值，我们可以通过键获取到唯一的值。JDK中，HashMap是其
      
    
    </summary>
    
      <category term="JDK源码解析" scheme="https://xiepuhuan.github.io/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树(Binary-Search-Tree)</title>
    <link href="https://xiepuhuan.github.io/2017/08/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(Binary-Search-Tree)/"/>
    <id>https://xiepuhuan.github.io/2017/08/24/二叉搜索树(Binary-Search-Tree)/</id>
    <published>2017-08-23T22:46:57.000Z</published>
    <updated>2017-08-23T22:46:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p>二叉搜索树(BST)又叫二叉查找树，二叉排序树。二叉搜索树就是一棵二叉树，但是它又具有搜索树的特征：</p><ul><li>每个结点都比它的左结点大，比右结点小。</li><li>每个结点的左右子树都是一课二叉搜索树。</li><li>对一棵二叉搜索树进行中序遍历结果是从小到大排序的结果。</li></ul><h1 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2. 时间复杂度"></a>2. 时间复杂度</h1><p>二叉搜索树结合了链表插入删除的灵活性和数组的查找的高效性。</p><ul><li><strong>最好情况：</strong><br>最好情况下的二叉搜索树是一棵满二叉树，这时从根结点到所有叶子结点的长度都为<code>lgN</code>，对应树的高度也为<code>lgN</code>。此时无论查找，插入，删除都可以在<code>O(lgN)</code>时间内完成。</li><li><strong>最坏情况：</strong><br>最坏情况下的二叉搜索树的每个结点只有一个孩子，几乎是链表的形状了，对应树的高度为N。此时查找，插入，删除的时间复杂度为<code>O(N)</code>。</li><li><strong>平均情况：</strong><br>二叉搜索树的平均情况应该是介于最好和最好情况之间。</li></ul><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>接下来我用二叉搜索树来实现一个符号表，符号表就是一个存储键值对的数据结构，其中键不可以重复，值可以重复。定义了如下操作：</p><blockquote><ul><li><strong>put(Key key, Value value)</strong> 将键key和值value插入符号表</li><li><strong>delete(Key key)</strong> 删除指定的键值对</li><li><strong>get(Key key)</strong>  获取键对应的值，如果不存在该键则返回null</li><li><strong>deleteMax()</strong> 删除最大的键对应的键值对</li><li><strong>deleteMin()</strong> 删除最小的键对应的键值对</li><li><strong>min()</strong> 获取最小的键</li><li><strong>max()</strong> 获取最大的键</li><li><strong>size()</strong> 获取符号表的大小</li><li><strong>isEmpty()</strong> 判断符号表否为空</li></ul></blockquote><p>代码用java描述，使用了泛型。因为需要进行比较操作，所以键都必须实现<code>Comparable</code>接口。在BST这个类中，使用了一个内部类<code>Node</code>来表示二叉搜索树的结点，同时也是一个键值对。所有操作都是采用迭代的方式。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node left, Node right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node node = root;</span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cmp = key.compareTo(node.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                node = node.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                node = node.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = root;</span><br><span class="line">        Node parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            parent = node;</span><br><span class="line">            cmp = key.compareTo(node.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                node = node.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                node = node.right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(parent.key) &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            node = node.right;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node node = max(root);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Node node = min(root);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="keyword">null</span> : node.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node x = node;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            parent = node;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --size;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = node.left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node x = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Node parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            parent = node;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --size;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.left = node.right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = deleteMax(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        traverse(node.left);</span><br><span class="line">        System.out.println(node.key);</span><br><span class="line">        traverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        Node node = root;</span><br><span class="line">        Node parent = root;</span><br><span class="line">        <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            cmp = key.compareTo(node.key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="number">0</span>) &#123;</span><br><span class="line">                --size;</span><br><span class="line">                cmp = key.compareTo(parent.key);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                        parent.left = node.right;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                        parent.right = node.right;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        root = node.right;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                        parent.left = node.left;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                        parent.right = node.left;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        root = node.left;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Node x = min(node.right);</span><br><span class="line">                node.key = x.key;</span><br><span class="line">                node.value = x.value;</span><br><span class="line">                node.right = deleteMax(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               parent = node;</span><br><span class="line">               <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                   node = node.left;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        BST&lt;Integer, String&gt; bst = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">        bst.put(<span class="number">2</span>, <span class="string">"qw"</span>);</span><br><span class="line">        bst.put(<span class="number">3</span>, <span class="string">"fy"</span>);</span><br><span class="line">        bst.put(<span class="number">5</span>, <span class="string">"naoko"</span>);</span><br><span class="line">        bst.put(<span class="number">1</span>, <span class="string">"qw"</span>);</span><br><span class="line">        bst.put(<span class="number">4</span>, <span class="string">"naoko"</span>);</span><br><span class="line">        bst.put(-<span class="number">3</span>, <span class="string">"naoko"</span>);</span><br><span class="line">        bst.deleteMax();</span><br><span class="line">        bst.deleteMin();</span><br><span class="line">        bst.delete(<span class="number">10</span>);</span><br><span class="line">        bst.traverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h1><p>二叉搜索树虽然简单但在最坏情况下表现得并不好。不过它是其他树类型的数据结构的基础，二叉搜索树还有其他变种如AVL树，红黑树，Treap树等。在C++，Java的集合API中，符号表或是Set的实现一般都是用红黑树。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h1&gt;&lt;p&gt;二叉搜索树(BST)又叫二叉查找树，二叉排序树。二叉搜索树就是一棵二叉树，但是它又具有搜索树的特征：&lt;/p&gt;
&lt;ul&gt;

      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://xiepuhuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="https://xiepuhuan.github.io/2017/08/23/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://xiepuhuan.github.io/2017/08/23/HashMap源码解析/</id>
    <published>2017-08-23T14:10:06.000Z</published>
    <updated>2017-08-23T14:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>Java中的<strong>HashMap</strong>是符号表的一种哈希实现（采用拉链法），HashMap用来存储键值对，键和值都可以为<code>Null</code>，其中键是唯一的。在Java7中的实现是用数组+链表，在Java8中的实现是数组+链表+红黑树。因为引进了红黑树的，所以Java8中的HashMap的查找效率提高了不少。以下的讲解的源码也是Java8的源码。</p><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><ul><li>拉链法是一种处理哈希冲突的一种方法，其他的还有线性探测法、平方探测法、双散列法。</li><li>拉链法将产生冲突的元素放在数组冲突位置上的一个存储结构上（一般是链表）</li></ul><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="HashMap内部结构"><a href="#HashMap内部结构" class="headerlink" title="HashMap内部结构"></a>HashMap内部结构</h2><ol><li>在HashMap中，数组<code>table</code>的大小是2的n次幂。</li><li>当HashMap中的键值对数量超过<code>threshold</code>这个阈值时，需要对数组进行扩容。为了避免数组过小导致每个数组位置存储的链表过长或红黑树过大，导致查找效率低下。这其实是一种以空间换时间的方法。</li><li>当数组中的链表超过8时，将链表换成红黑树以提高查找效率。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-8a6822bce84d8436?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HashMap内部结构图" title="">                </div>                <div class="image-caption">HashMap内部结构图</div>            </figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; /默认初始容量</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;    /最大容量</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; /加载因子</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;     /由链表转换为红黑树时链表长度的阈值</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;   /由红黑树转换为链表时红黑树大小的阈值</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; /由链表转换为红黑树时桶的阈值</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;    </span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;  </span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; /哈希表当前的键值对数量</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; /哈希表内部结构发生变化的次数</span><br><span class="line"><span class="keyword">int</span> threshold;  /扩容的阈值</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; /负载因子</span><br></pre></td></tr></table></figure><h2 id="结点类型"><a href="#结点类型" class="headerlink" title="结点类型"></a>结点类型</h2><p>在HashMap中存储的键值对都是<code>Node</code>或是<code>Node</code>的子类，链表的结点类型是<code>Node</code>，红黑树的结点类型是<code>TreeNode</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; /储存对key使用hash方法得出来的值</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li><code>initialCapacity</code>参数用来确定哈希表初始容量（桶的数量），不过并不直接使用<code>initialCapacity</code>来作为初始容量，而是使用由<code>tableSizeFor</code>方法来得出不小于<code>initialCapacity</code>的第一个2的n次幂的正整数（例如输入8返回8，输入9返回16）作为初始容量。</li><li><code>loadFactor</code>用来指定负载因子</li></ul><p>当构造函数执行完并不会创建<code>Node</code>的数组，而是等到<code>put</code>方法执行时由<code>resize</code>方法创建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><p>进行查找操作最重要的一步就是确定键在哪个桶中，其中第一步就用到hash方法，使用到hash方法是为了使键在数组中的分布更加均匀，减少冲突：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着利用<code>(n - 1) &amp; hash</code>（n是数组<code>table</code>的大小）得出键在哪个桶中，那这里为什么不用<code>hash % n</code>呢？因为位运算的速度比求余快。这里的<code>table</code>的大小必须是2的n次幂，原因有两个：</p><ul><li>因为n - 1之后高位为0，低位部分为1，使得哈希方法结果在参与与运算之后有意义，从而减少冲突。</li><li>为之后的扩容方法做优化</li></ul><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>数组<code>table</code>就是第一次执行<code>put</code>方法时创建出来的。</p><h3 id="put方法执行流程图"><a href="#put方法执行流程图" class="headerlink" title="put方法执行流程图"></a>put方法执行流程图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-1bc7945f6225dbfe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="put方法执行流程图" title="">                </div>                <div class="image-caption">put方法执行流程图</div>            </figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    /数组还没创建或者数组大小为<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        /执行扩容操作</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    /求得键所在的桶，并判断是否为空</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        /若为空直接添加结点作为链表头结点到该位置上</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        /e是用来存储找到的结点</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        /如果该桶的第一个结点就是，则找到</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        /否则判断该桶存储的是否为一棵红黑树</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            /调用putTreeVal方法向该树插入该结点，如果返回为空则插入成功，否则在树中找到该结点</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            /遍历该桶的链表</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    /当发现下个结点为空，证明已经遍历完所有结点还没发现key所在的结点</span><br><span class="line">                    那就直接插入新结点</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    /判断链表长度是否超过<span class="number">8</span>，是就将链表树形化</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                /找到key所在的结点则退出</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /判断结点是否为空，不为空则找到</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            /如果允许结点存在时替换旧的值或者旧的值为<span class="keyword">null</span>则替换旧值</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            </span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h2><p>Java 1.8里的扩容方法比较特别的一个优化就是扩容后结点的转移，例如对于原数组的一个桶中的所有元素要转移到新数组中需要一个个重新用<code>hash &amp; (n - 1)</code>计算新位置吗？当然不用。得益于数组大小的特点（2的n次幂），我们可以轻易知道原数组的一个桶中所有结点转移到新数组中只会存在于两个位置：</p><ul><li>原索引</li><li>原索引 + oldCap<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-640e2ecfd579c222..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></li></ul><p>关于这个的原理观察一下这个<code>hash &amp; (n - 1)</code>和上图你就能发现扩容后改变的是n，而与hash进行与运算的<code>n - 1</code>比原来多了一位1，与运算后出来的索引比原来多一种可能，而这种可能就是在原索引的基础上加上oldCap。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    /若原数组的大小已经大于<span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        / 若原数组大小已经达到最大值，则设置阈值为Integer.MAX_VALUE，即以后不能再执行扩容方法</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;/否则将数组扩大一倍，</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            /扩容后数组的大小未达到最大值并且旧数组大小不小于默认初始容量则将阈值也扩大一倍</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;/否则如果旧阈值大于<span class="number">0</span>（即在构造函数中给出了initialCapacity）</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        /未给定initialCapacity就使用默认初始容量，阈值也是默认的</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    /如果没有设置新阈值</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        /计算出新阈值</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    /当旧数组不为空时，将旧数组里的所有结点转移到新数组里去</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        /遍历数组</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            /判断桶是否为空</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                /如果该桶只有一个结点，就直接将该结点转移到新数组对应的桶中</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                /否则如果结点是TreeNode类型，执行split方法</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    /两条链表</span><br><span class="line">                    第一条是代表原索引位置上的链表</span><br><span class="line">                    第二条是代表原索引 + oldCap位置上的链表</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    /遍历该链表</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        /若该结点在新数组中的索引为原索引</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            /若链表为空，添加该结点为头结点</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>    /否则在尾部添加该结点</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;/否则该结点在新数组中的索引为原索引 + oldCap</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    /如果链表不为空将该链表添加到新数组</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="树形化"><a href="#树形化" class="headerlink" title="树形化"></a>树形化</h2><p>当添加一个结点后如果结点所在链表的长度大于8时，要将链表树形化（转换为红黑树）。但是进行树形化还需要满足一个条件，就是数组的大小要不小于<code>MIN_TREEIFY_CAPACITY</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><h3 id="remove方法执行过程图"><a href="#remove方法执行过程图" class="headerlink" title="remove方法执行过程图"></a>remove方法执行过程图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-f81c790a06004f1c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="remove方法执行过程图" title="">                </div>                <div class="image-caption">remove方法执行过程图</div>            </figure><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><ul><li><code>matchValue</code>是一个布尔型参数，为<code>false</code>表示不需要匹配值，为<code>true</code>表示需要匹配值，值一样才算找到</li><li><code>movable</code>表示移除红黑树结点时需不需要移动其他结点<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    /只有在表不为空且找到键所在的桶也不为空才能继续</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        /判断第一个结点是否是要找的结点</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        /否则当存在下一个结点才继续</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            /判断桶中的结点是否是红黑树的结点</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;/否则遍历链表寻找结点</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /结点不为空则为找到</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>在<code>HashMap</code>里一共有三种迭代器：</p><ul><li><code>KeyIterator</code> </li><li><code>ValueIterator</code></li><li><code>EntryIterator</code></li></ul><p>这三种迭代器都继承了<code>HashIterator</code>类并实现了<code>Iterator</code>接口供<code>KeySet</code>、<code>Values</code>、<code>EntrySet</code>使用。其中最重要的<code>HashIterator</code>是用来迭代哈希表中的结点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        /找到第一个不为空的桶</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        /如果modCount != expectedModCount则表示可能有其他线程修改了哈希表或者当前线程调用非迭代器的方法修改</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        /设置current为当前结点并找到下一个结点赋值给next</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在HashMap中的<code>modCount</code>是和迭代器中<code>expectedModCount</code>搭配起来提供<strong>快速失败机制</strong>（fail-fast）的。 体现在用迭代器遍历HashMap时，如果遍历过程中对集合对象的内容进行了修改，可能会导致迭代器遍历出现异常。所以每次使用<code>next</code>、<code>remove</code>方法都会先判断<code>modCount</code>与<code>expectedModCount</code>是否相等，如果不相等则表示被修改过，就会抛出<code>ConcurrentModificationException</code>。在迭代器遍历<code>HashMap</code>时如果想移除遍历到的值可以使用<code>Iterator</code>的<code>remove</code>方法。</p><h1 id="3-最后"><a href="#3-最后" class="headerlink" title="3. 最后"></a>3. 最后</h1><ol><li>HashMap是无序的，即无法维持键值对的先后插入顺序，也无法提供按键排序的功能，如要使用有序的map（符号表），可以使用下面两种：<ul><li><code>LinkedHashMap</code>：LinkedHashMap是HashMap的子类，可以保证插入的先后顺序，用迭代器遍历LinkedHashMap时，先得到的记录是先插入的，也可以在构造时指定参数，按照访问次序进行排序。</li><li><code>TreeMap</code>: TreeMap实现SortedMap接口，可以把记录按键的大小排序，默认是升序排序，也可以指定比较器进行排序，当用迭代器遍历TreeMap时，得到的记录是排过序的。</li></ul></li><li>HashMap不是线程安全的类，不能适用于多线程的环境。不过有三种方式使用线程安全的map（符号表）：<ul><li><code>Hashtable</code>： <strong>已过时的类不推荐使用</strong>。</li><li><code>ConcurrentHashMap</code>：<strong>推荐使用</strong>，使用CAS机制使得并发情况下效率比<code>Hashtable</code>高</li><li><code>Collections.synchronizedMap(map)</code>：使用静态工厂方法将HashMap对象封装成一个线程安全的类，因为<code>SynchronizedMap</code>使用了<code>synchronized</code>关键字，所以并发效率不如<code>ConcurrentHashMap</code>高。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;h2 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;H
      
    
    </summary>
    
      <category term="JDK源码解析" scheme="https://xiepuhuan.github.io/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor源码解析</title>
    <link href="https://xiepuhuan.github.io/2017/08/23/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://xiepuhuan.github.io/2017/08/23/ThreadPoolExecutor源码解析/</id>
    <published>2017-08-23T00:10:56.000Z</published>
    <updated>2017-08-23T00:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在引入线程池之前，我们先来了解几个事情：</p><ul><li>线程的创建和销毁是有代价的，如线程创建需要时间和相关计算资源。如果在Web服务器上为每个来到的请求都创建一个线程，而大多数请求都是轻量级的处理过程。那么创建线程的代价与请求处理的代价相比就非常大了，导致影响整体性能。</li><li>当线程数量达到能让CPU忙绿起来的时候，此时再创建线程，线程也基本处于闲置状态，这时候多出来的线程除了占用内存外，还可能因为与其他线程争用CPU资源导致出现其他性能开销.</li><li>在可创建线程的数量上存在一个限制，如果超过这个限制，可能会抛出<code>OutOfMemoryError</code>异常。</li></ul><p>这时候如果能出现一个东西能够对线程的生命周期进行管理，对现有的线程重复利用，并且能够以一种简单的方式将任务的提交与执行相解耦。没错，这就是<strong>线程池</strong>(Thread Pool)，在要了解Java中的线程池，首先必须了解<code>ThreadPoolExecutor</code>这个类。</p><h1 id="2-ThreadPoolExecutor详解"><a href="#2-ThreadPoolExecutor详解" class="headerlink" title="2. ThreadPoolExecutor详解"></a>2. ThreadPoolExecutor详解</h1><h2 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-4783b424cea714fa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ThreadPoolExecutor类继承" title="">                </div>                <div class="image-caption">ThreadPoolExecutor类继承</div>            </figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/线程池配置信息，<span class="keyword">volatile</span>修饰保证变量在多线程下的可见性</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">    <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的JDK中<code>ThreadPoolExecutor</code>类的构造函数源码看出该构造函数一共有7个参数，下面介绍七个参数的含义：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>corePoolSize</code></td><td style="text-align:left">基本大小，即线程池中的核心线程数</td></tr><tr><td style="text-align:left"><code>maximumPoolSize</code></td><td style="text-align:left">最大大小，即线程池中允许的最大线程数</td></tr><tr><td style="text-align:left"><code>keepAliveTime</code></td><td style="text-align:left">存活时间，当线程的没执行任务时，空闲的时间超过了这个时间就会被标记为可回收，直到线程池的大小超过基本大小，被标记的线程就会被终止</td></tr><tr><td style="text-align:left"><code>unit</code></td><td style="text-align:left"><code>keepAliveTime</code>的单位，有<code>DAYS</code>、<code>HOURS</code>、<code>MINUTES</code>、<code>SECONDS</code>、<code>MILLISECONDS</code>、<code>MICROSECONDS</code>、<code>NANOSECONDS</code>7个单位可选</td></tr><tr><td style="text-align:left"><code>workQueue</code></td><td style="text-align:left">工作队列，一个用来保存等待被执行的任务的阻塞队列</td></tr><tr><td style="text-align:left"><code>threadFactory</code></td><td style="text-align:left">线程工厂。线程池在创建线程时通过调用线程工厂的<code>Thread newThread(Runnable r)</code>来创建线程</td></tr><tr><td style="text-align:left"><code>handler</code></td><td style="text-align:left">饱和策略。当阻塞队列已满、线程池当前的线程数已达到最大值且没有线程处于空闲状态时，此时对于提交过来的任务将执行饱和策略。（如果某个任务提交到一个已关闭的Executor时，也会执行饱和策略）</td></tr></tbody></table><p><code>ThreadPoolExecutor</code>类中有四个重载的构造函数，每个构造函数都必须指定上表中的前5个参数，最后两个参数可以随意指定，不指定的话构造函数会使用默认的<strong>线程工厂</strong>和<strong>饱和策略</strong>：</p><h3 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂(ThreadFactory)"></a>线程工厂(ThreadFactory)</h3><p>线程池创建线程都是通过的<code>ThreadFactory</code>的<code>Thread newThread(Runnable r)</code>方法来创建的。下面是<code>Executors</code>类里的默认线程工厂方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出默认线程工厂创建出的是一个<strong>非守护、优先级为<code>Thread.NORM_PRIORITY</code></strong> 的线程。如果想要自己定制线程工厂满足需求，只需实现<code>ThreadFactory</code>接口的<code>Thread newThread(Runnable r)</code>方法。</p><h3 id="饱和策略-RejectedExecutionHandler"><a href="#饱和策略-RejectedExecutionHandler" class="headerlink" title="饱和策略(RejectedExecutionHandler)"></a>饱和策略(RejectedExecutionHandler)</h3><p>JDK中的<code>ThreadPoolExecutor</code>类提供了4种不同的<code>RejectedExecutionHandler</code>实现：</p><ul><li><code>AbortPolicy</code><br><strong>默认的饱和策略</strong>，该策略抛出未检查（运行时异常）的<code>RejectedExecutionException</code>。</li><li><code>DiscardPolicy</code> 不执行任何操作，直接抛弃任务</li><li><code>CallerRunsPolicy</code> 在调用者线程中执行该任务</li><li><code>DiscardOldestPolicy</code> 丢弃阻塞队列中的第一个任务， 然后重新将该任务交给线程池执行</li></ul><p>同样的，可以通过实现<code>RejectedExecutionHandler</code>接口自定义饱和策略。</p><h2 id="线程池状态和线程数量"><a href="#线程池状态和线程数量" class="headerlink" title="线程池状态和线程数量"></a>线程池状态和线程数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/代表线程池当前状态和线程数量的原子变量</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;  /COUNT_BITS为<span class="number">29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; /CAPACITY为能表示的最大线程数。</span><br><span class="line"></span><br><span class="line">/线程池状态</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">/对线程池状态和线程数量进行打包和拆包的函数：</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">/判断线程池状态的三个函数</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/线程数量增<span class="number">1</span>，成功返回<span class="keyword">true</span>，失败返回<span class="keyword">false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/线程数量减<span class="number">1</span>，成功返回<span class="keyword">true</span>，失败返回<span class="keyword">false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/线程数量减<span class="number">1</span>，失败则重试直到成功</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AtomicInteger</code>类型的变量<code>ctl</code>用高3位来表示当前线程池状态，低29位来表示当前的线程数。</p><p>Java线程池有5种不同的状态，分别为运行(<code>RUNNING</code>)、关闭(<code>SHUTDOWN</code>)、停止(<code>STOP</code>)、整理(<code>TIDYING</code>)、结束(<code>TERMINATED</code>)。<br>在<code>ThreadPoolExecutor</code>里由5个整型常量表示，每个整型常量的都由高3位表示状态：</p><ul><li><code>RUNNING</code> 高3位为<em>111</em>，该状态的线程池会接收新任务，并处理阻塞队列中的任务</li><li><code>SHUTDOWN</code> 高3位为<em>000</em>，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务。调用<code>void shutdown()</code>方法实现</li><li><code>STOP</code> 高3位为<em>001</em>，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务。调用<code>List&lt;Runnable&gt; shutdownNow()</code>实现。</li><li><code>TIDYING</code> 高3位为<em>010</em>，当线程池关闭后阻塞队列的任务已完成或线程池停止，然后<code>workerCount</code>（当前线程数量)为0，线程池进入该状态后会调用<code>terminated()</code>方法进入<code>TERMINATED</code>状态。</li><li><code>TERMINATED</code> 高3位为<em>011</em><h2 id="启动线程池"><a href="#启动线程池" class="headerlink" title="启动线程池"></a>启动线程池</h2>当创建完一个<code>ThreadPoolExecutor</code>对象后，线程池里并没有线程。一般都是调用<code>void execute(Runnable command)</code>执行任务时才创建线程并启动，不过可以通过调用如下方法预先创建核心线程并启动（在addWorker方法里启动）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">            ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-fc87fd4f29d96669?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行过程" title="">                </div>                <div class="image-caption">执行过程</div>            </figure><p>如上图所示，当调用<code>void execute(Runnable command)</code>这个方法执行任务时：</p><ol><li>判断当前线程池线程数量是否小于核心线程池大小，是则创建线程并启动，否则到第2步</li><li>判断任务队列是否已满，未满则将任务加入阻塞队列，已满则到第3步</li><li>判断当前线程池线程数量是否小于最大线程池大小，是则创建线程并启动，否则执行饱和策略</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    /任务为空，抛出空指针异常</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">   </span><br><span class="line">   /判断当前线程数量是否小于核心线程数</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;  </span><br><span class="line">        /是则添加一个核心线程(<span class="keyword">true</span>表示核心线程)到线程池，并且启动线程执行任务（addWorker方法里会启动）</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))   </span><br><span class="line">            <span class="keyword">return</span>; /添加成功则返回</span><br><span class="line">        c = ctl.get(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /线程池处于运行状态则向阻塞队列添加该任务</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; </span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        /判断线程池是否处于运行状态，不是就移除刚才添加的任务</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            /移除成功就执行饱和策略，这样整个方法就结束了</span><br><span class="line">            reject(command);</span><br><span class="line">        /否则若处于运行状态或移除失败，这时无论处于哪种情况任务都在阻塞队列里，判断当前线程数量是否为<span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            若是则添加一个线程并启动</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p><code>boolean addWorker(Runnable firstTask, boolean core)</code>方法的作用就是创建<code>Worker</code>对象并启动这个对象里的线程（<code>Worker</code>里一个<code>Thread</code>类型的字段）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        /如果线程池不处于运行状态，理论上不应该添加一个执行该任务的线程，但如果满足下面三个条件的话就可以通过：</span><br><span class="line">        <span class="number">1</span>. 线程池状态是关闭</span><br><span class="line">        <span class="number">2</span>. 要执行的任务为空</span><br><span class="line">        <span class="number">3</span>. 阻塞队列不为空</span><br><span class="line">        因为线程池关闭后不允许提交任务，但关闭后会执行完阻塞队列的任务，所以允许添加一个firstTask为空的线程</span><br><span class="line">        来帮助执行完阻塞队列里的任务</span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            /若当前线程池的线程数量达到了线程池所允许的最大线程数或所指定要添加线程类型的线程数量则返回<span class="keyword">false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            /到这里前面的限制条件都通过，现在尝试将线程数量增一，成功则退出最外层的循环</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            /失败则重新获取线程池状态，状态改变则从最外层循环开始执行，不变则从内循环开始执行</span><br><span class="line">            c = ctl.get();  </span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        /构造一个Worker对象，每个Worker对象绑定一个线程</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                /若线程池处于运行状态或处于关闭且firstTask为<span class="keyword">null</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    线程提前启动，则抛出异常</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    /将w加到Worker的集合里</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    获取Worker集合大小，若大小比largestPoolSize大小大，则更新一下</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    /添加成功</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            /若添加成功则启动线程</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        /若启动失败（t线程为空或添加过程中抛出异常）则执行addWorkerFailed方法</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>线程池维护的线程其实是一组Worker对象，Worker封装了线程也继承了<code>AbstractQueuedSynchronizer</code>类并实现了<code>Runnable</code>接口，重写了<code>void run()</code>方法。至于为什么要继承<code>AbstractQueuedSynchronizer</code>类，请看下面的<code>runWorker</code>方法讲解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    /绑定这个对象线程已执行完成的任务数</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">    </span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        /阻止中断，在任务获取前不允许中断</span><br><span class="line">        setState(-<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /线程启动时执行的方法</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /获取锁，不可重入</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    /尝试获取锁</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    /释放锁</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    /判断锁是否被独占</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    /中断已开始执行的线程，这个就是为什么要设置setState(-<span class="number">1</span>)的一个原因了，这个方法会被`shutdownNow()`方法调用。</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p>上面说到为什么<code>Worker</code>类要继承<code>AbstractQueuedSynchronizer</code>，其实是要用锁的状态来区分空闲线程和非空闲线程，在执行<code>runWorker</code>方法中：</p><ul><li>获取任务时没有加锁（空闲状态，可中断线程）</li><li>要执行任务时才加锁（不允许中断线程）</li></ul><p>在调用<code>void tryTerminate()</code>和<code>void shutdown()</code>这两个方法时，会中断空闲线程，所以没有在执行任务的线程就可能被中断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); /允许中断，与Worker构造函数的setState(-<span class="number">1</span>)是一对的</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        /获取到任务才进入循环</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            /加锁，表示非空闲状态</span><br><span class="line">            w.lock();</span><br><span class="line">            /<span class="number">1</span>. 如果线程池状态大于等于STOP并且本线程未中断，则应该执行中断方法</span><br><span class="line">             <span class="number">2</span>. 或者执行Thread.interrupted()方法判断本线程是否中断并且清除中断状态，</span><br><span class="line">                如果发现线程池状态大于等于STOP则执行中断方法。</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                /ThreadPoolExecutor中的beforeExecute(wt, task)方法一个空方法，用来留给继承ThreadPoolExecutor的类</span><br><span class="line">                 来重写该方法并在任务执行前执行</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    /执行获取到的任务</span><br><span class="line">                    task.run();</span><br><span class="line">![](https:<span class="comment">//user-gold-cdn.xitu.io/2017/12/30/160a72c7c9f35844?w=977&amp;h=318&amp;f=png&amp;s=14007)</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    /ThreadPoolExecutor中的afterExecute(task,thrown)方法也是一个空方法，用来留给继承</span><br><span class="line">                    ThreadPoolExecutor的类来重写该方法并在任务执行后执行</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                /该线程执行的任务加<span class="number">1</span>，即使抛出异常</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                /释放锁，表示回到空闲状态</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /执行到这一步表示是由于获取不到任务而正常退出的，所以completedAbruptly为<span class="keyword">false</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        /无论怎样退出都要执行</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    /表示获取任务是否已超时</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        /<span class="number">1</span>. 若线程池状态大于等于停止状态，此时线程池不再处理队列的任务，并且会回收所有线程（不管空不空闲），</span><br><span class="line">            所以此时应该把线程池线程数量减<span class="number">1</span>，并且获取的任务为空</span><br><span class="line">         /<span class="number">2</span>. 处于关闭状态且任务队列为空，表示任务队列为空且不会有任务提交，所以线程数减<span class="number">1</span>，并且获取的任务为空</span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        /是否启用超时机制。当允许核心线程超时或当前线程数超过核心线程则启用</span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        /如果线程数量超过线程池所允许的最大线程数或者启用超时机制情况下获取任务超时，理论上应该回收线程。</span><br><span class="line">         但是如果该线程是线程池中的最后一个线程且任务队列不为空就可以不回收，继续运行，要是还有其他线程或者任务队列为空则回收该线程。</span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            /尝试将线程数量减<span class="number">1</span>，成功返回<span class="keyword">null</span>，失败继续从循环开始处开始。这里为什么不是用decrementWorkerCount()</span><br><span class="line">            这种不会失败的方法减<span class="number">1</span>而采用这种方式。是因为 wc &gt; <span class="number">1</span>，如果线程池不只有一个线程它们互相发现不只一个线程，</span><br><span class="line">            且它们同时执行不会失败的将线程数量减一的方法，到时线程池线程数量可能就为<span class="number">0</span>了，哪么队列中的任务就没线程执行了。</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            /<span class="number">1</span>. 如果启用超时机制就执行poll()方法，在keepAliveTime纳秒内还没获取就返回<span class="keyword">null</span>。</span><br><span class="line">             <span class="number">2</span>. 如果未启用超时机制就执行take()方法，队列没任务就一直阻塞直到有任务。</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            /到这里就是因为超时获取不到任务</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            /在执行take()过程中被中断并不算超时</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    /由于不是获取不到任务而正常退出的，得在这里将线程数减<span class="number">1</span>，正常退出的在getTask()方法有这个减<span class="number">1</span>操作</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    /加锁，因为HashSet和completedTaskCount不是线程安全的</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        /将线程执行的任务数统一加到线程池维护的completedTaskCount字段</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    /尝试将线程池设置为结束状态</span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">     /满足当前线程池状态小于STOP（运行或关闭状态）才继续</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        若线程是异常退出runWorker方法就直接添加一个没有带初始任务的非核心线程</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            /这三行代码找出当前线程池所至少存在的线程数</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            /如果当前线程数已经大于等于min，就直接返回，否则添加一个没有带初始任务的非核心线程</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是向线程池提交任务后，线程池的正常执行过程：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-89fc3307c319d88a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池正常运行过程" title="">                </div>                <div class="image-caption">线程池正常运行过程</div>            </figure></p><h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-95259b2dd5526261?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线程池状态转换" title="">                </div>                <div class="image-caption">线程池状态转换</div>            </figure><p><code>terminate</code>（结束）是线程池的最后一个状态，只能由关闭或停止状态转变为结束状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         /如果满足下面任意一个条件就没办法到达结束状态</span><br><span class="line">         <span class="number">1</span>. 线程池处于运行状态</span><br><span class="line">         <span class="number">2</span>. 线程池状态是TIDYING或已经是结束状态</span><br><span class="line">         <span class="number">3</span>. 线程池处于关闭状态且任务队列不为空</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         /当前线程数量不为<span class="number">0</span>也无法到达结束状态</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; </span><br><span class="line">            /中断一个空闲线程</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             /尝试将线程池状态设置为TIDYING，失败重循环开始处开始</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    /terminated()是一个空方法，留给继承ThreadPoolExecutor的类覆盖</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    /尝试将线程池状态设置为TERMINATED</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="关闭操作"><a href="#关闭操作" class="headerlink" title="关闭操作"></a>关闭操作</h2><p>我们可以通过调用<code>void shutdown()</code>方法关闭线程池，关闭后线程池后不允许接受新任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        / 安全策略判断</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        /设置线程池状态为SHUTDOWN状态</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        /中断所有空闲线程</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    /尝试结束线程池</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="停止操作"><a href="#停止操作" class="headerlink" title="停止操作"></a>停止操作</h2><p>我们可以在运行和关闭状态下通过调用<code>void shutdownNow()</code>方法停止线程池，停止后线程池后不允许接受新任务，也不会执行阻塞队列里的任务，还会中断当前所有的线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        / 安全策略判断  </span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        /设置线程池状态为STOP状态</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        /中断所有线程，不管是空闲还是非空闲</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        /取出阻塞队列的所有任务</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    /尝试结束线程池</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-线程池的配置"><a href="#3-线程池的配置" class="headerlink" title="3. 线程池的配置"></a>3. 线程池的配置</h1><p><code>Executors</code>提供了四种静态工厂方法来创建四种不同配置的线程池：</p><ul><li><p><code>newFixedThreadPool(int nThreads)</code> </p><p>接受一个int类型的nThreads变量，创建一个<strong>核心线程数</strong>和<strong>最大线程数</strong>都为<code>nThreads</code>的线程池（即最大线程数为nThreads），且使用一个无界的阻塞队列<code>LinkedBlockingQueue</code>。如果不设置核心线程超时的话，创建的线程是不会超时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>newSingleThreadExecutor()</code></p><p>创建一个<strong>核心线程数</strong>和<strong>最大线程数</strong>都为1的线程池（即最大线程数为1)，且使用一个无界的阻塞队列<code>LinkedBlockingQueue</code>，不设置核心线程超时的话，创建的线程也是不会超时的。唯一线程可以保证任务的顺序执行，如果这个唯一的线程执行过程中因为异常而结束的话，在<code>processWorkerExit</code>方法最后会判断是否因异常而结束而创建一个新线程继续运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>newCachedThreadPool()</code></p><p> 创建一个<strong>核心线程数</strong>为0，<strong>最大线程数</strong>为<code>Integer.MAX_VALUE</code>的线程池，超时时间为60秒，所以线程空闲时间超过60秒就会被回收。使用了一个同步队列作为阻塞队列，同步队列不存储元素，且在一端进行插入，另一端要有移除操作插入才会成功，否则插入操作会阻塞等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>newScheduledThreadPool()</code></p><p> 创建一个核心线程数为<code>corePoolSize</code>的线程池，用于指定的时间内周期性的执行所的任务。<code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;在引入线程池之前，我们先来了解几个事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程的创建和销毁是有代价的，如线程创建需要时间和相关
      
    
    </summary>
    
      <category term="JDK源码解析" scheme="https://xiepuhuan.github.io/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Class文件</title>
    <link href="https://xiepuhuan.github.io/2017/08/23/Class%E6%96%87%E4%BB%B6/"/>
    <id>https://xiepuhuan.github.io/2017/08/23/Class文件/</id>
    <published>2017-08-22T19:12:15.000Z</published>
    <updated>2017-08-22T19:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Class文件是一种与平台无关的字节码文件，每一个Class文件都对应一个类或接口的定义信息，它包含了Java虚拟机指令集和符号表以及其他辅助信息。Class文件只与Java虚拟机有关，可以由不同的语言编写的源代码编译而来。</p><h1 id="2-结构"><a href="#2-结构" class="headerlink" title="2. 结构"></a>2. 结构</h1><p>Class文件是一组以8个字节为基础单位的字节流。在下表的数据项中：</p><ul><li>u1、u2、u4、u8类型分别代表1个字节、2个字节、4个字节、8个字节的无符号数</li><li>_info结尾的类型是表类型，是由多个无符号数或其他表作为数据项的复合数据类型</li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u4</td><td style="text-align:left">magic（魔数）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">minor_version（副版本号）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">major_version（主版本号）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">constant_pool_count（常量池计数器）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">cp_info</td><td style="text-align:left">constant_pool（常量池）</td><td style="text-align:left">constant_pool_count-1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">access_flags（访问标志）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">this_class（类索引）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">super_class（父类索引）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">interfaces_count（接口计数器）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">interfaces（接口表）</td><td style="text-align:left">interfaces_count</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">fields_count（字段计数器）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">field_info</td><td style="text-align:left">fields（字段表）</td><td style="text-align:left">fields_count</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">methods_count（方法计数器）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">method_info</td><td style="text-align:left">methods（方法表）</td><td style="text-align:left">methods_count</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">attributes_count（属性计数器）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes（属性表）</td><td style="text-align:left">attributes_count</td></tr></tbody></table><h2 id="数据项含义"><a href="#数据项含义" class="headerlink" title="数据项含义"></a>数据项含义</h2><h3 id="magic（魔数）"><a href="#magic（魔数）" class="headerlink" title="magic（魔数）"></a>magic（魔数）</h3><p>每个Class文件头4个字节就是魔数，魔数的作用是确定这个文件是否为一个能被虚拟机所接受的Class文件。魔数的值固定为<strong>0xCAFEBABE</strong>。</p><h3 id="主版本号-amp-副版本号"><a href="#主版本号-amp-副版本号" class="headerlink" title="主版本号 &amp; 副版本号"></a>主版本号 &amp; 副版本号</h3><p>主副版本号共同构成了Class文件的版本号，规定了这个版本号的Class文件只能由不低于这个版本号的虚拟机执行。</p><h3 id="constant-pool-count（常量池计数器）"><a href="#constant-pool-count（常量池计数器）" class="headerlink" title="constant_pool_count（常量池计数器）"></a>constant_pool_count（常量池计数器）</h3><p>常量池计数器的值代表了常量池的容量。这里需要注意一点<strong>常量池的容量比常量池的常量数据项还要多1，因为常量池常量的索引是从1开始的</strong>。举个例子：常量池有8个常量，那么常量池的索引就是1-8，空出了0这个索引，那么常量池计数器表示为常量池容量就为9（即0-8）。</p><h3 id="constant-pool（常量池）"><a href="#constant-pool（常量池）" class="headerlink" title="constant_pool（常量池）"></a>constant_pool（常量池）</h3><p>常量池中主要存放两大类常量：</p><ol><li>字面值<ul><li>字符串</li><li>声明为<code>final</code>的常量</li></ul></li><li>符号引用<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ol><h3 id="access-flags（访问标志）"><a href="#access-flags（访问标志）" class="headerlink" title="access_flags（访问标志）"></a>access_flags（访问标志）</h3><p>访问标志用于表示某个类或者接口的访问权限及基础属性</p><h3 id="类索引（this-class）"><a href="#类索引（this-class）" class="headerlink" title="类索引（this_class）"></a>类索引（this_class）</h3><p>类索引的是一个u2类型的数据项，它的值表示指向常量池中当前类或接口的索引，即一个CONSTANT_Class_info类型的符号引用。</p><h3 id="super-class（父类索引）"><a href="#super-class（父类索引）" class="headerlink" title="super_class（父类索引）"></a>super_class（父类索引）</h3><p>父类索引的是一个u2类型的数据项，它的值表示指向常量池中父类的索引，即一个CONSTANT_Class_info类型的符号引用。</p><h3 id="interfaces-count（接口计数器"><a href="#interfaces-count（接口计数器" class="headerlink" title="interfaces_count（接口计数器)"></a>interfaces_count（接口计数器)</h3><p>接口计数器表示该类或接口实现的接口数量</p><h3 id="interfaces（接口表）"><a href="#interfaces（接口表）" class="headerlink" title="interfaces（接口表）"></a>interfaces（接口表）</h3><p>一个数据项类型为u2的集合，每一项表示指向常量池中接口的索引，即一个CONSTANT_Class_info类型的符号引用。</p><h3 id="fields-count（字段计数器）"><a href="#fields-count（字段计数器）" class="headerlink" title="fields_count（字段计数器）"></a>fields_count（字段计数器）</h3><p>字段计数器表示类或接口声明的变量的数量，不包括方法中声明的变量。</p><h3 id="fields（字段表）"><a href="#fields（字段表）" class="headerlink" title="fields（字段表）"></a>fields（字段表）</h3><p>一个数据项类型为field_info的集合，描述了各个字段，field_info的结构如下：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">access_flags（访问标记，修饰符）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">name_index（常量池中该字段简单名称的索引）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">descriptor_index（常量池中该字段描述符的索引）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">attributes_count</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes</td><td style="text-align:left">attributes_count</td></tr></tbody></table><h3 id="methods-count（方法计数器）"><a href="#methods-count（方法计数器）" class="headerlink" title="methods_count（方法计数器）"></a>methods_count（方法计数器）</h3><p>方法计数器表示类或接口中定义的方法数量</p><h3 id="methods（方法表）"><a href="#methods（方法表）" class="headerlink" title="methods（方法表）"></a>methods（方法表）</h3><p>一个数据项类型为method_info的集合，描述了各个方法，field_info的结构如下：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">access_flags（访问标记，修饰符）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">name_index（常量池中该字段简单名称的索引）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">descriptor_index（常量池中该字段描述符的索引）</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">attributes_count</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes</td><td style="text-align:left">attributes_count</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Class文件是一种与平台无关的字节码文件，每一个Class文件都对应一个类或接口的定义信息，它包含了Java虚拟机指令
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://xiepuhuan.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis底层数据结构实现</title>
    <link href="https://xiepuhuan.github.io/2017/08/22/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xiepuhuan.github.io/2017/08/22/Redis底层数据结构实现/</id>
    <published>2017-08-22T14:52:13.000Z</published>
    <updated>2017-08-22T14:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Redis是一个基于内存的非关系型的键值对数据库，因它基于内存的特性所以它的速度比传统的关系型数据库快，除此之外它还具有许多特性：</p><ul><li>支持事务</li><li>支持AOF和RDB持久化</li><li>支持多种数据数据结构</li><li>流水线、发布\订阅功能</li><li>主从复制</li><li>内存回收</li></ul><p>本文讲的是Redis丰富的数据结构的实现原理</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="五种基本类型"><a href="#五种基本类型" class="headerlink" title="五种基本类型"></a>五种基本类型</h2><p>Redis是一个键值对数据库，而键都是字符串（Redis内部实现的简单动态字符串）类型，值有5种基本类型，分别是：</p><ul><li>STRING（字符串）</li><li>LIST（列表）</li><li>SET（集合）</li><li>ZSET（有序集合）</li><li>HASH（哈希）</li></ul><h3 id="不同类型的不同实现"><a href="#不同类型的不同实现" class="headerlink" title="不同类型的不同实现"></a>不同类型的不同实现</h3><table><thead><tr><th>类型</th><th>编码</th></tr></thead><tbody><tr><td>STRING（字符串）</td><td>INT（整型）</td></tr><tr><td>STRING（字符串）</td><td>EMBSTR（简单动态字符串）</td></tr><tr><td>STRING（字符串）</td><td>RAW（简单动态字符串）</td></tr><tr><td>LIST（列表）</td><td>QUICKLIST（快表）</td></tr><tr><td>LIST（列表）</td><td>LINKEDLIST（快表）</td></tr><tr><td>SET（集合）</td><td>INTSET（整数集合）</td></tr><tr><td>SET（集合）</td><td>HT（哈希表）</td></tr><tr><td>ZSET（有序集合）</td><td>ZIPLIST（压缩列表）</td></tr><tr><td>ZSET（有序集合）</td><td>SKIPLIST（跳表）</td></tr><tr><td>HASH（哈希）</td><td>ZIPLIST（压缩列表）</td></tr><tr><td>HASH（哈希）</td><td>HT（哈希表）</td></tr></tbody></table><h2 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h2><p>在Redis中，这5种基本类型的对象都是封装在<code>robj</code>这个结构体中，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数，用于内存回收与对象共享</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过调用createObject方法可以创建其对象</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释下各个属性：</p><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>该属性表示对象的类型，占4个bit，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_HASH 4</span></span><br></pre></td></tr></table></figure><p>在Redis中通过使用<code>TYPE</code>命令可以获得其类型</p><blockquote><p>127.0.0.1:6379&gt; TYPE key</p><p>string</p></blockquote><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>该属性表示该类型的对象具体的实现，这样做的目的是为了使在不同场景下灵活使用不同的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br></pre></td></tr></table></figure><p>在Redis中通过使用<code>OBJECT ENCODING</code>命令可以获得其编码</p><blockquote><p>127.0.0.1:6379&gt; OBJECT ENCODING key</p><p>“embstr”</p></blockquote><h3 id="lru"><a href="#lru" class="headerlink" title="lru"></a>lru</h3><p>该属性记录该对象最近一次被访问的时间，如果服务器打开了<code>maxmemory</code>选项，并且服务器用于内存回收的算法为volatile-lru或allkeys-lru，当占用内存超过maxmemory设置的上限时，最早被访问的会先被释放。</p><p>在Redis中通过使用<code>OBJECT IDLETIME</code>命令可以获得其lru时间</p><blockquote><p>127.0.0.1:6379&gt; OBJECT IDLETIME key</p><p>(integer) 10155</p></blockquote><h3 id="refcount"><a href="#refcount" class="headerlink" title="refcount"></a>refcount</h3><p>该属性有两个作用：</p><ul><li>用于引用计数实现内存回收，该属性值表示对象被多少个程序引用，当对象被创建时，该属性值为1，当该值为0时对象占用的内存会被回收。</li><li>用于对象共享，比如Redis在初始化服务器时就会创建0到9999的字符串对象用于对象共享，每当使用<code>set</code>命令创建一个新字符串对象，如果要创建的字符串已经存在则将指向值的指针指向该字符串对象，并将该对象的<code>refcount</code>加1。</li></ul><blockquote><p>127.0.0.1:6379&gt; OBJECT REFCOUNT key</p><p>(integer) 2</p></blockquote><h2 id="REDIS-STRING（字符串）"><a href="#REDIS-STRING（字符串）" class="headerlink" title="REDIS_STRING（字符串）"></a>REDIS_STRING（字符串）</h2><p>Redis的字符串一共有三种实现方式，分别适用于不同场景，其中有一种实现是简单动态字符串，简称SDS，下面的结构体<code>sdshdr</code>就表示一个SDS，它具有以下几个优点：</p><ul><li>常数时间获取字符串长度</li><li>自动扩容</li><li>预分配空间以减少内存重新分配次数</li><li>二进制安全</li><li>重用部分C语言函数库</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"> <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line"> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line"> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 数据空间</span></span><br><span class="line"> <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="INT"><a href="#INT" class="headerlink" title="INT"></a>INT</h3><p>当字符串保存的是一个可以用long类型来表示的整数时，那么<code>robj</code>对象里的属性<code>ptr</code>的类型<code>void *</code>就会被替换为<code>long</code>，而<code>encoding</code>的值会设置为<code>int</code>表示该字符串的实现方式是整型。</p><blockquote><p>127.0.0.1:6379&gt; SET key 88</p><p>OK</p><p>127.0.0.1:6379&gt; OBJECT ENCODING key</p><p>“int”</p></blockquote><h3 id="EMBSTR"><a href="#EMBSTR" class="headerlink" title="EMBSTR"></a>EMBSTR</h3><p>在目前最新版本中，当字符串保存的是一个小于等于44个字节的字符串时，那么<code>robj</code>对象里的属性<code>ptr</code>就会指向一个SDS对象，而<code>encoding</code>的值会设置为<code>embstr</code>表示该字符串的实现方式是SDS（简单动态字符串）。<code>embstr</code>是一种用来保存短字符串的编码方式，embstr编码通过调用一次内存分配函数来创建一块连续的内存空间，即<code>redisObject</code>对象和它的<code>ptr</code>指针指向的SDS对象是连续的。不过<code>embstr</code>编码的字符串对象是只读性的，一旦对其指向<code>APPEND</code>命令追加字符串会导致其变为<code>raw</code>编码实现。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-7a94c1ce4e65b69a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="embstr编码创建的内存块结构" title="">                </div>                <div class="image-caption">embstr编码创建的内存块结构</div>            </figure><blockquote><p>127.0.0.1:6379&gt; SET key value</p><p>OK</p><p>127.0.0.1:6379&gt; OBJECT ENCODING key</p><p>“embstr”</p></blockquote><h3 id="RAW"><a href="#RAW" class="headerlink" title="RAW"></a>RAW</h3><p>在目前最新版本中，当字符串对象保存的是一个超过44个字节的字符串时，那么<code>robj</code>对象里的属性<code>ptr</code>就会指向一个SDS对象，而<code>encoding</code>的值会设置为<code>raw</code>表示该字符串的实现方式是SDS（简单动态字符串）。<code>raw</code>编码的字符串对象是可读可写的，对其指向<code>APPEND</code>命令追加字符串会不会导致其实现改变，如果追加的字符串的长度超过其<code>free</code>属性值，会在追加前重新进行内存空间分配。</p><blockquote><p>127.0.0.1:6379&gt; SET key value</p><p>OK</p><p>127.0.0.1:6379&gt; OBJECT ENCODING key</p><p>“raw”</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;Redis是一个基于内存的非关系型的键值对数据库，因它基于内存的特性所以它的速度比传统的关系型数据库快，除此之外它还具有
      
    
    </summary>
    
      <category term="Redis" scheme="https://xiepuhuan.github.io/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>超文本传输协议(HTTP)</title>
    <link href="https://xiepuhuan.github.io/2017/08/22/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE(HTTP)/"/>
    <id>https://xiepuhuan.github.io/2017/08/22/超文本传输协议(HTTP)/</id>
    <published>2017-08-22T13:55:21.000Z</published>
    <updated>2017-08-22T13:55:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>HTTP是位于应用层的一个无状态的协议，默认HTTP的端口号为80，HTTPS的端口号为443。HTTP协议本身是不可靠的实现，要实现可靠地数据传输需要依靠底层的TCP协议。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><p>HTTP的报文包括<strong>请求报文</strong>和<strong>响应报文</strong>两种</p><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>请求报文是浏览器向服务器发出请求的报文，由第一行的请求行和后面的首部行组成，每一行都由回车换行(\r\n)结尾，当请求的方法是POST的时候，会在首部行结尾再回车换行加上POST携带的实体数据。</p><blockquote><p>请求行 \r\n<br>首部行 \r\n<br>\r\n<br>实体行</p></blockquote><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><ul><li>方法字段：<ul><li>GET（主要方法）</li><li>POST</li><li>HEAD</li><li>PUT</li><li>DELETE</li></ul></li><li>URI字段：请求对象的标识</li><li>HTTP版本字段：有HTTP/1.0和HTTP/1.1两种</li></ul><h3 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h3><ul><li>Host：要访问的主机名</li><li>Connection：值为keep-alive表示该连接为持续连接，为close表示非持续连接。</li><li>Accept： 可接受的MIME类型，即报文类型。</li><li>User-Agent: 用户代理， 表示请求的浏览器的类型。</li><li>Referer: 表示发出请求时处于哪个页面，可用做反盗链。</li><li>Accept-Encoding: 告诉服务器自己接受的页面编码。</li><li>Accept-Language: 告诉服务器自己接受的网页语言。</li><li>Cookie: 将服务器存储在浏览器本地的Cookie值发送给服务器，实现无状态的。HTTP协议的会话跟踪。</li></ul><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>请求报文是服务器向浏览器发出响应报文，由第一行的状态行、接着首部行、最后的实体行组成，每一行都由回车换行(\r\n)结尾，其中实体行就是请求的数据。</p><blockquote><p>状态行 \r\n<br>首部行 \r\n<br>\r\n<br>实体行</p></blockquote><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><ul><li>协议版本：有HTTP/1.0和HTTP/1.1两种</li><li>状态码：<ul><li>200：成功。</li><li>301：内容已经永久移动，浏览器会重定向到响应指定的新URI。</li><li>302：内容临时移动</li><li>304：内容未被修改，响应不包含内容</li><li>400：请求不能被服务器理解。</li><li>403：无权访问该文件。</li><li>404：不能找到请求文件。</li><li>500：服务器内部错误。</li><li>501：服务器不支持请求的方法。</li><li>505：服务器不支持请求的版本。</li></ul></li><li>状态信息：状态码的含义</li></ul><h3 id="首部行-1"><a href="#首部行-1" class="headerlink" title="首部行"></a>首部行</h3><ul><li>Connection：值为keep-alive表示该连接为持续连接，为close表示非持续连接。</li><li>Date：表示报文发送的时间。</li><li>Server：Web服务器用来处理请求的软件信息。</li><li>Cache-control：缓存控制</li><li>ETag：响应对象的标识符</li><li>Last-Modfied：对象创建或者最后修改的时间。</li><li>Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。</li><li>Content-Length：被发送的对象的字节数。</li><li>Content-Type：表示响应的实体行的对象类型。</li></ul><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><p>HTTP的缓存机制是通过<strong>Cache-control</strong>字段来控制，<strong>Cache-control</strong>是一个通用首部，请求和响应的首部都可以使用，有几个常见的值：</p><ul><li>private：          只允许发出请求的客户端缓存</li><li>public：             允许客户端和代理服务器缓存</li><li>max-age=x：       缓存的有效期为x秒</li><li>no-cache：        不直接使用缓存，使用前得向服务器发出请求验证缓存有效性<ul><li>If-None-Match/Etag：当缓存的内容具有Etag标识，就向服务器发送含有If-None-Match字段的请求报文以判断缓存的内存是否与服务器上的内容一致，如果一致，服务器就会返回304状态的响应报文表示可以直接使用缓存，否则返回200状态含有新资源实体的响应报文。</li><li>If-Modified-Since/Last-Modified：当缓存的内容具有Last-Modified（最后修改时间），就向服务器发送含有If-Modified-Since字段的请求报文以判断缓存的内存在服务器上的是否改变，如果时间一致，就会返回304状态的响应表示可以直接使用缓存，否则返回200状态含有新资源实体的响应报文。</li></ul></li><li>no-store：          所有内容都不会缓存</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-b10e2f4c91e27467.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTP缓存的使用" title="">                </div>                <div class="image-caption">HTTP缓存的使用</div>            </figure><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS中的S指的是SSL（安全套接字层）或TLS（传输层安全），TLS是基于SSL开发的。</p><h3 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h3><p>HTTP属于不安全的通信协议：</p><ul><li>使用明文不加密，内容容易被窃读</li><li>不能验证对方身份，对方可能是一个伪装的通讯方</li><li>无法验证报文的完整性，报文可能被篡改</li></ul><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>要解决第一个问题必须采用加密算法对报文进行加密，常见的加密算法有对称加密(AES算法，加密解密使用同一把秘钥)、非对称加密(RSA算法，加密和解密采用不同秘钥)，HTTPS采用混合加密算法集合和两者的优点。由于非对称加密开销比对称加密大，所以通信过程中报文的加密采用对称加密，而非对称加密用于一开始共享秘钥的传输。</p><h3 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h3><ul><li>客户端发出请求报文，报文包含客户端支持的SSL协议版本、加密算法。</li><li><p>服务器发送数字证书，数字证书可以向数字证书认证机构申请，证书包含以下内容：</p><ul><li>证书的发布机构CA</li><li>证书的有效期</li><li>证书所有人的名称</li><li>公开秘钥</li><li>签名算法</li><li>数字签名（证书内容摘要值的加密结果）</li></ul></li><li><p>客户端收到证书后验证证书的合法性。数字签名是数字证书机构使用私钥进行加密的结果，得在浏览器本地可以找到对应的公钥进行解密，为了保证证书没有被篡改，客户端会根据签名算法计算出证书内容的摘要值（哈希算法），如与解密后的数字签名一致的话就证明内容没有被篡改并且对方是一个合法通信方。</p></li><li><p>随后客户端产生一个<code>pre-master secret</code>的随机数用于对称加密，使用数字证书里的公开秘钥对随机数加密并发送给服务器。</p></li><li><p>服务器收到包含共享秘钥的报文后用自己的私钥解密得到共享秘钥。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;HTTP是位于应用层的一个无状态的协议，默认HTTP的端口号为80，HTTPS的端口号为443。HTTP协议本身是不可靠
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://xiepuhuan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库基本概念</title>
    <link href="https://xiepuhuan.github.io/2017/08/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://xiepuhuan.github.io/2017/08/22/数据库基本概念/</id>
    <published>2017-08-22T03:41:30.000Z</published>
    <updated>2017-08-22T03:41:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>事务也是在存储引擎层实现的，可以这么说，事务本质就是一组SQL语句，但是这些SQL语句要么全部执行，要么都不执行。<br>为了保证数据完整性，数据库系统必须维护下面四个性质（即ACID）：</p><ul><li><strong>原子性：</strong>一个事务是不可分割的，要么事务中的SQL语句全部成功提交，要么全部回滚。</li><li><strong>一致性：</strong>数据库从一个一致的状态转移到另一个一致的状态，前后数据库的完整性没有被破坏。</li><li><strong>隔离性：</strong>多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行。数据库系统中有4种隔离级别。</li><li><strong>持久性</strong>：事务提交后，所做的修改会一直保存在数据库中。</li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>MySQL中开始一个事务并提交的过程如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p><p>如果想回滚来撤销开始事务之后的SQL语句可以使用<strong>ROLLBACK</strong>，不过不可以撤销<strong>SELECT、CREATE、DROP</strong>的操作。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>事务的隔离性一共有<strong>4个隔离级别</strong>：</p><ul><li><p><strong>READ UNCOMMITTED（未提交读）：</strong>对事务的修改即使还未提交，对其他事务也是可见的，即可以读取未提交的数据，会出现脏读的情况。</p></li><li><p><strong>READ COMMITTED（提交读）：</strong>事务从开始到提交前所做的修改对其他事务是不可见的，但是执行同样的查询可能会出现不一样的结果，所以也叫<strong>不可重复读</strong>。</p></li><li><p><strong>REPEATABLE READ（可重复读）：</strong>可重复读是MySQL事务的默认隔离级别，它解决了脏读的问题，并且保证执行同样的查询的结果相同。</p></li><li><p><strong>SERIALIZABLE（可串行化）：</strong>强制事务串行执行，数据一致性好，但会导致大量锁竞争的问题，并发性弱。</p></li></ul><h3 id="ANSI-SQL隔离级别"><a href="#ANSI-SQL隔离级别" class="headerlink" title="ANSI SQL隔离级别"></a>ANSI SQL隔离级别</h3><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读可能性</th><th style="text-align:center">不可重复读可能性</th><th style="text-align:center">幻读可能性</th><th style="text-align:center">加锁读</th></tr></thead><tbody><tr><td style="text-align:center">READ UNCOMMITTED（未提交读）</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">READ COMMITTED（提交读）</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">REPEATABLE READ（可重复读）</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">SERIALIZABLE（可串行化）</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr></tbody></table><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读是指当某个事物前后执行两条SQL查询语句查询记录，发现前后查询的记录不一致，这时可能其他事务在两次查询之间插入了新记录。MySQL的InnoDB存储引擎通过<strong>多版本并发控制(MVCC)</strong>解决了幻读问题。</p><h1 id="2-范式"><a href="#2-范式" class="headerlink" title="2. 范式"></a>2. 范式</h1><p>范式是关系数据库理论的基础，也是在设计数据库结构过程中所要遵循的规则和指导方法。目前共有8种范式：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。通常所用到的基本是前三个范式：</p><h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h2><p>第一范式指的是字段的原子性，即字段不可再分，但这取决于所面临的场景，如姓名这个字段其实可以分为姓氏和名字。</p><h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h2><p>第二范式要求要有主键约束，即每一条记录都是唯一的，并且其他字段完全依赖于主键。</p><h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h2><p>第三范式即消除传递依赖，非主键字段直接依赖于主键字段。例如在学生表中存在学号、姓名、年龄等字段，其中主键为学号，这时所有非主键字段都直接依赖于学号，这时如果将系编号、系别、系主任加到学生表中就出现传递依赖了，具体就是系别、系主任直接依赖与系编号，而系编号依赖于主键，这时应该通过拆分形成学生表和系别表从而消除传递依赖。</p><h1 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h1><p>索引之于数据库犹如目录之于书籍，在MySQL中，索引在存储引擎层实现，索引可以用于快速查找到特定的记录。索引是存储某列或某几列字段的数据结构，这种数据结构有多种实现方式，如：B树、B+树、哈希表，在MySQL中的默认存储引擎<strong>InnoDB</strong>默认使用B+树来实现索引。</p><h1 id="4-存储引擎"><a href="#4-存储引擎" class="headerlink" title="4. 存储引擎"></a>4. 存储引擎</h1><h5 id="查看当前支持的存储引擎"><a href="#查看当前支持的存储引擎" class="headerlink" title="查看当前支持的存储引擎"></a>查看当前支持的存储引擎</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span></span><br></pre></td></tr></table></figure><h5 id="更改表使用的存储引擎"><a href="#更改表使用的存储引擎" class="headerlink" title="更改表使用的存储引擎"></a>更改表使用的存储引擎</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>MySQL默认的存储引擎就是InnoDB，它具有以下特性：</p><ul><li>事务</li><li>行级锁</li><li></li></ul><p>*</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-事务&quot;&gt;&lt;a href=&quot;#1-事务&quot; class=&quot;headerlink&quot; title=&quot;1. 事务&quot;&gt;&lt;/a&gt;1. 事务&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;
      
    
    </summary>
    
      <category term="MySQL" scheme="https://xiepuhuan.github.io/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>红黑树(Red-Black-Tree)</title>
    <link href="https://xiepuhuan.github.io/2017/08/21/%E7%BA%A2%E9%BB%91%E6%A0%91(Red-Black-Tree)/"/>
    <id>https://xiepuhuan.github.io/2017/08/21/红黑树(Red-Black-Tree)/</id>
    <published>2017-08-21T06:41:23.000Z</published>
    <updated>2017-08-21T06:41:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是二叉查找树的变种之一。它是在1972年由<strong>Rudolf Bayer</strong>发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 <strong>Leo J. Guibas</strong> 和 <strong>Robert Sedgewick</strong>修改为如今的“红黑树”。 2008年 <strong>Robert Sedgewick</strong> 对其进行了改进，并命名为 <strong>LLRBT</strong>(Left-leaning Red Black Tree 左倾红黑树)。左倾红黑树相比1978年的红黑树要简单很多，实现的代码量也少很多。<strong>Robert Sedgewick</strong>也是<em>Algorithms</em>（中文版叫《算法》）这本书的作者，在这本书中就讲了基于2-3树的左倾红黑树。</li><li>现在的使用的工程代码中的红黑树都是基于78年的算法，比如JDK中的<strong>TreeMap</strong>。其实红黑树就是2-3-4树的具体实现，所以要想理解红黑树就得先理解2-3-4树。而08年左倾红黑树则是基于2-3树。</li></ul><h1 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h1><p>红黑树是2-3-4树的实现，所以在讲红黑树之前想讲下2-3-4树有助于理解红黑树。<br>因为红黑树是一棵自平衡二叉搜索树，通过结点颜色改变和局部旋转来维持平衡，所以除了一些会改变树结构的操作之外，其他的操作都和普通的二叉搜索树相同。因此这里就只讲插入删除操作。<br>因为我要用红黑树实现一个符号表，所以结点需要存储键值对，而且实现的红黑树是基于2-3-4树。</p><h3 id="2-3-4树的定义"><a href="#2-3-4树的定义" class="headerlink" title="2-3-4树的定义"></a>2-3-4树的定义</h3><ul><li>2-3-4树可以存在三种类型结点。</li><li>2-结点是一个结点有2条链接和1个键，其中两条链接对应于二叉搜索树中的左右链接。</li><li>3-结点是一个结点有3条链接和2个键。</li><li>4-结点是一个结点有4条链接和3个键。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-9f2094def1e7f1af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一棵2-3-4树" title="">                </div>                <div class="image-caption">一棵2-3-4树</div>            </figure><h3 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h3><ol><li>每个结点都有颜色，不是黑色就是红色。</li><li>根结点是黑色的。</li><li>如果一个空结点都是黑色的。</li><li>如果一个结点是红色的，则与它相连的结点都只能是黑色的，也就是不可以有两个红色结点相连。</li><li>每个空结点到根结点的简单路径中所含的黑色结点数目相同。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-3ce1f178b57e2bf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一棵红黑树" title="">                </div>                <div class="image-caption">一棵红黑树</div>            </figure><p>通过观察以上两图基本能看出两者的关系了</p><ul><li>第一张图已经存在三种结点了，其中1和3都是2-结点，2和4构成一个3-结点，5和6和7构成一个4-结点。</li><li>第二张图则是第一张图中2-3-4树在红黑树的表现形式。<br>现在我总结一下2-3-4树中三种结点在红黑树中的表示：</li><li><strong>2-结点</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-7d6327f702e6ea9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2-结点" title="">                </div>                <div class="image-caption">2-结点</div>            </figure><ul><li><strong>3-结点</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-65e30c6667f02d24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-结点" title="">                </div>                <div class="image-caption">3-结点</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-225b46b5fe046c8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-结点" title="">                </div>                <div class="image-caption">3-结点</div>            </figure><ul><li><strong>4-结点</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-b97b09d5224246ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4-结点" title="">                </div>                <div class="image-caption">4-结点</div>            </figure><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><p>实现部分的代码用Java</p><h3 id="结点的定义"><a href="#结点的定义" class="headerlink" title="结点的定义"></a>结点的定义</h3><p>每个结点的类型是Node，里面有5个字段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node left, Node right, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>当我们想要在树中插入一个新结点时，先在树中搜索与插入结点键相同的结点。</p><ol><li>如果找到该结点则直接修改对应的<code>Value</code>字段就完成了。</li><li><p>如果找不到该结点则创建一个新的结点并把这个新结点设置为红色（因为插入一个红色结点不会改变红黑树的性质5），随后插到对应树底部对应的结点下。然而插入树底部对应结点下，那这个对应的结点有三种可能，分别是上面说到的2-，3-，4-结点。</p><ul><li>如果插到2-结点下，由于2-结点是黑色结点则不会破坏红黑树的任何性质，所以不用做任何操作就完成了。</li><li><p>如果插到3-结点下，从上面3-结点的图看，3-结点有三个位置可以插入。</p><ul><li>如果插入黑色结点的位置下则变成4-结点也不用做任何操作就完成了。</li><li>如果插到3-结点的红色结点下，则破坏了红黑树的性质4。如下图新插入的<strong><code>0003</code></strong>结点，因为插入位置在右边，则需要对<strong><code>0001</code></strong>做一个左旋操作：<br><img src="http://upload-images.jianshu.io/upload_images/4750376-a72a308e415bced6.gif?imageMogr2/auto-orient/strip" alt="左旋"></li></ul><ul><li>如果插入位置在左边，如下图新插入的<strong><code>0002</code></strong>结点。则需要对插入结点的父节点做一个右旋操作，再对<strong><code>0001</code></strong>做一个左旋操作：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-d9f2958d5d1ebf7f.gif?imageMogr2/auto-orient/strip" alt="先右旋再左旋" title="">                </div>                <div class="image-caption">先右旋再左旋</div>            </figure></li></ul></li></ul><ul><li>无论插到4-结点的哪个地方都会破坏性质4，这时只要将4-结点分解为两个2-结点并将中间结点往上传给父结点。如下图新插入的<strong><code>0004</code></strong>结点：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-81b6929e951d706f.gif?imageMogr2/auto-orient/strip" alt="分解4-结点" title="">                </div>                <div class="image-caption">分解4-结点</div>            </figure></li></ul></li></ol><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>首先要删除一个结点的话，这个结点有两种可能的颜色：</p><ol><li>删除一个红色结点不会破坏红黑树的任何性质，可以像删除普通二叉树搜索树结点一样删除</li><li><p>如果删除的是一个黑色结点则会破坏红黑树的性质5，所以我们只要保证删除的结点是红色的就不会破坏红黑树的性质。具体步骤如下：<br>在自顶向下搜索要删除结点过程中，保证当前结点是红色的。如果当前结点不是要删除的结点，在接着再往下搜索时判断下一个结点的颜色，定义下一个结点为左结点，（下个结点为右结点的情况与左结点相反）：</p><ul><li>如果下个结点是红色或者为空，则不需要做任何操作</li><li>如果下个结点为黑色且下个结点的兄弟结点也是黑色的话，直接将当前结点和两个子结点合并为一个4-结点。</li><li>如果下个结点为黑色而下个结点的兄弟结点是红色的话，直接对当前结点做一个左旋操作变成一个4-结点。</li></ul></li><li><p>当自顶向下删除完结点后，需要向上回溯消除所有破坏红黑树性质4的情况，这一步通过平衡操作来实现。</p></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span> &lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value, Node left, Node right, <span class="keyword">boolean</span> color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//颜色转换</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        h.color = !h.color;</span><br><span class="line">        h.left.color = !h.left.color;</span><br><span class="line">        h.right.color = !h.right.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationLeft</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node x = node.right;</span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotationRight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node x = node.left;</span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//平衡操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">balance</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right) &amp;&amp; !isRed(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((isRed(node.left.left) || isRed(node.left.right) || isRed(node.right.left) || isRed(node.right.right)))</span><br><span class="line">                flipColors(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRed(node.left))&#123;</span><br><span class="line">                <span class="keyword">if</span> (isRed(node.left.right))</span><br><span class="line">                    node.left = rotationLeft(node.left);</span><br><span class="line">                <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">                    node = rotationRight(node);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isRed(node.right))&#123;</span><br><span class="line">                <span class="keyword">if</span> (isRed(node.right) &amp;&amp; isRed(node.right.left))</span><br><span class="line">                    node.right = rotationRight(node.right);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isRed(node.right) &amp;&amp; isRed(node.right.right))</span><br><span class="line">                    node = rotationLeft(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right) &amp;&amp; !isRed(node)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((isRed(node.left.left) || isRed(node.left.right) || isRed(node.right.left) || isRed(node.right.right)))</span><br><span class="line">                    flipColors(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">max</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">null</span> : max(root).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="keyword">null</span> : min(root).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        root = put(key, value, root);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Key key, Value value, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="keyword">null</span>, <span class="keyword">null</span>, RED);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">            <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                node.left = put(key, value, node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                node.right = put(key, value, node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> balance(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty())&#123;</span><br><span class="line">            root.color = RED;</span><br><span class="line"></span><br><span class="line">            root = deleteMin(root);</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty())</span><br><span class="line">                root.color = BLACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isRed(node.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isRed(node.left) &amp;&amp; !isRed(node.right))</span><br><span class="line">                flipColors(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = rotationLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.left = deleteMin(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> balance(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty())&#123;</span><br><span class="line">            root.color = RED;</span><br><span class="line"></span><br><span class="line">            root = deleteMax(root);</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">if</span> (!isEmpty())</span><br><span class="line">                root.color = BLACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMax</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isRed(node.right)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isRed(node.left) &amp;&amp; !isRed(node.right))</span><br><span class="line">                flipColors(node);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                node = rotationRight(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.right = deleteMax(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> balance(node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty())&#123;</span><br><span class="line">            root.color = RED;</span><br><span class="line"></span><br><span class="line">            root = delete(key, root);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isEmpty())</span><br><span class="line">                root.color = BLACK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Key key, Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; !isRed(node.left)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isRed(node.right))</span><br><span class="line">                    flipColors(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = rotationLeft(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.left = delete(key, node.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span> &amp;&amp; !isRed(node.right)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!isRed(node.left))</span><br><span class="line">                    flipColors(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    node = rotationRight(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.right = delete(key, node.right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> node.right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> node.left;</span><br><span class="line"></span><br><span class="line">            Node x = min(node.right);</span><br><span class="line">            node.key = x.key;</span><br><span class="line">            node.value = x.value;</span><br><span class="line"></span><br><span class="line">            node.right = deleteMin(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> balance(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断树是否为一棵红黑树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRBTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRBTree</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.color == RED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node x = node;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(; x != <span class="keyword">null</span>; x = x.left) &#123;</span><br><span class="line">                <span class="keyword">if</span>(x.color == BLACK) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> isRBTree(node, count, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRBTree</span><span class="params">(Node node, <span class="keyword">int</span> count, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count == k;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">                ||(isRed(node.left) &amp;&amp; isRed(node.left.right))</span><br><span class="line">                ||(isRed(node.right) &amp;&amp; isRed(node.right.right))</span><br><span class="line">                ||(isRed(node.right) &amp;&amp; isRed(node.right.left))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.color == BLACK) &#123;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span> ? k == count:isRBTree(node.left, count, k) &amp;&amp; isRBTree(node.right, count, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//树的中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inTraverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        inTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inTraverse</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inTraverse(node.left);</span><br><span class="line">        System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">        inTraverse(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3000</span>, a;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        RBTree&lt;Integer, String&gt; rbt = <span class="keyword">new</span> RBTree();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            a = random.nextInt(<span class="number">50000</span>);</span><br><span class="line">            rbt.put(a, <span class="string">"naoko"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1500</span>; ++i) &#123;</span><br><span class="line">            rbt.delete(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rbt.isRBTree()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"不是红黑树"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rbt.inTraverse();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"是红黑树"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持树的平衡，从而获得较高的查找性能。不同的是红黑树并不是向AVL树那样追求完美平衡，而是黑色平衡，即从根结点到任意一个空结点的简单路径上黑色结点数都相同。因为一棵红黑树的高度最高不超过<strong><code>2lg(N+1)</code></strong>，因此其查找时间复杂度也是<strong><code>O(lgN)</code></strong>级别的。而对于插入和删除操作产生不平衡情况都会在3次旋转之内快速解决，所以复杂度基本为<strong><code>O(lgN)</code></strong>级别，也因为这一点红黑树的效率比AVL树快。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>红黑树的插入和删除操作都有自顶向下和自顶向上两种方法，其中自顶向下较为容易，我的删除操作实现属于自顶向下的方法。在JDK中的TreeMap中插入和删除就用了自底向上的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;红黑树（Red Black Tree） 是一种自平衡二叉查找树，是二叉查找树的变种之一。它是在1972年由&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://xiepuhuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="https://xiepuhuan.github.io/2017/08/20/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://xiepuhuan.github.io/2017/08/20/Java内存区域/</id>
    <published>2017-08-19T21:46:40.000Z</published>
    <updated>2017-08-19T21:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机(Java Virtual Machine)在执行Java程序时会把它所管理的内存划分为如下5个不同的运行时数据区域。</p><h3 id="1-程序计数器-Program-Counter"><a href="#1-程序计数器-Program-Counter" class="headerlink" title="1. 程序计数器(Program Counter)"></a>1. 程序计数器(Program Counter)</h3><p>对于一个运行中的Java程序来说，每当启动一个线程时都会创建一个属于自己的程序计数器，各个线程之间的计数器互不影响。如果线程执行的是一个方法(非本地方法)，那么计数器记录的是正在执行的虚拟机字节码指令的地址；要是线程执行的是一个本地方法(Native Method)，那么计数器则为空(Undefined)。</p><h3 id="2-虚拟机栈-Virtual-Machine-Stack"><a href="#2-虚拟机栈-Virtual-Machine-Stack" class="headerlink" title="2. 虚拟机栈(Virtual Machine Stack)"></a>2. 虚拟机栈(Virtual Machine Stack)</h3><p>与程序计数器一样，每当启动一个线程时都会创建一个属于自己的虚拟机栈，各个线程之间的虚拟机栈互不影响。线程执行时每调用一个方法，就会创建一个栈帧(Stack Frame)压到虚拟机栈中，当方法执行完正常返回或者抛出异常导致终止都会弹出栈帧。栈帧用于存储本地变量表，操作数栈，动态链接，方法出口等信息。本地变量表的大小在编译时就已经确定并存在于class文件中，在方法运行时大小不会再改变。</p><h3 id="3-堆-Heap"><a href="#3-堆-Heap" class="headerlink" title="3. 堆(Heap)"></a>3. 堆(Heap)</h3><p>堆是所有线程共享的内存区域，几乎所有的对象实例和数组都在堆上分配。</p><h3 id="4-本地方法栈-Native-Method-Stack"><a href="#4-本地方法栈-Native-Method-Stack" class="headerlink" title="4. 本地方法栈(Native Method Stack)"></a>4. 本地方法栈(Native Method Stack)</h3><p>本地方法栈是为执行本地方法服务的。</p><h3 id="5-方法区-Method-Area"><a href="#5-方法区-Method-Area" class="headerlink" title="5. 方法区(Method Area)"></a>5. 方法区(Method Area)</h3><p>方法区是所有线程共享的内存区域，用于存储类信息，常量，静态变量，即时编译器编译后的代码等数据。其中方法区有一个常量池(Constant Pool)，在编译期间确定用于存放编译期生成的字面值常量和符号引用，这部分将在类加载后进入方法区的常量池存放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java虚拟机(Java Virtual Machine)在执行Java程序时会把它所管理的内存划分为如下5个不同的运行时数据区域。&lt;/p&gt;
&lt;h3 id=&quot;1-程序计数器-Program-Counter&quot;&gt;&lt;a href=&quot;#1-程序计数器-Program-Counter
      
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://xiepuhuan.github.io/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList源码解析</title>
    <link href="https://xiepuhuan.github.io/2017/08/19/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://xiepuhuan.github.io/2017/08/19/ArrayList源码解析/</id>
    <published>2017-08-19T06:36:18.000Z</published>
    <updated>2017-08-19T06:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>List是一种支持插入、删除、查找，元素可重复，可为null的数据结构，在JDK中有不同的实现类，其中<strong>ArrayList</strong>基于数组实现，支持随机访问，非线程安全，插入与删除时间复杂度为O(n)。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><p>ArrayList内部是使用数组来实现的，所以可以做到随机访问时间为O(1)，如果不一开始设置好最终的大小，可能在不断添加元素的过程中多次扩容而导致效率问题。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//数组最大大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素存放的数组，设置为transient的目的是序列化对象时忽略该数组，因为数组可能不是存满的，我们只序列化必要的对象以节省空间时间。</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"><span class="comment">//已经添加的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果未给出大小，默认大小是数组大小10，只不过这个大小为10的数组是延迟到添加元素创建的，所以这里</span></span><br><span class="line"><span class="comment">// 一开始数组大小是0。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容函数"><a href="#扩容函数" class="headerlink" title="扩容函数"></a>扩容函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就是默认大小数组延迟创建的开始部分了</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 新数组的大小为旧数组的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增删改查方法"><a href="#增删改查方法" class="headerlink" title="增删改查方法"></a>增删改查方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定位置上的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//范围检查，index超出范围抛出异常</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定位置上的元素并返回旧元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素到列表尾部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容，如需要则扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素到指定索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 范围检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 判断是否需要扩容，如需要则扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 移动元素</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                        size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除指定位置上的元素并返回其值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若存在对象o则移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空所有对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray方法"><a href="#toArray方法" class="headerlink" title="toArray方法"></a>toArray方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制出一个具有原数组所有元素的新数组</span></span><br><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="subList方法"><a href="#subList方法" class="headerlink" title="subList方法"></a>subList方法</h2><p>创建出一个子List，对该List的操作将作用于到原List上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查索引范围是否合法</span></span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h2><p>List接口中存在默认的sort方法，只不过该方法是为LinkedList非基于数组实现的List准备的，所以ArrayList重写了sort方法，通过调用Arrays.sort()方法直接对数组进行排序效率比默认的高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    Arrays.sort((E[]) elementData, <span class="number">0</span>, size, c);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h1><ul><li>ArrayList内部基于数组实现，查找效率非常高，但是当出现大量的插入或删除操作，每次都要移动大量元素，明显效率很低。所以ArrayList应该适合于那种查找操作多于插入删除操作的场景。</li><li>ArrayList比LinkedList节省空间，因为ArrayList核心就是一个存储该类元素的数组。在64位虚拟机下，不开启指针压缩情况下：<ul><li>ArrayList存储元素消耗的空间为 24字节（数组对象头）+ 数组长度 * 8字节</li><li>LinkedList存储元素消耗的空间为 元素数量 * 40字节（结点对象头 + 前后结点指针 + 元素指针）</li><li>总的来说，每存储一个元素，ArrayList平均消耗8个字节的引用空间，而LinkedList除了消耗8个字节的引用空间还要32字节的空间（结点对象头 + 前后结点指针）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;List是一种支持插入、删除、查找，元素可重复，可为null的数据结构，在JDK中有不同的实现类，其中&lt;strong&gt;A
      
    
    </summary>
    
      <category term="JDK源码解析" scheme="https://xiepuhuan.github.io/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>ConCurrentHashMap源码解析</title>
    <link href="https://xiepuhuan.github.io/2017/08/19/ConCurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://xiepuhuan.github.io/2017/08/19/ConCurrentHashMap源码解析/</id>
    <published>2017-08-18T23:33:59.000Z</published>
    <updated>2017-08-18T23:33:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>在之前写了<a href="https://naokokawai.github.io/2017/10/15/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">HashMap源码解析</a>介绍了<code>HashMap</code>这个数据结构，可惜它并不是线程安全的，在多线程情况下最好还是使用<code>ConCurrentHashMap</code>。在JDK8中它使用了CAS+synchronized实现来保证线程安全，而在JDK7中它使用了分段锁的实现方式来保证线程安全。下面我来剖析下它源码：</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="类继承结构"><a href="#类继承结构" class="headerlink" title="类继承结构"></a>类继承结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node数组最大大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// Node数组最大大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 最大数组大小，只在toArray方法中使用</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 默认并发级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 链表转换为红黑树链表长度的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 红黑树转换为链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 链表转换为红黑树数组大小的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 帮助扩容的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// forwarding结点的Hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 树根结点的Hash值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node结点的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; -1表示有-(sizeCtl + 1)个线程在扩容</span></span><br><span class="line"><span class="comment">// == -1表示数组在初始化</span></span><br><span class="line"><span class="comment">// 大于0表示并且数组为初始化表示要初始化数组的大小，否则表示扩容的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></figure><h2 id="结点类型"><a href="#结点类型" class="headerlink" title="结点类型"></a>结点类型</h2><h3 id="链表结点类型"><a href="#链表结点类型" class="headerlink" title="链表结点类型"></a>链表结点类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 使用volatile修饰来保证变量在多线程下的可见性</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在以当前结点开始的链表中寻找含有k这个键的结点</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树结点类型"><a href="#红黑树结点类型" class="headerlink" title="红黑树结点类型"></a>红黑树结点类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">                TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出键为k的结点</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">        * starting at given root.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放红黑树的结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first; <span class="comment">// TreeNode根结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;  <span class="comment">// 等待线程</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState; <span class="comment">// 锁状态</span></span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">            (d = a.getClass().getName().</span><br><span class="line">                compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">            d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                    -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略后面大部分代码</span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在构造函数中并不会创建Node数组，而是延迟到第一次put方法时才创建Node数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                MAXIMUM_CAPACITY :</span><br><span class="line">                tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="comment">// 键值对数量 / 数组大小 &lt;= 加载因子，根据initialCapacity与加载因子求出数组大小</span></span><br><span class="line">    <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// 如果数组大小最大等于数组大小则设置数组初始大小为MAXIMUM_CAPACITY，</span></span><br><span class="line">    <span class="comment">// 否则调用tableSizeFor函数求出一个不小于size的第一个2的n次幂的正整数</span></span><br><span class="line">    <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">    <span class="comment">// 设置要初始化的数组大小</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出一个不小于c的第一个2的n次幂的正整数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = c - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>通过高16位与低16位的异或运算得出新的散列值以减少碰撞几率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入键值对，如果键已存在，默认更改其值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 键与值不得为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 计算出键的散列值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">// 指定数组位置上结点的个数</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过使用循环直到添加成功退出循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组未初始化，则调用initTable方法初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">            <span class="comment">// 否则计算出键所在的桶，如果桶为空则调用casTabAt方法尝试在该位置添加结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加结点成功退出循环，否则表示有其他线程也尝试在此位置插入结点，出现冲突</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;<span class="comment">// 如果该位置不为空，并且该结点Hash值为MOVED表示当前正在扩容，调用helpTransfer方法帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 使用synchronized关键字对该头结点进行加锁，只有获取头结点的锁的线程才有资格对该桶的链表或数组添加结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再一次判断加锁的结点是否为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果头结点Hash值大于等于0则表示该桶存放的是链表，遍历链表添加结点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 找到该结点</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 判断是否替换旧值</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="comment">// 否则判断头结点是否为为TreeBin的实例，如果是则该桶存放的是一棵红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用putTreeVal方法添加结点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="comment">// 判断是否替换旧值</span></span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果binCount不等于0则表示添加结点或替换新值成功</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果结点数量大于等于8，将链表树形化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 如果值不为空直接返回旧值</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加新结点成功，调用addCount方法判断是否需要扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h2><p>这个方法是在调用put方法时数组未初始化时调用的，用于创建初始数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 使用循环来保证初始化成功</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果sizeCtl小于0表示数组在初始化或者扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 调用Thread.yield方法尝试让出CPU给其他相同优先级的线程</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="comment">// 否则使用CAS更新SIZECTL为-1，表示要初始化数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再一次判断数组是否未初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 若在构造对象时未给出初始化大小则使用默认大小16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 创建新数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 设置下次扩容阈值为当前数组大小的0.75倍</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 无论是否初始化成功，更新sizeCtl的值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="helpTransfer方法"><a href="#helpTransfer方法" class="headerlink" title="helpTransfer方法"></a>helpTransfer方法</h2><p>当发现数组正在扩容时调用helpTransfer方法帮助数组转移结点到新数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;在之前写了&lt;a href=&quot;https://naokokawai.github.io/2017/10/15/HashMa
      
    
    </summary>
    
      <category term="JDK源码解析" scheme="https://xiepuhuan.github.io/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序(Quick-Sort)</title>
    <link href="https://xiepuhuan.github.io/2017/08/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(Quick-Sort)/"/>
    <id>https://xiepuhuan.github.io/2017/08/18/快速排序(Quick-Sort)/</id>
    <published>2017-08-18T06:10:06.000Z</published>
    <updated>2017-08-18T06:10:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>快速排序是由<strong>C.A.R.Hoare</strong>在1960年发明的。快速排序可能是应用最广泛的排序算法了，快速排序的实现简单，平均时间复杂度是<code>O(NlgN)</code>，而且它是原地排序。其实在快排的实现有一些坑，如果不仔细一点，快排也许就变成慢排了。<br><strong>接下来所讲的排序都是从小到大排序的，代码也是java描述的：</strong></p><p>与归并排序一样，快速排序也采用了分而治之的思想。</p><ol><li>在数组中选取一个元素作为主元</li><li>将数组切分成左右两半，左边一半的元素小于等于主元，右边一半的元素大于等于主元</li><li>将左边排序</li><li>将右边排序</li><li>因为左边已经小于等于右边了，所以当左右两边都排完序，整体也就有序了</li></ol><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换数组中两个元素的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切分数组的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        swap(a, (left + right) / <span class="number">2</span>, left);</span><br><span class="line">        Comparable v = a[left];  <span class="comment">//v是主元</span></span><br><span class="line">        <span class="keyword">int</span> i = left, j = right + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i].compareTo(v) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (i == right)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (a[--j].compareTo(v) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (j == left)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = partition(a, left, right);  <span class="comment">//切分数组，返回切分的位置，也就是主元的位置</span></span><br><span class="line">        sort(a, left, i - <span class="number">1</span>);   <span class="comment">//对数组的左半边排序</span></span><br><span class="line">        sort(a, i + <span class="number">1</span>, right);  <span class="comment">//对数组的右半边排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>辅助函数</strong>：<br>这一段是快速排序的简单实现，还有一些可以优化的地方。先来介绍一下实现过程需要用的辅助函数：</p><ul><li>因为排序过程中需要与主元进行比较且参与排序的元素是类变量，所以要求排序的元素需要实现<code>Comparable</code>接口重写<code>compareTo()</code>函数。</li><li>在与主元比较后可能需要交换位置所以用一个<code>swap()</code>函数交换两个元素的位置。</li></ul><h1 id="3-快速排序性能与复杂度分析"><a href="#3-快速排序性能与复杂度分析" class="headerlink" title="3. 快速排序性能与复杂度分析"></a>3. 快速排序性能与复杂度分析</h1><p>快速排序的运行时间取决于切分是否平衡，而是否平衡又依赖于切分的元素，也就是主元的选择。</p><ul><li><strong>最坏情况</strong><br>假设我们每次选择的主元恰好是待排数组中的极值且元素都不重复时，例如最小值：根据切分函数，指针i在遇到第一个元素就停下来，而<code>j</code>却一直向左遍历直到遇到主元才停下来。最终切分的位置变成了<code>left</code>，切分出一个大小为0的数组和一个大小为<code>n - 1</code>的数组，不烦假设每次都出现这种不平等的切分，切分的操作时间复杂度为<code>O(n)</code>，对一个大小为0的数组递归调用排序会直接返回，因此T(0) = O(1)。于是算法的运行时间的递归式可表达为：T(n) = T(0) + T(n - 1) + O(n) = T(n - 1) + O(n)，T(n)的解是<code>O(n^2)</code>。</li><li><strong>最好情况</strong><br>最好的情况是每次切分后的两个数组大小都不大于<code>n / 2</code>时，这时一个的数组的大小为<code>[n / 2 - 1]</code>，另一个为<code>[n / 2]</code>，此时算法运行时间的递归式为：T(n) = 2T(n / 2) + O(n)，T(n)的解是<code>O(nlgn)</code>。</li><li><strong>平均情况</strong><br>快速排序的平均运行时间其实更接近与最好情况，而非最坏情况。</li></ul><h1 id="4-算法优化"><a href="#4-算法优化" class="headerlink" title="4. 算法优化"></a>4. 算法优化</h1><p> <strong>1. 切换到插入排序</strong></p><ul><li>对于小数组，快速排序比插入排序慢</li><li>因为递归，快速排序的<code>sort()</code>方法在小数组中也会调用自己</li></ul><p>所以可以当数组在大小在M以内时调用插入排序，M的取值可以是5 ~ 15。</p><p><strong>2. 选择合适的主元</strong><br>如我上面所说，假设我们每次选择的主元恰好是待排数组中的极值时，那就是最坏的情况，如果要避免这种情况的发生，那就是要选择合适的主元。我们可以在待排数组取左，中，右3个数，取其中位数作为主元。这样就可以在一定程度上避免最坏情况。</p><p><strong>3. 重复的元素不必排序</strong><br>当数组中存在大量的重复元素时，如果我们用上面所实现的快排，时间复杂度还是要<code>O(nlgn)</code>，这开销是在太大相对于插入排序来说。这时我们可以采用三向切分来实现快排。如下所示：</p><blockquote><pre><code>    left part           center part                   right part* +--------------------------------------------------------------+* |  &lt; pivot   |          ==pivot         |    ?    |  &gt; pivot  |* +--------------------------------------------------------------+*              ^                          ^         ^*              |                          |         |*              lt                         i        gt</code></pre></blockquote><p>通过维持三个指针来控制<code>[left, lt )</code>小于主元(pivot)，<code>[lt, i)</code>等于主元，<code>[i, gt]</code>未知，<code>(gt, right]</code>大于主元。<br>一开始，<code>lt</code>指向主元的位置<code>left</code>，<code>gt</code>指向<code>right</code>，而<code>i</code>从<code>left</code>右边接下来的第一个索引开始遍历，每当遇到一个数，就判断它与主元之间的大小关系，有<strong>三种情况</strong>：</p><ul><li>小于主元就把这个数与<code>lt</code>指向的数交换，然后<code>lt</code>,<code>i</code>都自增1，然后继续遍历</li><li>大于主元就把这个数与<code>gt</code>指向的数交换，<code>gt</code>自减1，此时i还得不能自增，因为它不知道<code>gt</code>用一个什么样的元素跟它交换，所以留到下一次循环判断交换过来的这个元素的去留</li><li>等于主元就不用跟谁进行交换，直接自增1就可以</li></ul><p><strong>三向切分快速排序如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMedian</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i].compareTo(a[j]) &gt; <span class="number">0</span></span><br><span class="line">                ? (a[i].compareTo(a[k]) &lt; <span class="number">0</span> ? i : a[j].compareTo(a[k]) &gt; <span class="number">0</span> ? j : k)</span><br><span class="line">                : (a[i].compareTo(a[k]) &gt; <span class="number">0</span> ? i : a[j].compareTo(a[k]) &lt; <span class="number">0</span> ? j : k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            Comparable value = a[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= left &amp;&amp; value.compareTo(a[j]) &lt; <span class="number">0</span>; --j)</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            a[j + <span class="number">1</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt; <span class="number">15</span>) &#123;</span><br><span class="line">            insertSort(a, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, getMedian(a, left, (left + right) / <span class="number">2</span>, right), left);</span><br><span class="line">        Comparable v = a[left];</span><br><span class="line">        <span class="keyword">int</span> lt = left, i = left + <span class="number">1</span>, gt = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt)&#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                swap(a, lt++, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                swap(a, i, gt--);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(a, left, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">10000000</span>;</span><br><span class="line">        Integer[] a = <span class="keyword">new</span> Integer[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i)</span><br><span class="line">            a[i] = <span class="number">88</span>;</span><br><span class="line">        sort(a);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-注意："><a href="#5-注意：" class="headerlink" title="5. 注意："></a>5. 注意：</h1><p>目前所实现的三向切分并不完美，虽然它解决了大量重复元素的不必要排序，将排序时间从线性对数级别降到线性级别，但它在数组元素重复不多的情况下，它的交换次数比标准的二分法多很多。不过在90年代<strong>J.Bently</strong>和<strong>D.Mcllroy</strong>找到一个聪明的办法解决了这个问题。接下来的快速三向切分就是解决办法。</p><h2 id="快速的三向切分"><a href="#快速的三向切分" class="headerlink" title="快速的三向切分"></a>快速的三向切分</h2><blockquote><pre><code>*   left part         center part                  right part* +----------------------------------------------------------+* | == pivot |  &lt; pivot  |    ?    |  &gt; pivot    | == pivot |* +----------------------------------------------------------+*            ^           ^         ^             ^*            |           |         |             |  *            p           i         j             q</code></pre></blockquote><p>在这个算法中，<code>[p, i)</code>里面的元素小于主元，<code>(j, q]</code>里面的元素大于主元，而左右两端<code>[left, p)</code>和<code>(q, right]</code>等于主元。在算法一开始，<code>p</code> 和 <code>i</code>都指向<code>left</code>后面的第一个元素， <code>j</code>和<code>q</code>都指向<code>right</code>，先把i从左到右遍历时每遇到一个元素都会有<strong>三种情况：</strong></p><ul><li>等于主元，这时只要与<code>p</code>指向的元素交换然后各自自增1即可</li><li>小于主元，这就是指针<code>p</code>和<code>i</code>所要维护的元素，直接把<code>i</code>自增1跳过就可以</li><li>大于主元，这时就是<code>j</code>和<code>q</code>所要维护的元素，先退出循环等待与他们交换</li></ul><p>同理，对于<code>j</code>从<code>right</code>向左遍历也是一样。当 <code>i &gt; j</code> 时，切分也就结束，最后还要把数组调整为左边小右边大，中间等于主元的形式，再依次排序左边和右边。在这个算法中，既解决了重复元素排序的问题，又解决了少量元素重复时，交换次数过多的问题。接下来是我的实现，不过我觉得我有些地方实现的不太好，凑合着用吧。</p><h2 id="快速的三向切分的实现"><a href="#快速的三向切分的实现" class="headerlink" title="快速的三向切分的实现"></a>快速的三向切分的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick3WayPartitionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取中位数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMedian</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[i].compareTo(a[j]) &gt; <span class="number">0</span></span><br><span class="line">                ? (a[i].compareTo(a[k]) &lt; <span class="number">0</span> ? i : a[j].compareTo(a[k]) &gt; <span class="number">0</span> ? j : k)</span><br><span class="line">                : (a[i].compareTo(a[k]) &gt; <span class="number">0</span> ? i : a[j].compareTo(a[k]) &lt; <span class="number">0</span> ? j : k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            Comparable value = a[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= left &amp;&amp; value.compareTo(a[j]) &lt; <span class="number">0</span>; --j)</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            a[j + <span class="number">1</span>] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调整数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjust</span><span class="params">(Comparable[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> toStart)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i)</span><br><span class="line">            swap(a, i, toStart++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        temps = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            insertSort(a, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, getMedian(a, left, (left + right) / <span class="number">2</span>, right), left);</span><br><span class="line">        Comparable v = a[left];</span><br><span class="line">        <span class="keyword">int</span> p = left + <span class="number">1</span>, i = p, j = right, q = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j)&#123;</span><br><span class="line">                <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">                <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">                    swap(a, i++, p++);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    i++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= j)&#123;</span><br><span class="line">                <span class="keyword">int</span> cmp = a[j].compareTo(v);</span><br><span class="line">                <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">                    swap(a, j--, q--);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    j--;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                swap(a, i++, j--);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p - left &gt; i - p)</span><br><span class="line">            adjust(a, p, i - <span class="number">1</span>, left);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            adjust(a, left, p - <span class="number">1</span>, left + i - p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right - q &gt; q - j)</span><br><span class="line">            adjust(a, j + <span class="number">1</span>, q, right - q + j);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            adjust(a, q + <span class="number">1</span>, right, j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        sort(a, left, left + i - p - <span class="number">1</span>);</span><br><span class="line">        sort(a, right + j - q - <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-最后"><a href="#6-最后" class="headerlink" title="6. 最后"></a>6. 最后</h1><p>快速排序不是稳定的排序算法，所谓稳定就是当待排数组中存在重复元素的时候，排序后重复元素的相对顺序不会改变。在多关键字排序时，稳定的排序算法就很有用处。比如当一个学生按照学号先排序，然后再根据成绩进行排序，因为成绩存在重复的值，此时稳定的排序算法就会导致排序后具有相同成绩的学生按照学号排序，不会混乱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;快速排序是由&lt;strong&gt;C.A.R.Hoare&lt;/strong&gt;在1960年发明的。快速排序可能是应用最广泛的排序算
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://xiepuhuan.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>地址解析协议(ARP)</title>
    <link href="https://xiepuhuan.github.io/2017/08/17/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE(ARP)/"/>
    <id>https://xiepuhuan.github.io/2017/08/17/地址解析协议(ARP)/</id>
    <published>2017-08-17T15:42:03.000Z</published>
    <updated>2017-08-17T15:42:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。如果知道其IP地址，则可以通过<strong>ARP（Address Resolution Protocol，地址解析协议）</strong>查询到其MAC地址。ARP仅用于<strong>IPv4</strong>，IPv6使用<strong>ICMPv6</strong>。</p><h1 id="2-ARP帧格式"><a href="#2-ARP帧格式" class="headerlink" title="2. ARP帧格式"></a>2. ARP帧格式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-a0a209f6b4d7eb0c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ARP帧格式" title="">                </div>                <div class="image-caption">ARP帧格式</div>            </figure><p>上图是一个以太网封装上层ARP包后的以太网帧，其中的一些字段，如</p><ul><li>硬件类型：硬件地址类型，如以太网的值为0x0001</li><li>协议类型：映射的协议的地址类型，如IPv4的值为0x0800</li><li>硬件地址长度：硬件地址占多少个字节的长度，如以太网占6个字节，该值就为6</li><li>协议地址长度：协议地址占多少个字节的长度，如IPv4占4个字节，该值就为4</li><li>OP：指出这个ARP包是一个请求或响应包，请求为1，响应为2</li></ul><h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-2859d751afc71ccc.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ARP抓包结果" title="">                </div>                <div class="image-caption">ARP抓包结果</div>            </figure><p>以主机A(192.168.1.103)向所在子网的主机B(192.168.1.101)发送数据为例：</p><ol><li><p>当主机A发送数据时，主机A会在本机的ARP缓存表中寻找是否有主机B的IP地址。</p><ul><li>如果找到就知道主机B的MAC地址为<code>主机B的MAC地址</code>，直接把主机B的MAC地址写入帧首部发送数据。</li></ul></li><li><p>如果在ARP缓存表中没有找到主机B的MAC地址，主机A就会在网络上广播一个ARP请求帧。如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-041576217ae46060.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ARP请求结果" title="">                </div>                <div class="image-caption">ARP请求结果</div>            </figure></li><li><p>同一子网上的主机都会收到这个帧，并且根据ARP包的内容更新自己的ARP缓存表。但只有主机B接收到这个帧时，单播一个目的IP地址为192.168.1.103的ARP响应帧，其他主机则丢弃这个请求帧。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/4750376-2049079723b5a5be.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ARP响应结果" title="">                </div>                <div class="image-caption">ARP响应结果</div>            </figure></li></ol><p>ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。如果知道其IP地址，则可以通过&lt;str
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://xiepuhuan.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>阻塞队列(Blocking-Queue)</title>
    <link href="https://xiepuhuan.github.io/2017/08/17/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97(Blocking-Queue)/"/>
    <id>https://xiepuhuan.github.io/2017/08/17/阻塞队列(Blocking-Queue)/</id>
    <published>2017-08-17T14:14:18.000Z</published>
    <updated>2017-08-17T14:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>阻塞队列顾名思义本质上是一个先进先出的队列，不过阻塞队列是一个并发的容器，是线程安全的，并且在提供常用的队列获取方法之外还提供了阻塞与超时方法。</p><h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h1><h2 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h2><p>现在来回顾一下队列接口<code>Queue</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//添加元素，成功返回true，失败抛出异常java.lang.IllegalStateException: Queue full</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//添加元素，成功返回true，失败返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//移除队头元素，成功返回移除元素值，失败抛出异常java.util.NoSuchElementException</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移除队头元素，成功返回移除元素值，失败返回null</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取队头元素，没有抛出异常java.util.NoSuchElementException</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取队头元素，没有返回null</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockingQueue接口"><a href="#BlockingQueue接口" class="headerlink" title="BlockingQueue接口"></a>BlockingQueue接口</h2><p>而<code>BlockingQueue</code>接口则在<code>Queue</code>的基础上增加了阻塞方法和超时方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//添加元素，如队列已满则一直阻塞直到添加成功返回，该方法可在阻塞过程中响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//添加元素，如队列已满则一直阻塞直到添加成功或超时返回，该方法可在阻塞过程中响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//移除队头元素，如队列为空则一直阻塞直到队列不为空，该方法可在阻塞过程中响应中断</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//移除队头元素，如队列为空则一直阻塞直到移除成功或超时返回，该方法可在阻塞过程中响应中断</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="comment">//一次性从BlockingQueue获取所有可用的元素存储在集合c中</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockingQueue的实现类"><a href="#BlockingQueue的实现类" class="headerlink" title="BlockingQueue的实现类"></a>BlockingQueue的实现类</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/4750376-868b67fbfb29da93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BlockingQueue的实现" title="">                </div>                <div class="image-caption">BlockingQueue的实现</div>            </figure><p>如上图所示，阻塞队列有7个实现：</p><ul><li><code>ArrayBlockingQueue</code> ：一个由数组实现的有界阻塞队列。</li><li><code>LinkedBlockingQueue</code> ：一个由链表实现的有界阻塞队列。</li><li><code>PriorityBlockingQueue</code> ：一个支持优先级排序的无界阻塞队列。</li><li><code>DelayQueue</code>：一个由优先级队列实现的无界延时阻塞队列。</li><li><code>SynchronousQueue</code>：同步队列，一个不存储元素的阻塞队列。</li><li><code>LinkedTransferQueue</code>：一个由链表实现的无界阻塞队列，具有transfer相关方法。</li><li><code>LinkedBlockingDeque</code>：一个由链表实现的双端阻塞队列。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h1&gt;&lt;p&gt;阻塞队列顾名思义本质上是一个先进先出的队列，不过阻塞队列是一个并发的容器，是线程安全的，并且在提供常用的队列获取方法之外
      
    
    </summary>
    
      <category term="JDK源码解析" scheme="https://xiepuhuan.github.io/categories/JDK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
  </entry>
  
</feed>
